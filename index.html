<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>二木</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="personal blog">
<meta property="og:type" content="website">
<meta property="og:title" content="二木">
<meta property="og:url" content="https://qiao666.github.io/index.html">
<meta property="og:site_name" content="二木">
<meta property="og:description" content="personal blog">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Qiao666">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="二木" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 4.2.1"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">二木</a>
        <div style="color: white;padding: 10px;"><span >为什么要去登山？因为山就在那里</span></div>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">主页</a>
        
          <a class="main-nav-link" href="/archives">归档</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS 订阅"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="搜索"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://qiao666.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-剑指offer-56数组中数字出现的次数" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/07/31/%E5%89%91%E6%8C%87offer-56%E6%95%B0%E7%BB%84%E4%B8%AD%E6%95%B0%E5%AD%97%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0/" class="article-date">
  <time class="dt-published" datetime="2020-07-31T09:36:47.000Z" itemprop="datePublished">2020-07-31</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%89%91%E6%8C%87offer/">剑指offer</a>►<a class="article-category-link" href="/categories/%E5%89%91%E6%8C%87offer/56%E6%95%B0%E7%BB%84%E4%B8%AD%E6%95%B0%E5%AD%97%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0/">56数组中数字出现的次数</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/07/31/%E5%89%91%E6%8C%87offer-56%E6%95%B0%E7%BB%84%E4%B8%AD%E6%95%B0%E5%AD%97%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0/">剑指offer-56数组中数字出现的次数</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>题目一<br>一个整型数组 nums 里除两个数字之外，其他数字都出现了两次。请写程序找出这两个只出现一次的数字。要求时间复杂度是O(n)，空间复杂度是O(1)。<br>示例 1：<br>输入：nums = [4,1,4,6]<br>输出：[1,6] 或 [6,1]<br>示例 2：<br>输入：nums = [1,2,10,4,1,4,3,3]<br>输出：[2,10] 或 [10,2]<br>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-lcof" target="_blank" rel="noopener">https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-lcof</a></p>
<p>题目二<br>在一个数组 nums 中除一个数字只出现一次之外，其他数字都出现了三次。请找出那个只出现一次的数字。<br>示例 1：<br>输入：nums = [3,4,3,3]<br>输出：4<br>示例 2：<br>输入：nums = [9,1,7,9,7,9,7]<br>输出：1<br>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-ii-lcof" target="_blank" rel="noopener">https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-ii-lcof</a></p>
<h1 id="算法分析-代码实现"><a href="#算法分析-代码实现" class="headerlink" title="算法分析+代码实现"></a>算法分析+代码实现</h1><p>1 利用set数据结构,一次遍历完成去重，增加新元素操作，注意将结果放在一个新数组中，然后返回该数组，而不是直接返回set</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> singleNumbers = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">set</span>= new Set()</span><br><span class="line">    for(item of nums)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">set</span>.has(item))&#123;</span><br><span class="line">            <span class="keyword">set</span>.delete(item)</span><br><span class="line">        &#125;</span><br><span class="line">        else&#123;</span><br><span class="line">            <span class="keyword">set</span>.add(item)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    let res=[]</span><br><span class="line">    <span class="keyword">set</span>.forEach(item=&gt;&#123;res.push(item)&#125;)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>结果： 时间复杂度O(n),空间复杂度O(n)<br>执行用时：124 ms, 在所有 JavaScript 提交中击败了21.03%的用户<br>内存消耗：43.7 MB, 在所有 JavaScript 提交中击败了11.11%的用户</p>
<p>最优解法：位运算，异或，假设只出现一次的两个值为a,b<br>异或运算 （^）：按位运算，同则为0，不同则为1<br>与运算（&amp;）：a&amp;-a===a&amp;(-a+1)返回一个最右位为1 其余位为0的值<br>依次将数组中每一个值进行异或运算，最后必定得到a^b<br>由于a b 两个值不相等，故一定存在某一位是1<br>则找到为1的位置，然后将原数组中每一个值和该位为1，其余位为0的数进行与运算（&amp;）,则可以根据结果将该数组分成两部分，每一部分只有一个只出现一次的值<br>然后再对每个子数组中的所有元素进行异或运算，最终得到只出现一次的结果</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> singleNumbers = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> sum=<span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span>(item <span class="keyword">of</span> nums)&#123;</span><br><span class="line">        sum^=item</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> mask=sum&amp;(-sum)</span><br><span class="line">    <span class="keyword">let</span> a=<span class="number">0</span>,b=<span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span>(item <span class="keyword">of</span> nums)&#123;</span><br><span class="line">        <span class="keyword">if</span>(item&amp;mask)&#123;</span><br><span class="line">            a^=item</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            b^=item</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> [a,b]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>结果：时间复杂度为O(n),空间复杂度为O(1)<br>执行用时：92 ms, 在所有 JavaScript 提交中击败了41.81%的用户<br>内存消耗：40.6 MB, 在所有 JavaScript 提交中击败了44.44%的用户</p>
<p>2<br>解法一：使用map数据结构</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> singleNumber = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> num <span class="keyword">of</span> nums) &#123;</span><br><span class="line">        <span class="keyword">if</span> (map.has(num)) map.set(num, map.get(num) + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span> map.set(num, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> [num, times] <span class="keyword">of</span> map.entries()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (times === <span class="number">1</span>) <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果：<br>执行用时：96 ms, 在所有 JavaScript 提交中击败了70.35%的用户<br>内存消耗：43.6 MB, 在所有 JavaScript 提交中击败了23.08%的用户</p>
<p>解法二：利用数学公式解决：<br>假设出现一次的数字为a<br>原数组中的出现过的数字为a,b<br>a=(3 * (a+b) - (a+3b))/2<br>a+b可以利用set数据结构得到的数组求和<br>a+3b即是原数组求和的值</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> singleNumber = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">set</span> = new Set()</span><br><span class="line">    for(item of nums)&#123;</span><br><span class="line">        <span class="keyword">set</span>.add(item)</span><br><span class="line">    &#125;</span><br><span class="line">    let setSum=0;</span><br><span class="line">    for(item of <span class="keyword">set</span>)&#123;</span><br><span class="line">        setSum+=item</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> sum=<span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span>(item <span class="keyword">of</span> nums)&#123;</span><br><span class="line">        sum+=item</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">3</span>*setSum-sum)/<span class="number">2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果：时间复杂度为O(n),空间复杂度为O(n)<br>执行用时：100 ms, 在所有 JavaScript 提交中击败了61.76%的用户<br>内存消耗：43.3 MB, 在所有 JavaScript 提交中击败了23.08%的用户</p>
<p>解法三：还是利用位运算<br>每次按照位数（最高 32 位）去考虑，这种方法的关键就是找到对于只出现一次的数字，它的哪些二进制位是 1。</p>
<p>整体算法流程如下：<br>从第 1 位开始<br>创建掩码（当前位为 1，其他为 0），count 设置为 0<br>将每个数字和掩码进行&amp;运算，如果结果不为 0，count 加 1<br>如果 count 整除 3，说明出现一次的数字这一位不是 1；否则，说明出现一次的数字这一位是 1<br>继续检查第 2 位，一直到 32 位，结束</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> singleNumber = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> bit = <span class="number">0</span>; bit &lt; <span class="number">32</span>; ++bit) &#123;</span><br><span class="line">        <span class="keyword">let</span> mask = <span class="number">1</span> &lt;&lt; bit;</span><br><span class="line">        <span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> num <span class="keyword">of</span> nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (num &amp; mask) ++count;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (count % <span class="number">3</span>) &#123;</span><br><span class="line">            res = res | mask;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>结果：时间复杂度O(n)空间复杂度O(1)<br>执行用时：108 ms, 在所有 JavaScript 提交中击败了46.22%的用户<br>内存消耗：40.5 MB, 在所有 JavaScript 提交中击败了38.46%的用户</p>
<h1 id="总结反思"><a href="#总结反思" class="headerlink" title="总结反思"></a>总结反思</h1><p>该题目在复习set，map数据结构的基本数据上，还涉及到了位运算，我一开始真没想到位运算，甚至还有数学算法</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://qiao666.github.io/2020/07/31/%E5%89%91%E6%8C%87offer-56%E6%95%B0%E7%BB%84%E4%B8%AD%E6%95%B0%E5%AD%97%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0/" data-id="ckda7iyrs00006cvaakh0atuc" data-title="剑指offer-56数组中数字出现的次数" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/map/" rel="tag">map</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/set/" rel="tag">set</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/" rel="tag">位运算</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-剑指offer-55二叉树的深度" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/07/31/%E5%89%91%E6%8C%87offer-55%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%B7%B1%E5%BA%A6/" class="article-date">
  <time class="dt-published" datetime="2020-07-31T08:18:23.000Z" itemprop="datePublished">2020-07-31</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%89%91%E6%8C%87offer/">剑指offer</a>►<a class="article-category-link" href="/categories/%E5%89%91%E6%8C%87offer/55%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%B7%B1%E5%BA%A6/">55二叉树的深度</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/07/31/%E5%89%91%E6%8C%87offer-55%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%B7%B1%E5%BA%A6/">剑指offer-55二叉树的深度</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>题目1：<br>输入一棵二叉树的根节点，求该树的深度。从根节点到叶节点依次经过的节点（含根、叶节点）形成树的一条路径，最长路径的长度为树的深度。<br>例如：<br>给定二叉树 [3,9,20,null,null,15,7]，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  3</span><br><span class="line"> &#x2F; \</span><br><span class="line">9  20</span><br><span class="line">  &#x2F;  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure>
<p>返回它的最大深度 3 。<br>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/er-cha-shu-de-shen-du-lcof" target="_blank" rel="noopener">https://leetcode-cn.com/problems/er-cha-shu-de-shen-du-lcof</a></p>
<h1 id="算法分析-代码实现"><a href="#算法分析-代码实现" class="headerlink" title="算法分析+代码实现"></a>算法分析+代码实现</h1><p>考察二叉树的深度，和之前做过的按层遍历二叉树思路基本一样，利用队列，只是这里用到了两个队列，一个出，一个进，保证每次只遍历一层</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> maxDepth = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> nodeArr=[]</span><br><span class="line">    <span class="keyword">let</span> res =<span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span>(!root)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        nodeArr.push(root)</span><br><span class="line">        res++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(nodeArr.length)&#123;</span><br><span class="line">        <span class="keyword">let</span> arr=[]</span><br><span class="line">        <span class="keyword">while</span>(nodeArr.length)&#123;</span><br><span class="line">            node=nodeArr.pop()</span><br><span class="line">            <span class="keyword">if</span>(node)&#123;</span><br><span class="line">                <span class="keyword">if</span>(node.left)&#123;</span><br><span class="line">                arr.push(node.left)</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(node.right)&#123;</span><br><span class="line">                arr.push(node.right)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(arr.length)&#123;</span><br><span class="line">            res++</span><br><span class="line">        &#125;</span><br><span class="line">        nodeArr=arr</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>结果：<br>执行用时：96 ms, 在所有 JavaScript 提交中击败了21.15%的用户<br>内存消耗：41.3 MB, 在所有 JavaScript 提交中击败了14.28%的用户</p>
<p>使用递归的写法如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> maxDepth = <span class="function"><span class="keyword">function</span> (<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.max(maxDepth(root.left), maxDepth(root.right)) + <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>结果：<br>执行用时：92 ms, 在所有 JavaScript 提交中击败了28.85%的用户<br>内存消耗：40.4 MB, 在所有 JavaScript 提交中击败了76.19%的用户</p>
<p>2  根据第一题的递归写法，来得到左右子树的最大深度，然后根据两子树深度差来判断，大于一的话，说明不平衡，直接返回-1，然后一直传递到根节点</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> isBalanced = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> treeDepth(root)&gt;<span class="number">-1</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//-1 不平衡</span></span><br><span class="line"><span class="keyword">var</span> treeDepth = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> leftDepth=treeDepth(root.left)</span><br><span class="line">    <span class="keyword">let</span> rightDepth=treeDepth(root.right)</span><br><span class="line">    <span class="comment">//左子树或者右子树存在不平衡</span></span><br><span class="line">    <span class="keyword">if</span>(leftDepth===<span class="number">-1</span>||rightDepth===<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果左右子树深度差大于1，返回-1</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">Math</span>.abs(leftDepth-rightDepth)&gt;<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回当前结点的深度：子树最大深度+1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.max(leftDepth,rightDepth)+<span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果：<br>执行用时：96 ms, 在所有 JavaScript 提交中击败了43.68%的用户<br>内存消耗：42.5 MB, 在所有 JavaScript 提交中击败了18.75%的用户</p>
<h1 id="总结反思"><a href="#总结反思" class="headerlink" title="总结反思"></a>总结反思</h1><p>递归的求深度函数特别巧妙。<br>学习之路还很漫长啊</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://qiao666.github.io/2020/07/31/%E5%89%91%E6%8C%87offer-55%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%B7%B1%E5%BA%A6/" data-id="ckda7iyta00036cva5wqval9o" data-title="剑指offer-55二叉树的深度" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/" rel="tag">二叉树</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%80%92%E5%BD%92/" rel="tag">递归</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%98%9F%E5%88%97/" rel="tag">队列</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-剑指offer-54二叉搜索树中的第k大结点" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/07/31/%E5%89%91%E6%8C%87offer-54%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E7%AC%ACk%E5%A4%A7%E7%BB%93%E7%82%B9/" class="article-date">
  <time class="dt-published" datetime="2020-07-31T07:54:16.000Z" itemprop="datePublished">2020-07-31</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%89%91%E6%8C%87offer/">剑指offer</a>►<a class="article-category-link" href="/categories/%E5%89%91%E6%8C%87offer/54%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E7%AC%ACk%E5%A4%A7%E7%BB%93%E7%82%B9/">54二叉搜索树中的第k大结点</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/07/31/%E5%89%91%E6%8C%87offer-54%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E7%AC%ACk%E5%A4%A7%E7%BB%93%E7%82%B9/">剑指offer-54二叉搜索树中的第k大结点</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一棵二叉搜索树，请找出其中第k大的节点。<br>示例 1:<br>输入: root = [3,1,4,null,2], k = 1</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  3</span><br><span class="line"> &#x2F; \</span><br><span class="line">1   4</span><br><span class="line"> \</span><br><span class="line">   2</span><br></pre></td></tr></table></figure>
<p>输出: 4<br>示例 2:<br>输入: root = [5,3,6,2,4,null,null,1], k = 3</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">      5</span><br><span class="line">     &#x2F; \</span><br><span class="line">    3   6</span><br><span class="line">   &#x2F; \</span><br><span class="line">  2   4</span><br><span class="line"> &#x2F;</span><br><span class="line">1</span><br></pre></td></tr></table></figure>
<p>输出: 4<br>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-di-kda-jie-dian-lcof" target="_blank" rel="noopener">https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-di-kda-jie-dian-lcof</a></p>
<h1 id="算法分析-代码实现"><a href="#算法分析-代码实现" class="headerlink" title="算法分析+代码实现"></a>算法分析+代码实现</h1><p>考察中序遍历的过程，<br>按照中序遍历的顺序,将结点的值入栈，栈中第k个值即为第k小结点<br>题目找第k大的值，也就是说是逆中序遍历，即先右后左的顺序</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> kthLargest = <span class="function"><span class="keyword">function</span>(<span class="params">root, k</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> arr=[]</span><br><span class="line">    <span class="keyword">let</span> dfs=<span class="function"><span class="keyword">function</span>(<span class="params">root</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root===<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        dfs(root.right)</span><br><span class="line">        arr.push(root.val)</span><br><span class="line">        dfs(root.left)</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(root)</span><br><span class="line">    <span class="comment">// console.log(arr)</span></span><br><span class="line">    <span class="keyword">return</span> arr[k<span class="number">-1</span>]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>结果：<br>执行用时：104 ms, 在所有 JavaScript 提交中击败了25.45%的用户<br>内存消耗：43.6 MB, 在所有 JavaScript 提交中击败了47.62%的用户</p>
<h1 id="总结反思"><a href="#总结反思" class="headerlink" title="总结反思"></a>总结反思</h1><p>二叉搜索树，中序遍历的概念都清楚，才能把代码写出来</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://qiao666.github.io/2020/07/31/%E5%89%91%E6%8C%87offer-54%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E7%AC%ACk%E5%A4%A7%E7%BB%93%E7%82%B9/" data-id="ckda7iysc00016cvae4tq61un" data-title="剑指offer-54二叉搜索树中的第k大结点" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86/" rel="tag">中序遍历</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/" rel="tag">二叉搜索树</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%80%92%E5%BD%92/" rel="tag">递归</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-剑指offer-53在排序数组中查找数字" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/07/30/%E5%89%91%E6%8C%87offer-53%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E6%95%B0%E5%AD%97/" class="article-date">
  <time class="dt-published" datetime="2020-07-30T09:05:04.000Z" itemprop="datePublished">2020-07-30</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%89%91%E6%8C%87offer/">剑指offer</a>►<a class="article-category-link" href="/categories/%E5%89%91%E6%8C%87offer/53%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E6%95%B0%E5%AD%97/">53在排序数组中查找数字</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/07/30/%E5%89%91%E6%8C%87offer-53%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E6%95%B0%E5%AD%97/">剑指offer-53在排序数组中查找数字</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>1：统计一个数字在排序数组中出现的次数。<br>示例 1:<br>输入: nums = [5,7,7,8,8,10], target = 8<br>输出: 2<br>示例 2:<br>输入: nums = [5,7,7,8,8,10], target = 6<br>输出: 0<br>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/zai-pai-xu-shu-zu-zhong-cha-zhao-shu-zi-lcof" target="_blank" rel="noopener">https://leetcode-cn.com/problems/zai-pai-xu-shu-zu-zhong-cha-zhao-shu-zi-lcof</a></p>
<p>2 ：一个长度为n-1的递增排序数组中的所有数字都是唯一的，并且每个数字都在范围0～n-1之内。在范围0～n-1内的n个数字中有且只有一个数字不在该数组中，请找出这个数字。<br>示例 1:<br>输入: [0,1,3]<br>输出: 2<br>示例 2:<br>输入: [0,1,2,3,4,5,6,7,9]<br>输出: 8<br>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/que-shi-de-shu-zi-lcof" target="_blank" rel="noopener">https://leetcode-cn.com/problems/que-shi-de-shu-zi-lcof</a></p>
<h1 id="算法分析-代码实现"><a href="#算法分析-代码实现" class="headerlink" title="算法分析+代码实现"></a>算法分析+代码实现</h1><p>1 利用二分查找的思想，确定该值的下标<br>然后根据下标向左，向右遍历，查询该值出现的次数</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> search = <span class="function"><span class="keyword">function</span>(<span class="params">nums, target</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> left=<span class="number">0</span></span><br><span class="line">    <span class="keyword">let</span> right=nums.length<span class="number">-1</span></span><br><span class="line">    <span class="keyword">let</span> flag=<span class="number">-1</span></span><br><span class="line">    <span class="comment">//小于最小的</span></span><br><span class="line">    <span class="keyword">if</span>(target&lt;nums[<span class="number">0</span>])&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//大于最大的</span></span><br><span class="line">    <span class="keyword">if</span>(target&gt;nums[right])&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(left&lt;=right)&#123;</span><br><span class="line">        mid=<span class="built_in">Math</span>.floor((left+right)/<span class="number">2</span>)</span><br><span class="line">        <span class="keyword">if</span>(nums[mid]&gt;target)&#123;</span><br><span class="line">            right=mid<span class="number">-1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid]&lt;target)&#123;</span><br><span class="line">            left=mid+<span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid]===target)&#123;</span><br><span class="line">            flag= mid</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(nums[left]===target)&#123;</span><br><span class="line">            flag =left</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(nums[right]===target)&#123;</span><br><span class="line">            flag =right</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> res=<span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span>(flag==<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        res++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//从标志位向左找</span></span><br><span class="line">    left=flag</span><br><span class="line">    <span class="keyword">while</span>(left&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">        left--</span><br><span class="line">        <span class="keyword">if</span>(nums[left]===target)&#123;</span><br><span class="line">            res++</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    right=flag</span><br><span class="line">    <span class="keyword">while</span>(right&lt;=nums.length)&#123;</span><br><span class="line">        right++</span><br><span class="line">        <span class="keyword">if</span>(nums[right]===target)&#123;</span><br><span class="line">            res++</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>结果：<br>执行用时：84 ms, 在所有 JavaScript 提交中击败了27.46%的用户<br>内存消耗：38.8 MB, 在所有 JavaScript 提交中击败了53.57%的用户</p>
<p>2 直接利用二分查找，只需排除特殊情况</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> missingNumber = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> left=<span class="number">0</span></span><br><span class="line">    <span class="keyword">let</span> right = nums.length<span class="number">-1</span></span><br><span class="line">    <span class="comment">//特殊情况,长度为1</span></span><br><span class="line">    <span class="keyword">if</span>(!right)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[<span class="number">0</span>]===<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(nums[<span class="number">0</span>]===<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断开头，开头不是0,直接返回0</span></span><br><span class="line">    <span class="keyword">if</span>(nums[<span class="number">0</span>]!=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(left&lt;=right)&#123;</span><br><span class="line">        <span class="keyword">let</span> mid = <span class="built_in">Math</span>.floor((left+right)/<span class="number">2</span>)</span><br><span class="line">        <span class="keyword">if</span>(nums[mid]===mid)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid+<span class="number">1</span>]===mid+<span class="number">1</span>)&#123;</span><br><span class="line">                left = mid+<span class="number">1</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> mid+<span class="number">1</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid]!==mid)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid<span class="number">-1</span>]!==mid<span class="number">-1</span>)&#123;</span><br><span class="line">                right = mid<span class="number">-1</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> mid</span><br><span class="line">            &#125;   </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>结果：<br>执行用时：84 ms, 在所有 JavaScript 提交中击败了42.07%的用户<br>内存消耗：38.8 MB, 在所有 JavaScript 提交中击败了95.83%的用户</p>
<h1 id="总结反思"><a href="#总结反思" class="headerlink" title="总结反思"></a>总结反思</h1><p>该题目的两个小题，复习了二分查找的算法，只要了解了二分查找的基本思想，代码很容易就写出来了</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://qiao666.github.io/2020/07/30/%E5%89%91%E6%8C%87offer-53%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E6%95%B0%E5%AD%97/" data-id="ckd8p07qs0001h8va2lgzayiy" data-title="剑指offer-53在排序数组中查找数字" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/" rel="tag">二分查找</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-剑指offer-52两个链表的第一个公共结点" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/07/30/%E5%89%91%E6%8C%87offer-52%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%85%AC%E5%85%B1%E7%BB%93%E7%82%B9/" class="article-date">
  <time class="dt-published" datetime="2020-07-30T08:13:50.000Z" itemprop="datePublished">2020-07-30</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%89%91%E6%8C%87offer/">剑指offer</a>►<a class="article-category-link" href="/categories/%E5%89%91%E6%8C%87offer/52%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%85%AC%E5%85%B1%E7%BB%93%E7%82%B9/">52两个链表的第一个公共结点</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/07/30/%E5%89%91%E6%8C%87offer-52%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%85%AC%E5%85%B1%E7%BB%93%E7%82%B9/">剑指offer-52两个链表的第一个公共结点</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>输入两个链表，找出它们的第一个公共节点。<br>示例 1：<br>输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3<br>输出：Reference of the node with value = 8<br>输入解释：相交节点的值为 8 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。<br> 示例 2：<br>输入：intersectVal = 2, listA = [0,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1<br>输出：Reference of the node with value = 2<br>输入解释：相交节点的值为 2 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [0,9,1,2,4]，链表 B 为 [3,2,4]。在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。<br> 示例 3：<br>输入：intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2<br>输出：null<br>输入解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。<br>解释：这两个链表不相交，因此返回 null。</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/liang-ge-lian-biao-de-di-yi-ge-gong-gong-jie-dian-lcof" target="_blank" rel="noopener">https://leetcode-cn.com/problems/liang-ge-lian-biao-de-di-yi-ge-gong-gong-jie-dian-lcof</a></p>
<h1 id="算法分析-代码实现"><a href="#算法分析-代码实现" class="headerlink" title="算法分析+代码实现"></a>算法分析+代码实现</h1><p>快慢指针<br>首先要得到两个链表的长度，然后根据长度保证两个链表可以同时遍历到最后节点</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> getIntersectionNode = <span class="function"><span class="keyword">function</span>(<span class="params">headA, headB</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//记录ＡＢ两个链表的长度</span></span><br><span class="line">    <span class="keyword">let</span> aLen=<span class="number">0</span>,bLen=<span class="number">0</span></span><br><span class="line">    <span class="keyword">let</span> head=headA</span><br><span class="line">    <span class="keyword">while</span>(head!=<span class="literal">null</span>)&#123;</span><br><span class="line">        head=head.next</span><br><span class="line">        aLen++</span><br><span class="line">    &#125;</span><br><span class="line">    head=headB</span><br><span class="line">    <span class="keyword">while</span>(head!=<span class="literal">null</span>)&#123;</span><br><span class="line">        head=head.next</span><br><span class="line">        bLen++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(aLen,bLen)</span><br><span class="line">    <span class="comment">//遍历长度为最短链表</span></span><br><span class="line">    len=<span class="built_in">Math</span>.min(aLen,bLen)</span><br><span class="line">    <span class="comment">//exLen保存长链表中多出的节点数</span></span><br><span class="line">    exLen=<span class="built_in">Math</span>.max(aLen,bLen)-len</span><br><span class="line">    <span class="keyword">while</span>(exLen)&#123;</span><br><span class="line">        <span class="keyword">if</span>(aLen&gt;bLen)&#123;</span><br><span class="line">            headA=headA.next</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            headB=headB.next</span><br><span class="line">        &#125;</span><br><span class="line">        exLen--</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//注意是结点相同，而不是结点值相同</span></span><br><span class="line">    <span class="keyword">while</span>(len)&#123;</span><br><span class="line">        <span class="keyword">if</span>(headB===headA)&#123;</span><br><span class="line">            <span class="keyword">return</span> headA</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            headA=headA.next</span><br><span class="line">            headB=headB.next</span><br><span class="line">        &#125;</span><br><span class="line">        len--</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> headB</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>结果：<br>执行用时：112 ms, 在所有 JavaScript 提交中击败了44.87%的用户<br>内存消耗：45.6 MB, 在所有 JavaScript 提交中击败了42.86%的用户</p>
<p>优化版本：最开始的思路，每个链表都需要遍历两次，有些麻烦<br>利用新思路，两个链表只需要遍历一次<br>原理：A =a+c+b,B =b+c+a<br>当两个指针相遇时，必定会停在相交结点，或者二者均是null结点<br>此时返回任意一个结点均可</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> getIntersectionNode = <span class="function"><span class="keyword">function</span>(<span class="params">headA, headB</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> p1 = headA;</span><br><span class="line">    <span class="keyword">let</span> p2 = headB;</span><br><span class="line">    <span class="keyword">while</span>(p1 != p2)&#123;</span><br><span class="line">        p1 = p1 ==<span class="literal">null</span> ? headB :p1.next;</span><br><span class="line">        p2 = p2 ==<span class="literal">null</span> ? headA : p2.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p1;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="总结反思"><a href="#总结反思" class="headerlink" title="总结反思"></a>总结反思</h1><p>首先要明确到底是值相等还是结点相等，我一开始以为是值相等，然后直接就返回了值相等但结点不相等的结点<br>第二个就是要立马想到双指针<br>至于说优化版，看一看，有个印象就好了</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://qiao666.github.io/2020/07/30/%E5%89%91%E6%8C%87offer-52%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%85%AC%E5%85%B1%E7%BB%93%E7%82%B9/" data-id="ckd8p07pw0000h8va1xhqhboz" data-title="剑指offer-52两个链表的第一个公共结点" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%8F%8C%E6%8C%87%E9%92%88/" rel="tag">双指针</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-剑指offer-51数组中的逆序对" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/07/28/%E5%89%91%E6%8C%87offer-51%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%80%86%E5%BA%8F%E5%AF%B9/" class="article-date">
  <time class="dt-published" datetime="2020-07-28T08:50:21.000Z" itemprop="datePublished">2020-07-28</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%89%91%E6%8C%87offer/">剑指offer</a>►<a class="article-category-link" href="/categories/%E5%89%91%E6%8C%87offer/51%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%80%86%E5%BA%8F%E5%AF%B9/">51数组中的逆序对</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/07/28/%E5%89%91%E6%8C%87offer-51%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%80%86%E5%BA%8F%E5%AF%B9/">剑指offer-51数组中的逆序对</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="题目描述（困难）"><a href="#题目描述（困难）" class="headerlink" title="题目描述（困难）"></a>题目描述（困难）</h1><p>在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数。<br>示例 1:<br>输入: [7,5,6,4]<br>输出: 5<br>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof" target="_blank" rel="noopener">https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof</a></p>
<h1 id="算法分析-代码实现"><a href="#算法分析-代码实现" class="headerlink" title="算法分析+代码实现"></a>算法分析+代码实现</h1><p>1 暴力运算，两次遍历</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> reversePairs = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums.length&lt;<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//存储逆序对的值</span></span><br><span class="line">    <span class="keyword">let</span> pairs=<span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">let</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> j=i+<span class="number">1</span>;j&lt;nums.length;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]&gt;nums[j])&#123;</span><br><span class="line">                res++</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>结果：超时，时间复杂度为O(n * * 2),我就说哪会这么简单<br>2 归并排序</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> reversePairs = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 归并排序</span></span><br><span class="line">    <span class="keyword">let</span> sum = <span class="number">0</span>;</span><br><span class="line">    mergeSort(nums);</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">    <span class="comment">//排序函数</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">mergeSort</span> (<span class="params">nums</span>) </span>&#123;</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="keyword">if</span>(nums.length &lt; <span class="number">2</span>) <span class="keyword">return</span> nums;</span><br><span class="line">        <span class="keyword">const</span> mid = <span class="built_in">parseInt</span>(nums.length / <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">let</span> left = nums.slice(<span class="number">0</span>,mid);</span><br><span class="line">        <span class="keyword">let</span> right = nums.slice(mid);</span><br><span class="line">        <span class="keyword">return</span> merge(mergeSort(left), mergeSort(right));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//交换函数</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">merge</span>(<span class="params">left, right</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> res = [];</span><br><span class="line">        <span class="keyword">let</span> leftLen = left.length;</span><br><span class="line">        <span class="keyword">let</span> rightLen = right.length;</span><br><span class="line">        <span class="keyword">let</span> len = leftLen + rightLen;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> index = <span class="number">0</span>, i = <span class="number">0</span>, j = <span class="number">0</span>; index &lt; len; index ++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i &gt;= leftLen) res[index] = right[j ++];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (j &gt;= rightLen) res[index] = left[i ++];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (left[i] &lt;= right[j]) res[index] = left[i ++];</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                res[index] = right[j ++];</span><br><span class="line">                sum += leftLen - i;<span class="comment">//在归并排序中唯一加的一行代码</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="总结反思"><a href="#总结反思" class="headerlink" title="总结反思"></a>总结反思</h1><p>要理解归并排序的思路，最好做到可以自己写出该算法</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://qiao666.github.io/2020/07/28/%E5%89%91%E6%8C%87offer-51%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%80%86%E5%BA%8F%E5%AF%B9/" data-id="ckd8p07t1000mh8vae0ua1pd2" data-title="剑指offer-51数组中的逆序对" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/" rel="tag">归并排序</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-剑指offer-50第一个只出现一次的字符" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/07/28/%E5%89%91%E6%8C%87offer-50%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E5%AD%97%E7%AC%A6/" class="article-date">
  <time class="dt-published" datetime="2020-07-28T08:03:02.000Z" itemprop="datePublished">2020-07-28</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%89%91%E6%8C%87offer/">剑指offer</a>►<a class="article-category-link" href="/categories/%E5%89%91%E6%8C%87offer/50%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E5%AD%97%E7%AC%A6/">50第一个只出现一次的字符</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/07/28/%E5%89%91%E6%8C%87offer-50%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E5%AD%97%E7%AC%A6/">剑指offer-50第一个只出现一次的字符</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>在字符串 s 中找出第一个只出现一次的字符。如果没有，返回一个单空格。 s 只包含小写字母。<br>示例:<br>s = “abaccdeff”<br>返回 “b”<br>s = “”<br>返回 “ “<br>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/di-yi-ge-zhi-chu-xian-yi-ci-de-zi-fu-lcof" target="_blank" rel="noopener">https://leetcode-cn.com/problems/di-yi-ge-zhi-chu-xian-yi-ci-de-zi-fu-lcof</a></p>
<h1 id="算法分析-代码实现"><a href="#算法分析-代码实现" class="headerlink" title="算法分析+代码实现"></a>算法分析+代码实现</h1><p>1 利用hash表，hash表两个值为一对，每对第一个存储字符，第二个存储字符出现的内容，便于第二次按字符串顺序遍历hash表</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> firstUniqChar = <span class="function"><span class="keyword">function</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//s为空，返回该值</span></span><br><span class="line">    <span class="keyword">if</span>(!s.length)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">' '</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> hash=[]</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;s.length;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(hash.indexOf(s[i])&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">            hash[hash.indexOf(s[i])+<span class="number">1</span>]++</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            hash.push(s[i])</span><br><span class="line">            hash.push(<span class="number">1</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;hash.length;i=i+<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(hash[i+<span class="number">1</span>]==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> hash[i]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//hash中不存在只出现一次的值，则返回‘ ’</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">' '</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>结果：<br>执行用时：204 ms, 在所有 JavaScript 提交中击败了6.94%的用户<br>内存消耗：41.2 MB, 在所有 JavaScript 提交中击败了100.00%的用户</p>
<p>2 hash表的优化版，取消了一对的概念，第二次遍历的时候，直接使用s<br>优化了indexof（）方法<br>使用str.charCodeAt()方法，返回该字符的 UTF-16 编码，</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> firstUniqChar = <span class="function"><span class="keyword">function</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//s为空，返回该值</span></span><br><span class="line">    <span class="keyword">if</span>(!s.length)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">' '</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> hash=<span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">128</span>).fill(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;s.length;i++)&#123;</span><br><span class="line">        <span class="keyword">let</span> p=s[i].charCodeAt()</span><br><span class="line">        hash[p]++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;s.length;i++)&#123;</span><br><span class="line">        <span class="keyword">let</span> p=s[i].charCodeAt()</span><br><span class="line">        <span class="keyword">if</span>(hash[p]==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> s[i]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//hash中不存在只出现一次的值，则返回‘ ’</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">' '</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>结果：<br>执行用时：92 ms, 在所有 JavaScript 提交中击败了96.06%的用户<br>内存消耗：41.6 MB, 在所有 JavaScript 提交中击败了100.00%的用户</p>
<h1 id="总结反思"><a href="#总结反思" class="headerlink" title="总结反思"></a>总结反思</h1><p>hash表，字符的utf码，数组的indexof等方法要会使用</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://qiao666.github.io/2020/07/28/%E5%89%91%E6%8C%87offer-50%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E5%AD%97%E7%AC%A6/" data-id="ckd8p07s50006h8vadmn5clcc" data-title="剑指offer-50第一个只出现一次的字符" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/hash%E8%A1%A8/" rel="tag">hash表</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-剑指offer-49丑数（因子只包括2，3-，5的数）" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/07/28/%E5%89%91%E6%8C%87offer-49%E4%B8%91%E6%95%B0%EF%BC%88%E5%9B%A0%E5%AD%90%E5%8F%AA%E5%8C%85%E6%8B%AC2%EF%BC%8C3-%EF%BC%8C5%E7%9A%84%E6%95%B0%EF%BC%89/" class="article-date">
  <time class="dt-published" datetime="2020-07-28T07:14:19.000Z" itemprop="datePublished">2020-07-28</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%89%91%E6%8C%87offer/">剑指offer</a>►<a class="article-category-link" href="/categories/%E5%89%91%E6%8C%87offer/49%E4%B8%91%E6%95%B0/">49丑数</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/07/28/%E5%89%91%E6%8C%87offer-49%E4%B8%91%E6%95%B0%EF%BC%88%E5%9B%A0%E5%AD%90%E5%8F%AA%E5%8C%85%E6%8B%AC2%EF%BC%8C3-%EF%BC%8C5%E7%9A%84%E6%95%B0%EF%BC%89/">剑指offer-49丑数（因子只包括2,3,5的数）</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>我们把只包含质因子 2、3 和 5 的数称作丑数（Ugly Number）。求按从小到大的顺序的第 n 个丑数（1是丑数）。<br>示例:<br>输入: n = 10<br>输出: 12<br>解释: 1, 2, 3, 4, 5, 6, 8, 9, 10, 12 是前 10 个丑数。<br>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/chou-shu-lcof" target="_blank" rel="noopener">https://leetcode-cn.com/problems/chou-shu-lcof</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h1 id="算法分析-代码实现"><a href="#算法分析-代码实现" class="headerlink" title="算法分析+代码实现"></a>算法分析+代码实现</h1><p>1 暴力分析每一个数，但是时间花销太大</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> nthUglyNumber = <span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> UglyN=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">let</span> num=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(UglyN&lt;n)&#123;</span><br><span class="line">        num++</span><br><span class="line">        <span class="comment">//去掉2的因子</span></span><br><span class="line">        <span class="keyword">while</span>(num%<span class="number">2</span>===<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">Math</span>.floor(num/<span class="number">2</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//去掉3的因子</span></span><br><span class="line">        <span class="keyword">while</span>(num%<span class="number">3</span>===<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">Math</span>.floor(num/<span class="number">3</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(num%<span class="number">5</span>===<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">Math</span>.floor(num/<span class="number">5</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(num===<span class="number">1</span>)&#123;</span><br><span class="line">            UglyN++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> num</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>2 动态规划，利用数组存住每一个丑数<br>而新的丑数一定是丑数数组中的某一个丑数 * 2或者 * 3或者 * 5得到的新值<br>使用三指针记录未经过计算的值</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> nthUglyNumber = <span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//动态规划数组</span></span><br><span class="line">    <span class="keyword">let</span> num = [<span class="number">1</span>] </span><br><span class="line">    <span class="comment">//创建三个指针，一个表示*2 一个表示*3 一个表示*5</span></span><br><span class="line">    <span class="comment">//每加一次，表示当前位置的数*2/*3/*5已经计算过，自动更新到下一位置</span></span><br><span class="line">    <span class="keyword">let</span> ptr2=<span class="number">0</span></span><br><span class="line">    <span class="keyword">let</span> ptr3=<span class="number">0</span></span><br><span class="line">    <span class="keyword">let</span> ptr5=<span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span>(num.length&lt;=n)&#123;</span><br><span class="line">        <span class="keyword">let</span> i = <span class="built_in">Math</span>.min(num[ptr2]*<span class="number">2</span>,num[ptr3]*<span class="number">3</span>,num[ptr5]*<span class="number">5</span>)</span><br><span class="line">        <span class="comment">//如果最小值是ptr2位置处值*2，则ptr2指向下一位置</span></span><br><span class="line">        <span class="keyword">if</span>(i===num[ptr2]*<span class="number">2</span>)&#123;</span><br><span class="line">            ptr2++</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//同上</span></span><br><span class="line">        <span class="keyword">if</span>(i===num[ptr3]*<span class="number">3</span>)&#123;</span><br><span class="line">            ptr3++</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//同上</span></span><br><span class="line">        <span class="keyword">if</span>(i===num[ptr5]*<span class="number">5</span>)&#123;</span><br><span class="line">            ptr5++</span><br><span class="line">        &#125;</span><br><span class="line">        num.push(i)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> num[n<span class="number">-1</span>]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>结果:<br>执行用时：108 ms, 在所有 JavaScript 提交中击败了21.91%的用户<br>内存消耗：41.2 MB, 在所有 JavaScript 提交中击败了100.00%的用户</p>
<h1 id="总结反思"><a href="#总结反思" class="headerlink" title="总结反思"></a>总结反思</h1><p>动态规划和三指针相结合，一开始也想到了要使用数组存储，但是由于没想到用三指针，所以不明白代码该如何实现，因为无法确定到底是之前存储的哪个值来乘2，乘3还是乘5。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://qiao666.github.io/2020/07/28/%E5%89%91%E6%8C%87offer-49%E4%B8%91%E6%95%B0%EF%BC%88%E5%9B%A0%E5%AD%90%E5%8F%AA%E5%8C%85%E6%8B%AC2%EF%BC%8C3-%EF%BC%8C5%E7%9A%84%E6%95%B0%EF%BC%89/" data-id="ckd8p07qz0003h8va8dh4239c" data-title="剑指offer-49丑数（因子只包括2,3,5的数）" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" rel="tag">动态规划</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%8F%8C%E6%8C%87%E9%92%88/" rel="tag">双指针</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-剑指offer-48最长不重复字串" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/07/26/%E5%89%91%E6%8C%87offer-48%E6%9C%80%E9%95%BF%E4%B8%8D%E9%87%8D%E5%A4%8D%E5%AD%97%E4%B8%B2/" class="article-date">
  <time class="dt-published" datetime="2020-07-26T09:09:36.000Z" itemprop="datePublished">2020-07-26</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%89%91%E6%8C%87offer/">剑指offer</a>►<a class="article-category-link" href="/categories/%E5%89%91%E6%8C%87offer/48%E6%9C%80%E9%95%BF%E4%B8%8D%E9%87%8D%E5%A4%8D%E5%AD%97%E4%B8%B2/">48最长不重复字串</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/07/26/%E5%89%91%E6%8C%87offer-48%E6%9C%80%E9%95%BF%E4%B8%8D%E9%87%8D%E5%A4%8D%E5%AD%97%E4%B8%B2/">剑指offer-48最长不重复字串</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>请从字符串中找出一个最长的不包含重复字符的子字符串，计算该最长子字符串的长度。<br>示例 1:<br>输入: “abcabcbb”<br>输出: 3<br>解释: 因为无重复字符的最长子串是 “abc”，所以其长度为 3。<br>示例 2:<br>输入: “bbbbb”<br>输出: 1<br>解释: 因为无重复字符的最长子串是 “b”，所以其长度为 1。<br>示例 3:<br>输入: “pwwkew”<br>输出: 3<br>解释: 因为无重复字符的最长子串是 “wke”，所以其长度为 3。<br>请注意，你的答案必须是 子串 的长度，”pwke” 是一个子序列，不是子串。</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/zui-chang-bu-han-zhong-fu-zi-fu-de-zi-zi-fu-chuan-lcof" target="_blank" rel="noopener">https://leetcode-cn.com/problems/zui-chang-bu-han-zhong-fu-zi-fu-de-zi-zi-fu-chuan-lcof</a></p>
<h1 id="算法分析-代码实现"><a href="#算法分析-代码实现" class="headerlink" title="算法分析+代码实现"></a>算法分析+代码实现</h1><p>滑动窗口解法,记录头尾两个值，然后根据情况跟新头尾</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> lengthOfLongestSubstring = <span class="function"><span class="keyword">function</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//考虑1特殊情况</span></span><br><span class="line">    <span class="keyword">if</span>(!s.length||s.length==<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> s.length</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> res=<span class="number">0</span></span><br><span class="line">    <span class="comment">//滑动窗口设计</span></span><br><span class="line">    <span class="comment">//两个值，一个头，一个尾部，</span></span><br><span class="line">    <span class="keyword">let</span> head=<span class="number">0</span>,tail=<span class="number">0</span></span><br><span class="line">    <span class="keyword">let</span> win=<span class="string">''</span><span class="comment">//滑动窗口的内容</span></span><br><span class="line">    <span class="keyword">while</span>(tail&lt;s.length)&#123;</span><br><span class="line">        <span class="comment">//如果当前值不在窗口，但是有可能一直没有重复值，需要在循环结束以后再判断一次</span></span><br><span class="line">        <span class="keyword">if</span>(!win.includes(s[tail]))&#123;</span><br><span class="line">            win+=s[tail]</span><br><span class="line">            tail++</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果包含该字符，则利用indexof更新head值,并更新win串</span></span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            head=win.indexOf(s[tail])+<span class="number">1</span></span><br><span class="line">            win=win.slice(head)</span><br><span class="line">            win+=s[tail]</span><br><span class="line">            tail++</span><br><span class="line">        &#125;</span><br><span class="line">        res&gt;win.length?<span class="literal">null</span>:res=win.length;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>结果：<br>执行用时：120 ms, 在所有 JavaScript 提交中击败了46.65%的用户<br>内存消耗：43.6 MB, 在所有 JavaScript 提交中击败了100.00%的用户</p>
<p>优化版：<br>不使用include（）,只使用indexof()<br>indexOf() 方法返回调用它的 String 对象中第一次出现的指定值的索引，从 fromIndex 处进行搜索。如果未找到该值，则返回 -1。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> lengthOfLongestSubstring = <span class="function"><span class="keyword">function</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> len = s.length;</span><br><span class="line">    <span class="keyword">let</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> temp = <span class="string">''</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i ++) &#123;</span><br><span class="line">    	<span class="comment">//没找到，则更新字串，更新最大值</span></span><br><span class="line">        <span class="keyword">if</span>(temp.indexOf(s[i]) === <span class="number">-1</span>) &#123;</span><br><span class="line">            temp += s[i];</span><br><span class="line">            res = <span class="built_in">Math</span>.max(res, temp.length);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            temp = temp.slice(temp.indexOf(s[i]) + <span class="number">1</span>);</span><br><span class="line">            temp += s[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>结果：<br>执行用时：116 ms, 在所有 JavaScript 提交中击败了51.27%的用户<br>内存消耗：43.5 MB, 在所有 JavaScript 提交中击败了100.00%的用户</p>
<p>3 原书最优解：动态规划<br>三个值，maxlength保存最大长度,curlength保存当前长度，preindex保存该字符上次出现的下标<br>一个数组 position[]保存每个字符上次出现的在s中的下标，由于该题目未明确所给字符串中有何值，故长度为128，可以保存ASCALL码中的128个字符</p>
<p>然后根据当前字符的下标和上次出现的下标来计算当前最大子串<br>只有当当前子串中有重复值时，才更新最大长度<br>否则当前子串长度+1</p>
<p>注意最后仍要比较一次最大长度和当前长度</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> lengthOfLongestSubstring = <span class="function"><span class="keyword">function</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//首先创建一个记录字符出现下标的值</span></span><br><span class="line">    <span class="keyword">const</span> position=<span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">128</span>).fill(<span class="number">-1</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> maxlength=<span class="number">0</span>,curlength=<span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;s.length;i++)&#123;</span><br><span class="line">        <span class="keyword">let</span> preIndex=position[s[i].charCodeAt()]</span><br><span class="line">        <span class="comment">//根据出现的值的下标</span></span><br><span class="line">        <span class="comment">//如果没出现过,或者距上次出现的长度要大于当前最大子串的长度</span></span><br><span class="line">        <span class="keyword">if</span>(preIndex==<span class="number">-1</span>||i-preIndex&gt;curlength)&#123;</span><br><span class="line">            <span class="comment">//当前的子串长度+1</span></span><br><span class="line">            curlength++</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//上次出现的长度要小于当前最大子串的长度</span></span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//如果上次出现的距离比当前最大字串要小</span></span><br><span class="line">            <span class="comment">// 更新最大值</span></span><br><span class="line">            maxlength&lt;curlength?maxlength=curlength:<span class="literal">null</span>;</span><br><span class="line">            <span class="comment">// 再要减去重复值</span></span><br><span class="line">            curlength=i-preIndex</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 更新对应的positon值,为当前下标值</span></span><br><span class="line">        position[s[i].charCodeAt()]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//结束以后再判断一次最大值和当前子串长度</span></span><br><span class="line">    maxlength&lt;curlength?maxlength=curlength:<span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> maxlength</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>结果：时间复杂度为O(n),空间复杂度为O(1)<br>执行用时：108 ms, 在所有 JavaScript 提交中击败了66.91%的用户<br>内存消耗：40 MB, 在所有 JavaScript 提交中击败了100.00%的用户</p>
<h1 id="总结反思"><a href="#总结反思" class="headerlink" title="总结反思"></a>总结反思</h1><p>该题目主要考察的就是双指针的用法<br>动态规划方法其实也是利用了双指针的思想</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://qiao666.github.io/2020/07/26/%E5%89%91%E6%8C%87offer-48%E6%9C%80%E9%95%BF%E4%B8%8D%E9%87%8D%E5%A4%8D%E5%AD%97%E4%B8%B2/" data-id="ckd2ym9z40000ugva1qhr0l0w" data-title="剑指offer-48最长不重复字串" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" rel="tag">动态规划</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%8F%8C%E6%8C%87%E9%92%88/" rel="tag">双指针</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/" rel="tag">滑动窗口</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-剑指offer-47礼物的最大价值" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/07/26/%E5%89%91%E6%8C%87offer-47%E7%A4%BC%E7%89%A9%E7%9A%84%E6%9C%80%E5%A4%A7%E4%BB%B7%E5%80%BC/" class="article-date">
  <time class="dt-published" datetime="2020-07-26T07:02:48.000Z" itemprop="datePublished">2020-07-26</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%89%91%E6%8C%87offer/">剑指offer</a>►<a class="article-category-link" href="/categories/%E5%89%91%E6%8C%87offer/47%E7%A4%BC%E7%89%A9%E7%9A%84%E6%9C%80%E5%A4%A7%E4%BB%B7%E5%80%BC/">47礼物的最大价值</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/07/26/%E5%89%91%E6%8C%87offer-47%E7%A4%BC%E7%89%A9%E7%9A%84%E6%9C%80%E5%A4%A7%E4%BB%B7%E5%80%BC/">剑指offer-47礼物的最大价值</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>在一个 m * n 的棋盘的每一格都放有一个礼物，每个礼物都有一定的价值（价值大于 0）。你可以从棋盘的左上角开始拿格子里的礼物，并每次向右或者向下移动一格、直到到达棋盘的右下角。给定一个棋盘及其上面的礼物的价值，请计算你最多能拿到多少价值的礼物？<br>示例 1:<br>输入:<br>[<br>  [1,3,1],<br>  [1,5,1],<br>  [4,2,1]<br>]<br>输出: 12<br>解释: 路径 1→3→5→2→1 可以拿到最多价值的礼物<br>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/li-wu-de-zui-da-jie-zhi-lcof" target="_blank" rel="noopener">https://leetcode-cn.com/problems/li-wu-de-zui-da-jie-zhi-lcof</a></p>
<h1 id="算法分析-代码实现"><a href="#算法分析-代码实现" class="headerlink" title="算法分析+代码实现"></a>算法分析+代码实现</h1><p>经典动态规划，构建二维数组dp [ m] [ n ],其中dp[i][j]表示的是当走到当前格时，所能取到的最大值</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> maxValue = <span class="function"><span class="keyword">function</span>(<span class="params">grid</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> row=grid.length<span class="comment">//行数</span></span><br><span class="line">    <span class="keyword">let</span> col = grid[<span class="number">0</span>].length<span class="comment">//列数</span></span><br><span class="line">    <span class="comment">//构建dp二维数组</span></span><br><span class="line">    <span class="comment">//map()方法：返回一个由原数组每个元素执行回调函数的结果组成的新数组。</span></span><br><span class="line">    <span class="keyword">let</span> dp =<span class="keyword">new</span> <span class="built_in">Array</span>(row).fill(<span class="number">0</span>).map(<span class="function"><span class="params">item</span>=&gt;</span>item=<span class="keyword">new</span> <span class="built_in">Array</span>(col).fill(<span class="number">0</span>))</span><br><span class="line">    <span class="comment">// 开始构建dp内容</span></span><br><span class="line">    <span class="comment">//明确端点值</span></span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>]=grid[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line">    <span class="comment">// 首先构建左边的和上边的值，当然也是从开始值开始累加的</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">1</span>;i&lt;row;i++)&#123;</span><br><span class="line">        dp[i][<span class="number">0</span>]=dp[i<span class="number">-1</span>][<span class="number">0</span>]+grid[i][<span class="number">0</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> j = <span class="number">1</span>;j&lt;col;j++)&#123;</span><br><span class="line">        dp[<span class="number">0</span>][j]=dp[<span class="number">0</span>][j<span class="number">-1</span>]+grid[<span class="number">0</span>][j]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">1</span>;i&lt;row;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> j = <span class="number">1</span>;j&lt;col;j++)&#123;</span><br><span class="line">            dp[i][j]=grid[i][j]+<span class="built_in">Math</span>.max(dp[i<span class="number">-1</span>][j],dp[i][j<span class="number">-1</span>])</span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[row<span class="number">-1</span>][col<span class="number">-1</span>]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>结果：时间复杂度为O( m * n),空间复杂度为O( m * n)<br>执行用时：104 ms, 在所有 JavaScript 提交中击败了10.98%的用户<br>内存消耗：39.4 MB, 在所有 JavaScript 提交中击败了100.00%的用户</p>
<p>优化：直接在数组上进行修改</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> maxValue = <span class="function"><span class="keyword">function</span>(<span class="params">grid</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> row=grid.length<span class="comment">//行数</span></span><br><span class="line">    <span class="keyword">let</span> col = grid[<span class="number">0</span>].length<span class="comment">//列数</span></span><br><span class="line">   </span><br><span class="line">    <span class="comment">// 开始构建dp内容</span></span><br><span class="line">   </span><br><span class="line">    <span class="comment">// 首先构建左边的和上边的值</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">1</span>;i&lt;row;i++)&#123;</span><br><span class="line">        grid[i][<span class="number">0</span>]+=grid[i<span class="number">-1</span>][<span class="number">0</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> j = <span class="number">1</span>;j&lt;col;j++)&#123;</span><br><span class="line">        grid[<span class="number">0</span>][j]+=grid[<span class="number">0</span>][j<span class="number">-1</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">1</span>;i&lt;row;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> j = <span class="number">1</span>;j&lt;col;j++)&#123;</span><br><span class="line">            grid[i][j]+=<span class="built_in">Math</span>.max(grid[i<span class="number">-1</span>][j],grid[i][j<span class="number">-1</span>])</span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> grid[row<span class="number">-1</span>][col<span class="number">-1</span>]</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>结果：时间复杂度不变，但是空间复杂度降为1<br>执行用时：80 ms, 在所有 JavaScript 提交中击败了47.54%的用户<br>内存消耗：38.1 MB, 在所有 JavaScript 提交中击败了100.00%的用户</p>
<h1 id="总结反思"><a href="#总结反思" class="headerlink" title="总结反思"></a>总结反思</h1><p>动态规划理解的时候，是从下往上去找最佳答案，<br>但是注意，设计代码的时候，是从上往下设计的，先有上面的最佳答案，才会有下面的最佳答案<br>一开始我总是理解为从下往上设计代码，然后怎么也理解不了，就算别人写好的代码，我看的时候也总感觉是云里雾里的看不真切，看不明白。<br>然后我就去重新找了一些讲解动态规划思路的博客，先理清楚了动态规划，然后再写代码或者看代码就容易多了</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://qiao666.github.io/2020/07/26/%E5%89%91%E6%8C%87offer-47%E7%A4%BC%E7%89%A9%E7%9A%84%E6%9C%80%E5%A4%A7%E4%BB%B7%E5%80%BC/" data-id="ckd2ym9zn0001ugva6wy8dhf6" data-title="剑指offer-47礼物的最大价值" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" rel="tag">动态规划</a></li></ul>

    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/8/">8</a><a class="extend next" rel="next" href="/page/2/">下一页 &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">分类</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/ES6/">ES6</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/ES6/ES5%E5%9B%9E%E9%A1%BE/">ES5回顾</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/ES6/%E5%B8%B8%E7%94%A8%E5%85%B3%E9%94%AE%E5%AD%97%E5%92%8C%E6%96%B9%E6%B3%95/">常用关键字和方法</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/ES6/%E6%89%A9%E5%B1%95%E9%83%A8%E5%88%86/">扩展部分</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/HEXO%E4%BD%BF%E7%94%A8/">HEXO使用</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/js%E9%AB%98%E7%BA%A7/">js高级</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/js%E9%AB%98%E7%BA%A7/js%E5%9F%BA%E7%A1%80/">js基础</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/js%E9%AB%98%E7%BA%A7/%E5%87%BD%E6%95%B0/">函数</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/js%E9%AB%98%E7%BA%A7/%E5%87%BD%E6%95%B0/%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE/">作用域和作用域链</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/js%E9%AB%98%E7%BA%A7/%E5%87%BD%E6%95%B0/%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E4%B8%8E%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E6%A0%88/">执行上下文与执行上下文栈</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/js%E9%AB%98%E7%BA%A7/%E5%87%BD%E6%95%B0/%E9%97%AD%E5%8C%85/">闭包</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/js%E9%AB%98%E7%BA%A7/%E5%AF%B9%E8%B1%A1/">对象</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/js%E9%AB%98%E7%BA%A7/%E5%AF%B9%E8%B1%A1/%E5%88%9B%E5%BB%BA/">创建</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/js%E9%AB%98%E7%BA%A7/%E5%AF%B9%E8%B1%A1/%E7%BB%A7%E6%89%BF%E6%A8%A1%E5%BC%8F/">继承模式</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/js%E9%AB%98%E7%BA%A7/%E7%BA%BF%E7%A8%8B-%E4%BA%8B%E4%BB%B6/">线程_事件</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/js%E9%AB%98%E7%BA%A7/%E9%9D%A2%E8%AF%95%E9%A2%98/">面试题</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/js%E9%AB%98%E7%BA%A7/%E9%9D%A2%E8%AF%95%E9%A2%98/%E4%B8%8A%E4%B8%8B%E6%96%87%E6%A0%88/">上下文栈</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/js%E9%AB%98%E7%BA%A7/%E9%9D%A2%E8%AF%95%E9%A2%98/%E4%BD%9C%E7%94%A8%E5%9F%9F/">作用域</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/js%E9%AB%98%E7%BA%A7/%E9%9D%A2%E8%AF%95%E9%A2%98/%E5%8E%9F%E5%9E%8B%E9%93%BE/">原型链</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/js%E9%AB%98%E7%BA%A7/%E9%9D%A2%E8%AF%95%E9%A2%98/%E9%97%AD%E5%8C%85/">闭包</a></li></ul></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/webpack/">webpack</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/webpack/%E5%85%A5%E9%97%A8/">入门</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/webpack/%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/">开发环境配置</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%89%91%E6%8C%87offer/">剑指offer</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%89%91%E6%8C%87offer/03-%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97/">03-数组中重复的数字</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%89%91%E6%8C%87offer/04-%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE/">04-二维数组中的查找</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%89%91%E6%8C%87offer/05%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC/">05替换空格</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%89%91%E6%8C%87offer/06%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8/">06从尾到头打印链表</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%89%91%E6%8C%87offer/07%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/">07重建二叉树</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%89%91%E6%8C%87offer/08%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E8%8A%82%E7%82%B9/">08二叉树的下一个节点</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%89%91%E6%8C%87offer/09%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/">09用两个栈实现队列</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%89%91%E6%8C%87offer/11%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97/">11旋转数组最小数字</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%89%91%E6%8C%87offer/12%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E8%B7%AF%E5%BE%84/">12矩阵中的路径</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%89%91%E6%8C%87offer/13%E6%9C%BA%E5%99%A8%E4%BA%BA%E8%BF%90%E5%8A%A8%E8%8C%83%E5%9B%B4/">13机器人运动范围</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%89%91%E6%8C%87offer/14%E5%89%AA%E7%BB%B3%E5%AD%90/">14剪绳子</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%89%91%E6%8C%87offer/15%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%AD1%E7%9A%84%E4%B8%AA%E6%95%B0/">15二进制中1的个数</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%89%91%E6%8C%87offer/16%E6%95%B0%E5%80%BC%E7%9A%84%E6%95%B4%E6%95%B0%E6%AC%A1%E6%96%B9/">16数值的整数次方</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%89%91%E6%8C%87offer/17%E6%89%93%E5%8D%B0%E4%BB%8E1%E5%88%B0%E6%9C%80%E5%A4%A7n%E4%BD%8D%E7%9A%84%E5%8D%81%E8%BF%9B%E5%88%B6%E6%95%B0/">17打印从1到最大n位的十进制数</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%89%91%E6%8C%87offer/18%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E8%8A%82%E7%82%B9/">18删除链表的节点</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%89%91%E6%8C%87offer/19%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E5%8C%B9%E9%85%8D/">19正则表达式的匹配</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%89%91%E6%8C%87offer/20%E8%A1%A8%E7%A4%BA%E6%95%B0%E5%80%BC%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2/">20表示数值的字符串</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%89%91%E6%8C%87offer/21%E8%B0%83%E6%95%B4%E6%95%B0%E7%BB%84%E9%A1%BA%E5%BA%8F%E4%BD%BF%E5%A5%87%E6%95%B0%E4%BD%8D%E4%BA%8E%E5%81%B6%E6%95%B0%E5%89%8D/">21调整数组顺序使奇数位于偶数前</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%89%91%E6%8C%87offer/22%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E8%8A%82%E7%82%B9/">22链表中倒数第k个节点</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%89%91%E6%8C%87offer/24%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/">24反转链表</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%89%91%E6%8C%87offer/25%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8/">25合并两个链表</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%89%91%E6%8C%87offer/26%E6%A0%91%E7%9A%84%E5%AD%90%E7%BB%93%E6%9E%84/">26树的子结构</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%89%91%E6%8C%87offer/27%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%95%9C%E5%83%8F/">27二叉树的镜像</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%89%91%E6%8C%87offer/28%E5%AF%B9%E7%A7%B0%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91/">28对称的二叉树</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%89%91%E6%8C%87offer/29%E9%A1%BA%E6%97%B6%E9%92%88%E6%89%93%E5%8D%B0%E7%9F%A9%E9%98%B5/">29顺时针打印矩阵</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%89%91%E6%8C%87offer/30%E5%8C%85%E5%90%ABmin%E5%87%BD%E6%95%B0%E7%9A%84%E6%A0%88/">30包含min函数的栈</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%89%91%E6%8C%87offer/31%E6%A0%88%E7%9A%84%E5%8E%8B%E5%85%A5%E5%BC%B9%E5%87%BA%E5%BA%8F%E5%88%97/">31栈的压入弹出序列</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%89%91%E6%8C%87offer/32%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91/">32从上到下打印二叉树</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%89%91%E6%8C%87offer/33%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%90%8E%E7%BB%AD%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97/">33二叉搜索树的后续遍历序列</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%89%91%E6%8C%87offer/34%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%92%8C%E4%B8%BA%E6%9F%90%E4%B8%80%E5%80%BC%E7%9A%84%E8%B7%AF%E5%BE%84/">34二叉树中和为某一值的路径</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%89%91%E6%8C%87offer/35%E5%A4%8D%E6%9D%82%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%8D%E5%88%B6/">35复杂链表的复制</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%89%91%E6%8C%87offer/36%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E5%92%8C%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/">36二叉搜索树和双向链表</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%89%91%E6%8C%87offer/37%E5%BA%8F%E5%88%97%E5%8C%96%E4%BA%8C%E5%8F%89%E6%A0%91/">37序列化二叉树</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%89%91%E6%8C%87offer/38%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8E%92%E5%88%97/">38字符串的排列</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%89%91%E6%8C%87offer/39%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E8%B6%85%E8%BF%87%E4%B8%80%E5%8D%8A%E7%9A%84%E6%95%B0%E5%AD%97/">39数组中出现次数超过一半的数字</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%89%91%E6%8C%87offer/40%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0/">40最小的k个数</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%89%91%E6%8C%87offer/41%E6%95%B0%E6%8D%AE%E6%B5%81%E4%B8%AD%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/">41数据流中的中位数</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%89%91%E6%8C%87offer/42%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC/">42连续子数组的最大值</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%89%91%E6%8C%87offer/43-1-n%E6%95%B4%E6%95%B0%E4%B8%AD1%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0/">43 1~n整数中1出现的次数</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%89%91%E6%8C%87offer/44%E6%95%B0%E5%AD%97%E5%BA%8F%E5%88%97%E4%B8%AD%E6%9F%90%E4%B8%80%E4%BD%8D%E7%9A%84%E6%95%B0%E5%AD%97/">44数字序列中某一位的数字</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%89%91%E6%8C%87offer/45%E6%8A%8A%E6%95%B0%E7%BB%84%E6%8E%92%E6%88%90%E6%9C%80%E5%B0%8F%E7%9A%84%E6%95%B0/">45把数组排成最小的数</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%89%91%E6%8C%87offer/46%E6%8A%8A%E6%95%B0%E5%AD%97%E7%BF%BB%E8%AF%91%E6%88%90%E5%AD%97%E7%AC%A6%E4%B8%B2/">46把数字翻译成字符串</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%89%91%E6%8C%87offer/47%E7%A4%BC%E7%89%A9%E7%9A%84%E6%9C%80%E5%A4%A7%E4%BB%B7%E5%80%BC/">47礼物的最大价值</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%89%91%E6%8C%87offer/48%E6%9C%80%E9%95%BF%E4%B8%8D%E9%87%8D%E5%A4%8D%E5%AD%97%E4%B8%B2/">48最长不重复字串</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%89%91%E6%8C%87offer/49%E4%B8%91%E6%95%B0/">49丑数</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%89%91%E6%8C%87offer/50%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E5%AD%97%E7%AC%A6/">50第一个只出现一次的字符</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%89%91%E6%8C%87offer/51%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%80%86%E5%BA%8F%E5%AF%B9/">51数组中的逆序对</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%89%91%E6%8C%87offer/52%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%85%AC%E5%85%B1%E7%BB%93%E7%82%B9/">52两个链表的第一个公共结点</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%89%91%E6%8C%87offer/53%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E6%95%B0%E5%AD%97/">53在排序数组中查找数字</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%89%91%E6%8C%87offer/54%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E7%AC%ACk%E5%A4%A7%E7%BB%93%E7%82%B9/">54二叉搜索树中的第k大结点</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%89%91%E6%8C%87offer/55%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%B7%B1%E5%BA%A6/">55二叉树的深度</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%89%91%E6%8C%87offer/56%E6%95%B0%E7%BB%84%E4%B8%AD%E6%95%B0%E5%AD%97%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0/">56数组中数字出现的次数</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%89%91%E6%8C%87offer/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/">斐波那契数列</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%88%91%E7%9A%84%E4%BA%91%E4%B9%8B%E8%B7%AF/">我的云之路</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%88%91%E7%9A%84%E4%BA%91%E4%B9%8B%E8%B7%AF/ECS%E7%AE%80%E4%BB%8B/">ECS简介</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%9D%82%E8%B0%88/">杂谈</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/ECS/" rel="tag">ECS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ES5/" rel="tag">ES5</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ES6/" rel="tag">ES6</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ES6%E6%89%A9%E5%B1%95/" rel="tag">ES6扩展</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/IEFE/" rel="tag">IEFE</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hash%E8%A1%A8/" rel="tag">hash表</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hexo%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/" rel="tag">hexo基本使用</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/instanceof/" rel="tag">instanceof</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/js/" rel="tag">js</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/js%E5%87%BD%E6%95%B0/" rel="tag">js函数</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/js%E5%AF%B9%E8%B1%A1/" rel="tag">js对象</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/js%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/" rel="tag">js数据类型</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/js%E9%9D%A2%E8%AF%95/" rel="tag">js面试</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/js%E9%AB%98%E7%BA%A7/" rel="tag">js高级</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/map/" rel="tag">map</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/md%E8%AF%AD%E6%B3%95/" rel="tag">md语法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/prototype/" rel="tag">prototype</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/set/" rel="tag">set</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/sort%E6%8E%92%E5%BA%8F/" rel="tag">sort排序</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/this/" rel="tag">this</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/typeof/" rel="tag">typeof</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/vpn/" rel="tag">vpn</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/web-dev-server/" rel="tag">web-dev-server</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/webpack/" rel="tag">webpack</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%B8%89%E6%8C%87%E9%92%88/" rel="tag">三指针</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%B8%8A%E4%B8%8B%E6%96%87%E9%9D%A2%E8%AF%95/" rel="tag">上下文面试</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86/" rel="tag">中序遍历</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BA%8B%E4%BB%B6/" rel="tag">事件</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/" rel="tag">二分查找</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/" rel="tag">二叉搜索树</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/" rel="tag">二叉树</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/" rel="tag">位运算</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BD%9C%E7%94%A8%E5%9F%9F/" rel="tag">作用域</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE/" rel="tag">作用域链</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%85%AB%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98/" rel="tag">八皇后问题</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" rel="tag">内存管理</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/" rel="tag">冒泡排序</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%87%BA%E5%85%A5%E6%A0%88/" rel="tag">出入栈</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92/" rel="tag">函数参数传递</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8/" rel="tag">函数调用</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%88%9B%E5%BB%BA%E6%A8%A1%E5%BC%8F%E6%AF%94%E8%BE%83/" rel="tag">创建模式比较</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%89%91%E6%8C%87offer/" rel="tag">剑指offer</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" rel="tag">动态规划</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8E%9F%E5%9E%8B/" rel="tag">原型</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8E%9F%E5%9E%8B%E9%93%BE/" rel="tag">原型链</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8E%9F%E5%9E%8B%E9%93%BE%E9%9D%A2%E8%AF%95/" rel="tag">原型链面试</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/" rel="tag">双向链表</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8F%8C%E6%8C%87%E9%92%88/" rel="tag">双指针</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/" rel="tag">反转链表</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8F%98%E9%87%8F%E8%B5%8B%E5%80%BC/" rel="tag">变量赋值</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/" rel="tag">后序遍历</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%9B%9E%E6%BA%AF/" rel="tag">回溯</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0/" rel="tag">回调函数</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%9D%97%E7%BA%A7%E4%BD%9C%E7%94%A8%E5%9F%9F/" rel="tag">块级作用域</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%A4%A7%E5%B0%8F%E5%A0%86/" rel="tag">大小堆</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA/" rel="tag">对象创建</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80/" rel="tag">对象基础</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%AF%B9%E8%B1%A1%E7%BB%A7%E6%89%BF/" rel="tag">对象继承</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%BA%8F%E5%88%97%E5%8C%96%E4%BA%8C%E5%8F%89%E6%A0%91/" rel="tag">序列化二叉树</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/" rel="tag">归并排序</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/" rel="tag">快速排序</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87/" rel="tag">执行上下文</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E6%A0%88/" rel="tag">执行上下文栈</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%8A%95%E7%A5%A8%E7%AE%97%E6%B3%95/" rel="tag">投票算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%8E%92%E5%BA%8F/" rel="tag">排序</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/" rel="tag">插入排序</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E5%80%BC%E7%9A%84%E6%95%B4%E6%95%B0%E6%AC%A1%E6%96%B9/" rel="tag">数值的整数次方</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E7%BB%84/" rel="tag">数组</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/" rel="tag">斐波那契数列</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%9F%A5%E6%89%BE%E5%92%8C%E6%8E%92%E5%BA%8F/" rel="tag">查找和排序</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%A0%88/" rel="tag">栈</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/" rel="tag">树的遍历</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%AD%A3%E5%88%99/" rel="tag">正则</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/" rel="tag">正则表达式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%B7%B1%E6%8B%B7%E8%B4%9D/" rel="tag">深拷贝</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/" rel="tag">滑动窗口</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%9F%A9%E9%98%B5/" rel="tag">矩阵</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BA%BF%E7%A8%8B/" rel="tag">线程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%87%AA%E5%AE%9A%E4%B9%89%E5%87%BD%E6%95%B0/" rel="tag">自定义函数</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%A1%A8%E7%A4%BA%E6%95%B0%E5%80%BC%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2/" rel="tag">表示数值的字符串</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/" rel="tag">贪心算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%B5%84%E6%BA%90%E6%89%93%E5%8C%85/" rel="tag">资源打包</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%80%92%E5%BD%92/" rel="tag">递归</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%93%BE%E8%A1%A8/" rel="tag">链表</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%97%AD%E5%8C%85/" rel="tag">闭包</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%98%9F%E5%88%97/" rel="tag">队列</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/" rel="tag">面试题</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/ECS/" style="font-size: 10px;">ECS</a> <a href="/tags/ES5/" style="font-size: 10px;">ES5</a> <a href="/tags/ES6/" style="font-size: 11.25px;">ES6</a> <a href="/tags/ES6%E6%89%A9%E5%B1%95/" style="font-size: 10px;">ES6扩展</a> <a href="/tags/IEFE/" style="font-size: 10px;">IEFE</a> <a href="/tags/hash%E8%A1%A8/" style="font-size: 10px;">hash表</a> <a href="/tags/hexo%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/" style="font-size: 10px;">hexo基本使用</a> <a href="/tags/instanceof/" style="font-size: 10px;">instanceof</a> <a href="/tags/js/" style="font-size: 11.25px;">js</a> <a href="/tags/js%E5%87%BD%E6%95%B0/" style="font-size: 10px;">js函数</a> <a href="/tags/js%E5%AF%B9%E8%B1%A1/" style="font-size: 12.5px;">js对象</a> <a href="/tags/js%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/" style="font-size: 10px;">js数据类型</a> <a href="/tags/js%E9%9D%A2%E8%AF%95/" style="font-size: 11.25px;">js面试</a> <a href="/tags/js%E9%AB%98%E7%BA%A7/" style="font-size: 12.5px;">js高级</a> <a href="/tags/map/" style="font-size: 10px;">map</a> <a href="/tags/md%E8%AF%AD%E6%B3%95/" style="font-size: 10px;">md语法</a> <a href="/tags/prototype/" style="font-size: 10px;">prototype</a> <a href="/tags/set/" style="font-size: 10px;">set</a> <a href="/tags/sort%E6%8E%92%E5%BA%8F/" style="font-size: 10px;">sort排序</a> <a href="/tags/this/" style="font-size: 10px;">this</a> <a href="/tags/typeof/" style="font-size: 10px;">typeof</a> <a href="/tags/vpn/" style="font-size: 10px;">vpn</a> <a href="/tags/web-dev-server/" style="font-size: 10px;">web-dev-server</a> <a href="/tags/webpack/" style="font-size: 10px;">webpack</a> <a href="/tags/%E4%B8%89%E6%8C%87%E9%92%88/" style="font-size: 10px;">三指针</a> <a href="/tags/%E4%B8%8A%E4%B8%8B%E6%96%87%E9%9D%A2%E8%AF%95/" style="font-size: 10px;">上下文面试</a> <a href="/tags/%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86/" style="font-size: 10px;">中序遍历</a> <a href="/tags/%E4%BA%8B%E4%BB%B6/" style="font-size: 10px;">事件</a> <a href="/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/" style="font-size: 11.25px;">二分查找</a> <a href="/tags/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/" style="font-size: 12.5px;">二叉搜索树</a> <a href="/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/" style="font-size: 17.5px;">二叉树</a> <a href="/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/" style="font-size: 11.25px;">位运算</a> <a href="/tags/%E4%BD%9C%E7%94%A8%E5%9F%9F/" style="font-size: 11.25px;">作用域</a> <a href="/tags/%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE/" style="font-size: 10px;">作用域链</a> <a href="/tags/%E5%85%AB%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98/" style="font-size: 10px;">八皇后问题</a> <a href="/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" style="font-size: 10px;">内存管理</a> <a href="/tags/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/" style="font-size: 10px;">冒泡排序</a> <a href="/tags/%E5%87%BA%E5%85%A5%E6%A0%88/" style="font-size: 10px;">出入栈</a> <a href="/tags/%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92/" style="font-size: 10px;">函数参数传递</a> <a href="/tags/%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8/" style="font-size: 10px;">函数调用</a> <a href="/tags/%E5%88%9B%E5%BB%BA%E6%A8%A1%E5%BC%8F%E6%AF%94%E8%BE%83/" style="font-size: 10px;">创建模式比较</a> <a href="/tags/%E5%89%91%E6%8C%87offer/" style="font-size: 20px;">剑指offer</a> <a href="/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" style="font-size: 16.25px;">动态规划</a> <a href="/tags/%E5%8E%9F%E5%9E%8B/" style="font-size: 10px;">原型</a> <a href="/tags/%E5%8E%9F%E5%9E%8B%E9%93%BE/" style="font-size: 10px;">原型链</a> <a href="/tags/%E5%8E%9F%E5%9E%8B%E9%93%BE%E9%9D%A2%E8%AF%95/" style="font-size: 10px;">原型链面试</a> <a href="/tags/%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/" style="font-size: 10px;">双向链表</a> <a href="/tags/%E5%8F%8C%E6%8C%87%E9%92%88/" style="font-size: 17.5px;">双指针</a> <a href="/tags/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/" style="font-size: 10px;">反转链表</a> <a href="/tags/%E5%8F%98%E9%87%8F%E8%B5%8B%E5%80%BC/" style="font-size: 10px;">变量赋值</a> <a href="/tags/%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/" style="font-size: 10px;">后序遍历</a> <a href="/tags/%E5%9B%9E%E6%BA%AF/" style="font-size: 11.25px;">回溯</a> <a href="/tags/%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0/" style="font-size: 10px;">回调函数</a> <a href="/tags/%E5%9D%97%E7%BA%A7%E4%BD%9C%E7%94%A8%E5%9F%9F/" style="font-size: 10px;">块级作用域</a> <a href="/tags/%E5%A4%A7%E5%B0%8F%E5%A0%86/" style="font-size: 10px;">大小堆</a> <a href="/tags/%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA/" style="font-size: 10px;">对象创建</a> <a href="/tags/%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80/" style="font-size: 10px;">对象基础</a> <a href="/tags/%E5%AF%B9%E8%B1%A1%E7%BB%A7%E6%89%BF/" style="font-size: 10px;">对象继承</a> <a href="/tags/%E5%BA%8F%E5%88%97%E5%8C%96%E4%BA%8C%E5%8F%89%E6%A0%91/" style="font-size: 10px;">序列化二叉树</a> <a href="/tags/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/" style="font-size: 10px;">归并排序</a> <a href="/tags/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/" style="font-size: 10px;">快速排序</a> <a href="/tags/%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87/" style="font-size: 10px;">执行上下文</a> <a href="/tags/%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E6%A0%88/" style="font-size: 10px;">执行上下文栈</a> <a href="/tags/%E6%8A%95%E7%A5%A8%E7%AE%97%E6%B3%95/" style="font-size: 10px;">投票算法</a> <a href="/tags/%E6%8E%92%E5%BA%8F/" style="font-size: 10px;">排序</a> <a href="/tags/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/" style="font-size: 10px;">插入排序</a> <a href="/tags/%E6%95%B0%E5%80%BC%E7%9A%84%E6%95%B4%E6%95%B0%E6%AC%A1%E6%96%B9/" style="font-size: 10px;">数值的整数次方</a> <a href="/tags/%E6%95%B0%E7%BB%84/" style="font-size: 10px;">数组</a> <a href="/tags/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/" style="font-size: 10px;">斐波那契数列</a> <a href="/tags/%E6%9F%A5%E6%89%BE%E5%92%8C%E6%8E%92%E5%BA%8F/" style="font-size: 10px;">查找和排序</a> <a href="/tags/%E6%A0%88/" style="font-size: 12.5px;">栈</a> <a href="/tags/%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/" style="font-size: 10px;">树的遍历</a> <a href="/tags/%E6%AD%A3%E5%88%99/" style="font-size: 10px;">正则</a> <a href="/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/" style="font-size: 10px;">正则表达式</a> <a href="/tags/%E6%B7%B1%E6%8B%B7%E8%B4%9D/" style="font-size: 10px;">深拷贝</a> <a href="/tags/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/" style="font-size: 10px;">滑动窗口</a> <a href="/tags/%E7%9F%A9%E9%98%B5/" style="font-size: 10px;">矩阵</a> <a href="/tags/%E7%BA%BF%E7%A8%8B/" style="font-size: 10px;">线程</a> <a href="/tags/%E8%87%AA%E5%AE%9A%E4%B9%89%E5%87%BD%E6%95%B0/" style="font-size: 10px;">自定义函数</a> <a href="/tags/%E8%A1%A8%E7%A4%BA%E6%95%B0%E5%80%BC%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2/" style="font-size: 10px;">表示数值的字符串</a> <a href="/tags/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/" style="font-size: 10px;">贪心算法</a> <a href="/tags/%E8%B5%84%E6%BA%90%E6%89%93%E5%8C%85/" style="font-size: 10px;">资源打包</a> <a href="/tags/%E9%80%92%E5%BD%92/" style="font-size: 18.75px;">递归</a> <a href="/tags/%E9%93%BE%E8%A1%A8/" style="font-size: 15px;">链表</a> <a href="/tags/%E9%97%AD%E5%8C%85/" style="font-size: 11.25px;">闭包</a> <a href="/tags/%E9%98%9F%E5%88%97/" style="font-size: 13.75px;">队列</a> <a href="/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/" style="font-size: 11.25px;">面试题</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/07/">七月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/06/">六月 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/07/31/%E5%89%91%E6%8C%87offer-56%E6%95%B0%E7%BB%84%E4%B8%AD%E6%95%B0%E5%AD%97%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0/">剑指offer-56数组中数字出现的次数</a>
          </li>
        
          <li>
            <a href="/2020/07/31/%E5%89%91%E6%8C%87offer-55%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%B7%B1%E5%BA%A6/">剑指offer-55二叉树的深度</a>
          </li>
        
          <li>
            <a href="/2020/07/31/%E5%89%91%E6%8C%87offer-54%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E7%AC%ACk%E5%A4%A7%E7%BB%93%E7%82%B9/">剑指offer-54二叉搜索树中的第k大结点</a>
          </li>
        
          <li>
            <a href="/2020/07/30/%E5%89%91%E6%8C%87offer-53%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E6%95%B0%E5%AD%97/">剑指offer-53在排序数组中查找数字</a>
          </li>
        
          <li>
            <a href="/2020/07/30/%E5%89%91%E6%8C%87offer-52%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%85%AC%E5%85%B1%E7%BB%93%E7%82%B9/">剑指offer-52两个链表的第一个公共结点</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 Qiao666<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">主页</a>
  
    <a href="/archives" class="mobile-nav-link">归档</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>