<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>剑指offer-53在排序数组中查找数字</title>
      <link href="/2020/07/30/%E5%89%91%E6%8C%87offer-53%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E6%95%B0%E5%AD%97/"/>
      <url>/2020/07/30/%E5%89%91%E6%8C%87offer-53%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E6%95%B0%E5%AD%97/</url>
      
        <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>1：统计一个数字在排序数组中出现的次数。<br>示例 1:<br>输入: nums = [5,7,7,8,8,10], target = 8<br>输出: 2<br>示例 2:<br>输入: nums = [5,7,7,8,8,10], target = 6<br>输出: 0<br>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/zai-pai-xu-shu-zu-zhong-cha-zhao-shu-zi-lcof" target="_blank" rel="noopener">https://leetcode-cn.com/problems/zai-pai-xu-shu-zu-zhong-cha-zhao-shu-zi-lcof</a></p><p>2 ：一个长度为n-1的递增排序数组中的所有数字都是唯一的，并且每个数字都在范围0～n-1之内。在范围0～n-1内的n个数字中有且只有一个数字不在该数组中，请找出这个数字。<br>示例 1:<br>输入: [0,1,3]<br>输出: 2<br>示例 2:<br>输入: [0,1,2,3,4,5,6,7,9]<br>输出: 8<br>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/que-shi-de-shu-zi-lcof" target="_blank" rel="noopener">https://leetcode-cn.com/problems/que-shi-de-shu-zi-lcof</a></p><h1 id="算法分析-代码实现"><a href="#算法分析-代码实现" class="headerlink" title="算法分析+代码实现"></a>算法分析+代码实现</h1><p>1 利用二分查找的思想，确定该值的下标<br>然后根据下标向左，向右遍历，查询该值出现的次数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> search = <span class="function"><span class="keyword">function</span>(<span class="params">nums, target</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> left=<span class="number">0</span></span><br><span class="line">    <span class="keyword">let</span> right=nums.length<span class="number">-1</span></span><br><span class="line">    <span class="keyword">let</span> flag=<span class="number">-1</span></span><br><span class="line">    <span class="comment">//小于最小的</span></span><br><span class="line">    <span class="keyword">if</span>(target&lt;nums[<span class="number">0</span>])&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//大于最大的</span></span><br><span class="line">    <span class="keyword">if</span>(target&gt;nums[right])&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(left&lt;=right)&#123;</span><br><span class="line">        mid=<span class="built_in">Math</span>.floor((left+right)/<span class="number">2</span>)</span><br><span class="line">        <span class="keyword">if</span>(nums[mid]&gt;target)&#123;</span><br><span class="line">            right=mid<span class="number">-1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid]&lt;target)&#123;</span><br><span class="line">            left=mid+<span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid]===target)&#123;</span><br><span class="line">            flag= mid</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(nums[left]===target)&#123;</span><br><span class="line">            flag =left</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(nums[right]===target)&#123;</span><br><span class="line">            flag =right</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> res=<span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span>(flag==<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        res++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//从标志位向左找</span></span><br><span class="line">    left=flag</span><br><span class="line">    <span class="keyword">while</span>(left&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">        left--</span><br><span class="line">        <span class="keyword">if</span>(nums[left]===target)&#123;</span><br><span class="line">            res++</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    right=flag</span><br><span class="line">    <span class="keyword">while</span>(right&lt;=nums.length)&#123;</span><br><span class="line">        right++</span><br><span class="line">        <span class="keyword">if</span>(nums[right]===target)&#123;</span><br><span class="line">            res++</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>结果：<br>执行用时：84 ms, 在所有 JavaScript 提交中击败了27.46%的用户<br>内存消耗：38.8 MB, 在所有 JavaScript 提交中击败了53.57%的用户</p><p>2 直接利用二分查找，只需排除特殊情况</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> missingNumber = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> left=<span class="number">0</span></span><br><span class="line">    <span class="keyword">let</span> right = nums.length<span class="number">-1</span></span><br><span class="line">    <span class="comment">//特殊情况,长度为1</span></span><br><span class="line">    <span class="keyword">if</span>(!right)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[<span class="number">0</span>]===<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(nums[<span class="number">0</span>]===<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断开头，开头不是0,直接返回0</span></span><br><span class="line">    <span class="keyword">if</span>(nums[<span class="number">0</span>]!=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(left&lt;=right)&#123;</span><br><span class="line">        <span class="keyword">let</span> mid = <span class="built_in">Math</span>.floor((left+right)/<span class="number">2</span>)</span><br><span class="line">        <span class="keyword">if</span>(nums[mid]===mid)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid+<span class="number">1</span>]===mid+<span class="number">1</span>)&#123;</span><br><span class="line">                left = mid+<span class="number">1</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> mid+<span class="number">1</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid]!==mid)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid<span class="number">-1</span>]!==mid<span class="number">-1</span>)&#123;</span><br><span class="line">                right = mid<span class="number">-1</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> mid</span><br><span class="line">            &#125;   </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>结果：<br>执行用时：84 ms, 在所有 JavaScript 提交中击败了42.07%的用户<br>内存消耗：38.8 MB, 在所有 JavaScript 提交中击败了95.83%的用户</p><h1 id="总结反思"><a href="#总结反思" class="headerlink" title="总结反思"></a>总结反思</h1><p>该题目的两个小题，复习了二分查找的算法，只要了解了二分查找的基本思想，代码很容易就写出来了</p>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
          <category> 53在排序数组中查找数字 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二分查找 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer-52两个链表的第一个公共结点</title>
      <link href="/2020/07/30/%E5%89%91%E6%8C%87offer-52%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%85%AC%E5%85%B1%E7%BB%93%E7%82%B9/"/>
      <url>/2020/07/30/%E5%89%91%E6%8C%87offer-52%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%85%AC%E5%85%B1%E7%BB%93%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>输入两个链表，找出它们的第一个公共节点。<br>示例 1：<br>输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3<br>输出：Reference of the node with value = 8<br>输入解释：相交节点的值为 8 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。<br> 示例 2：<br>输入：intersectVal = 2, listA = [0,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1<br>输出：Reference of the node with value = 2<br>输入解释：相交节点的值为 2 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [0,9,1,2,4]，链表 B 为 [3,2,4]。在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。<br> 示例 3：<br>输入：intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2<br>输出：null<br>输入解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。<br>解释：这两个链表不相交，因此返回 null。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/liang-ge-lian-biao-de-di-yi-ge-gong-gong-jie-dian-lcof" target="_blank" rel="noopener">https://leetcode-cn.com/problems/liang-ge-lian-biao-de-di-yi-ge-gong-gong-jie-dian-lcof</a></p><h1 id="算法分析-代码实现"><a href="#算法分析-代码实现" class="headerlink" title="算法分析+代码实现"></a>算法分析+代码实现</h1><p>快慢指针<br>首先要得到两个链表的长度，然后根据长度保证两个链表可以同时遍历到最后节点</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> getIntersectionNode = <span class="function"><span class="keyword">function</span>(<span class="params">headA, headB</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//记录ＡＢ两个链表的长度</span></span><br><span class="line">    <span class="keyword">let</span> aLen=<span class="number">0</span>,bLen=<span class="number">0</span></span><br><span class="line">    <span class="keyword">let</span> head=headA</span><br><span class="line">    <span class="keyword">while</span>(head!=<span class="literal">null</span>)&#123;</span><br><span class="line">        head=head.next</span><br><span class="line">        aLen++</span><br><span class="line">    &#125;</span><br><span class="line">    head=headB</span><br><span class="line">    <span class="keyword">while</span>(head!=<span class="literal">null</span>)&#123;</span><br><span class="line">        head=head.next</span><br><span class="line">        bLen++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(aLen,bLen)</span><br><span class="line">    <span class="comment">//遍历长度为最短链表</span></span><br><span class="line">    len=<span class="built_in">Math</span>.min(aLen,bLen)</span><br><span class="line">    <span class="comment">//exLen保存长链表中多出的节点数</span></span><br><span class="line">    exLen=<span class="built_in">Math</span>.max(aLen,bLen)-len</span><br><span class="line">    <span class="keyword">while</span>(exLen)&#123;</span><br><span class="line">        <span class="keyword">if</span>(aLen&gt;bLen)&#123;</span><br><span class="line">            headA=headA.next</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            headB=headB.next</span><br><span class="line">        &#125;</span><br><span class="line">        exLen--</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//注意是结点相同，而不是结点值相同</span></span><br><span class="line">    <span class="keyword">while</span>(len)&#123;</span><br><span class="line">        <span class="keyword">if</span>(headB===headA)&#123;</span><br><span class="line">            <span class="keyword">return</span> headA</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            headA=headA.next</span><br><span class="line">            headB=headB.next</span><br><span class="line">        &#125;</span><br><span class="line">        len--</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> headB</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>结果：<br>执行用时：112 ms, 在所有 JavaScript 提交中击败了44.87%的用户<br>内存消耗：45.6 MB, 在所有 JavaScript 提交中击败了42.86%的用户</p><p>优化版本：最开始的思路，每个链表都需要遍历两次，有些麻烦<br>利用新思路，两个链表只需要遍历一次<br>原理：A =a+c+b,B =b+c+a<br>当两个指针相遇时，必定会停在相交结点，或者二者均是null结点<br>此时返回任意一个结点均可</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> getIntersectionNode = <span class="function"><span class="keyword">function</span>(<span class="params">headA, headB</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> p1 = headA;</span><br><span class="line">    <span class="keyword">let</span> p2 = headB;</span><br><span class="line">    <span class="keyword">while</span>(p1 != p2)&#123;</span><br><span class="line">        p1 = p1 ==<span class="literal">null</span> ? headB :p1.next;</span><br><span class="line">        p2 = p2 ==<span class="literal">null</span> ? headA : p2.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p1;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="总结反思"><a href="#总结反思" class="headerlink" title="总结反思"></a>总结反思</h1><p>首先要明确到底是值相等还是结点相等，我一开始以为是值相等，然后直接就返回了值相等但结点不相等的结点<br>第二个就是要立马想到双指针<br>至于说优化版，看一看，有个印象就好了</p>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
          <category> 52两个链表的第一个公共结点 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 双指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer-51数组中的逆序对</title>
      <link href="/2020/07/28/%E5%89%91%E6%8C%87offer-51%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%80%86%E5%BA%8F%E5%AF%B9/"/>
      <url>/2020/07/28/%E5%89%91%E6%8C%87offer-51%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%80%86%E5%BA%8F%E5%AF%B9/</url>
      
        <content type="html"><![CDATA[<h1 id="题目描述（困难）"><a href="#题目描述（困难）" class="headerlink" title="题目描述（困难）"></a>题目描述（困难）</h1><p>在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数。<br>示例 1:<br>输入: [7,5,6,4]<br>输出: 5<br>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof" target="_blank" rel="noopener">https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof</a></p><h1 id="算法分析-代码实现"><a href="#算法分析-代码实现" class="headerlink" title="算法分析+代码实现"></a>算法分析+代码实现</h1><p>1 暴力运算，两次遍历</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> reversePairs = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums.length&lt;<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//存储逆序对的值</span></span><br><span class="line">    <span class="keyword">let</span> pairs=<span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">let</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> j=i+<span class="number">1</span>;j&lt;nums.length;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]&gt;nums[j])&#123;</span><br><span class="line">                res++</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>结果：超时，时间复杂度为O(n * * 2),我就说哪会这么简单<br>2 归并排序</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> reversePairs = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 归并排序</span></span><br><span class="line">    <span class="keyword">let</span> sum = <span class="number">0</span>;</span><br><span class="line">    mergeSort(nums);</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">    <span class="comment">//排序函数</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">mergeSort</span> (<span class="params">nums</span>) </span>&#123;</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="keyword">if</span>(nums.length &lt; <span class="number">2</span>) <span class="keyword">return</span> nums;</span><br><span class="line">        <span class="keyword">const</span> mid = <span class="built_in">parseInt</span>(nums.length / <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">let</span> left = nums.slice(<span class="number">0</span>,mid);</span><br><span class="line">        <span class="keyword">let</span> right = nums.slice(mid);</span><br><span class="line">        <span class="keyword">return</span> merge(mergeSort(left), mergeSort(right));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//交换函数</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">merge</span>(<span class="params">left, right</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> res = [];</span><br><span class="line">        <span class="keyword">let</span> leftLen = left.length;</span><br><span class="line">        <span class="keyword">let</span> rightLen = right.length;</span><br><span class="line">        <span class="keyword">let</span> len = leftLen + rightLen;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> index = <span class="number">0</span>, i = <span class="number">0</span>, j = <span class="number">0</span>; index &lt; len; index ++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i &gt;= leftLen) res[index] = right[j ++];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (j &gt;= rightLen) res[index] = left[i ++];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (left[i] &lt;= right[j]) res[index] = left[i ++];</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                res[index] = right[j ++];</span><br><span class="line">                sum += leftLen - i;<span class="comment">//在归并排序中唯一加的一行代码</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="总结反思"><a href="#总结反思" class="headerlink" title="总结反思"></a>总结反思</h1><p>要理解归并排序的思路，最好做到可以自己写出该算法</p>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
          <category> 51数组中的逆序对 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 归并排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer-50第一个只出现一次的字符</title>
      <link href="/2020/07/28/%E5%89%91%E6%8C%87offer-50%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E5%AD%97%E7%AC%A6/"/>
      <url>/2020/07/28/%E5%89%91%E6%8C%87offer-50%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E5%AD%97%E7%AC%A6/</url>
      
        <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>在字符串 s 中找出第一个只出现一次的字符。如果没有，返回一个单空格。 s 只包含小写字母。<br>示例:<br>s = “abaccdeff”<br>返回 “b”<br>s = “”<br>返回 “ “<br>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/di-yi-ge-zhi-chu-xian-yi-ci-de-zi-fu-lcof" target="_blank" rel="noopener">https://leetcode-cn.com/problems/di-yi-ge-zhi-chu-xian-yi-ci-de-zi-fu-lcof</a></p><h1 id="算法分析-代码实现"><a href="#算法分析-代码实现" class="headerlink" title="算法分析+代码实现"></a>算法分析+代码实现</h1><p>1 利用hash表，hash表两个值为一对，每对第一个存储字符，第二个存储字符出现的内容，便于第二次按字符串顺序遍历hash表</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> firstUniqChar = <span class="function"><span class="keyword">function</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//s为空，返回该值</span></span><br><span class="line">    <span class="keyword">if</span>(!s.length)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">' '</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> hash=[]</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;s.length;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(hash.indexOf(s[i])&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">            hash[hash.indexOf(s[i])+<span class="number">1</span>]++</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            hash.push(s[i])</span><br><span class="line">            hash.push(<span class="number">1</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;hash.length;i=i+<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(hash[i+<span class="number">1</span>]==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> hash[i]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//hash中不存在只出现一次的值，则返回‘ ’</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">' '</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>结果：<br>执行用时：204 ms, 在所有 JavaScript 提交中击败了6.94%的用户<br>内存消耗：41.2 MB, 在所有 JavaScript 提交中击败了100.00%的用户</p><p>2 hash表的优化版，取消了一对的概念，第二次遍历的时候，直接使用s<br>优化了indexof（）方法<br>使用str.charCodeAt()方法，返回该字符的 UTF-16 编码，</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> firstUniqChar = <span class="function"><span class="keyword">function</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//s为空，返回该值</span></span><br><span class="line">    <span class="keyword">if</span>(!s.length)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">' '</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> hash=<span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">128</span>).fill(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;s.length;i++)&#123;</span><br><span class="line">        <span class="keyword">let</span> p=s[i].charCodeAt()</span><br><span class="line">        hash[p]++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;s.length;i++)&#123;</span><br><span class="line">        <span class="keyword">let</span> p=s[i].charCodeAt()</span><br><span class="line">        <span class="keyword">if</span>(hash[p]==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> s[i]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//hash中不存在只出现一次的值，则返回‘ ’</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">' '</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>结果：<br>执行用时：92 ms, 在所有 JavaScript 提交中击败了96.06%的用户<br>内存消耗：41.6 MB, 在所有 JavaScript 提交中击败了100.00%的用户</p><h1 id="总结反思"><a href="#总结反思" class="headerlink" title="总结反思"></a>总结反思</h1><p>hash表，字符的utf码，数组的indexof等方法要会使用</p>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
          <category> 50第一个只出现一次的字符 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hash表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer-49丑数（因子只包括2,3,5的数）</title>
      <link href="/2020/07/28/%E5%89%91%E6%8C%87offer-49%E4%B8%91%E6%95%B0%EF%BC%88%E5%9B%A0%E5%AD%90%E5%8F%AA%E5%8C%85%E6%8B%AC2%EF%BC%8C3-%EF%BC%8C5%E7%9A%84%E6%95%B0%EF%BC%89/"/>
      <url>/2020/07/28/%E5%89%91%E6%8C%87offer-49%E4%B8%91%E6%95%B0%EF%BC%88%E5%9B%A0%E5%AD%90%E5%8F%AA%E5%8C%85%E6%8B%AC2%EF%BC%8C3-%EF%BC%8C5%E7%9A%84%E6%95%B0%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>我们把只包含质因子 2、3 和 5 的数称作丑数（Ugly Number）。求按从小到大的顺序的第 n 个丑数（1是丑数）。<br>示例:<br>输入: n = 10<br>输出: 12<br>解释: 1, 2, 3, 4, 5, 6, 8, 9, 10, 12 是前 10 个丑数。<br>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/chou-shu-lcof" target="_blank" rel="noopener">https://leetcode-cn.com/problems/chou-shu-lcof</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h1 id="算法分析-代码实现"><a href="#算法分析-代码实现" class="headerlink" title="算法分析+代码实现"></a>算法分析+代码实现</h1><p>1 暴力分析每一个数，但是时间花销太大</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> nthUglyNumber = <span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> UglyN=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">let</span> num=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(UglyN&lt;n)&#123;</span><br><span class="line">        num++</span><br><span class="line">        <span class="comment">//去掉2的因子</span></span><br><span class="line">        <span class="keyword">while</span>(num%<span class="number">2</span>===<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">Math</span>.floor(num/<span class="number">2</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//去掉3的因子</span></span><br><span class="line">        <span class="keyword">while</span>(num%<span class="number">3</span>===<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">Math</span>.floor(num/<span class="number">3</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(num%<span class="number">5</span>===<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">Math</span>.floor(num/<span class="number">5</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(num===<span class="number">1</span>)&#123;</span><br><span class="line">            UglyN++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> num</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>2 动态规划，利用数组存住每一个丑数<br>而新的丑数一定是丑数数组中的某一个丑数 * 2或者 * 3或者 * 5得到的新值<br>使用三指针记录未经过计算的值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> nthUglyNumber = <span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//动态规划数组</span></span><br><span class="line">    <span class="keyword">let</span> num = [<span class="number">1</span>] </span><br><span class="line">    <span class="comment">//创建三个指针，一个表示*2 一个表示*3 一个表示*5</span></span><br><span class="line">    <span class="comment">//每加一次，表示当前位置的数*2/*3/*5已经计算过，自动更新到下一位置</span></span><br><span class="line">    <span class="keyword">let</span> ptr2=<span class="number">0</span></span><br><span class="line">    <span class="keyword">let</span> ptr3=<span class="number">0</span></span><br><span class="line">    <span class="keyword">let</span> ptr5=<span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span>(num.length&lt;=n)&#123;</span><br><span class="line">        <span class="keyword">let</span> i = <span class="built_in">Math</span>.min(num[ptr2]*<span class="number">2</span>,num[ptr3]*<span class="number">3</span>,num[ptr5]*<span class="number">5</span>)</span><br><span class="line">        <span class="comment">//如果最小值是ptr2位置处值*2，则ptr2指向下一位置</span></span><br><span class="line">        <span class="keyword">if</span>(i===num[ptr2]*<span class="number">2</span>)&#123;</span><br><span class="line">            ptr2++</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//同上</span></span><br><span class="line">        <span class="keyword">if</span>(i===num[ptr3]*<span class="number">3</span>)&#123;</span><br><span class="line">            ptr3++</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//同上</span></span><br><span class="line">        <span class="keyword">if</span>(i===num[ptr5]*<span class="number">5</span>)&#123;</span><br><span class="line">            ptr5++</span><br><span class="line">        &#125;</span><br><span class="line">        num.push(i)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> num[n<span class="number">-1</span>]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>结果:<br>执行用时：108 ms, 在所有 JavaScript 提交中击败了21.91%的用户<br>内存消耗：41.2 MB, 在所有 JavaScript 提交中击败了100.00%的用户</p><h1 id="总结反思"><a href="#总结反思" class="headerlink" title="总结反思"></a>总结反思</h1><p>动态规划和三指针相结合，一开始也想到了要使用数组存储，但是由于没想到用三指针，所以不明白代码该如何实现，因为无法确定到底是之前存储的哪个值来乘2，乘3还是乘5。</p>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
          <category> 49丑数 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
            <tag> 双指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer-48最长不重复字串</title>
      <link href="/2020/07/26/%E5%89%91%E6%8C%87offer-48%E6%9C%80%E9%95%BF%E4%B8%8D%E9%87%8D%E5%A4%8D%E5%AD%97%E4%B8%B2/"/>
      <url>/2020/07/26/%E5%89%91%E6%8C%87offer-48%E6%9C%80%E9%95%BF%E4%B8%8D%E9%87%8D%E5%A4%8D%E5%AD%97%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>请从字符串中找出一个最长的不包含重复字符的子字符串，计算该最长子字符串的长度。<br>示例 1:<br>输入: “abcabcbb”<br>输出: 3<br>解释: 因为无重复字符的最长子串是 “abc”，所以其长度为 3。<br>示例 2:<br>输入: “bbbbb”<br>输出: 1<br>解释: 因为无重复字符的最长子串是 “b”，所以其长度为 1。<br>示例 3:<br>输入: “pwwkew”<br>输出: 3<br>解释: 因为无重复字符的最长子串是 “wke”，所以其长度为 3。<br>请注意，你的答案必须是 子串 的长度，”pwke” 是一个子序列，不是子串。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/zui-chang-bu-han-zhong-fu-zi-fu-de-zi-zi-fu-chuan-lcof" target="_blank" rel="noopener">https://leetcode-cn.com/problems/zui-chang-bu-han-zhong-fu-zi-fu-de-zi-zi-fu-chuan-lcof</a></p><h1 id="算法分析-代码实现"><a href="#算法分析-代码实现" class="headerlink" title="算法分析+代码实现"></a>算法分析+代码实现</h1><p>滑动窗口解法,记录头尾两个值，然后根据情况跟新头尾</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> lengthOfLongestSubstring = <span class="function"><span class="keyword">function</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//考虑1特殊情况</span></span><br><span class="line">    <span class="keyword">if</span>(!s.length||s.length==<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> s.length</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> res=<span class="number">0</span></span><br><span class="line">    <span class="comment">//滑动窗口设计</span></span><br><span class="line">    <span class="comment">//两个值，一个头，一个尾部，</span></span><br><span class="line">    <span class="keyword">let</span> head=<span class="number">0</span>,tail=<span class="number">0</span></span><br><span class="line">    <span class="keyword">let</span> win=<span class="string">''</span><span class="comment">//滑动窗口的内容</span></span><br><span class="line">    <span class="keyword">while</span>(tail&lt;s.length)&#123;</span><br><span class="line">        <span class="comment">//如果当前值不在窗口，但是有可能一直没有重复值，需要在循环结束以后再判断一次</span></span><br><span class="line">        <span class="keyword">if</span>(!win.includes(s[tail]))&#123;</span><br><span class="line">            win+=s[tail]</span><br><span class="line">            tail++</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果包含该字符，则利用indexof更新head值,并更新win串</span></span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            head=win.indexOf(s[tail])+<span class="number">1</span></span><br><span class="line">            win=win.slice(head)</span><br><span class="line">            win+=s[tail]</span><br><span class="line">            tail++</span><br><span class="line">        &#125;</span><br><span class="line">        res&gt;win.length?<span class="literal">null</span>:res=win.length;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>结果：<br>执行用时：120 ms, 在所有 JavaScript 提交中击败了46.65%的用户<br>内存消耗：43.6 MB, 在所有 JavaScript 提交中击败了100.00%的用户</p><p>优化版：<br>不使用include（）,只使用indexof()<br>indexOf() 方法返回调用它的 String 对象中第一次出现的指定值的索引，从 fromIndex 处进行搜索。如果未找到该值，则返回 -1。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> lengthOfLongestSubstring = <span class="function"><span class="keyword">function</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> len = s.length;</span><br><span class="line">    <span class="keyword">let</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> temp = <span class="string">''</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i ++) &#123;</span><br><span class="line">    <span class="comment">//没找到，则更新字串，更新最大值</span></span><br><span class="line">        <span class="keyword">if</span>(temp.indexOf(s[i]) === <span class="number">-1</span>) &#123;</span><br><span class="line">            temp += s[i];</span><br><span class="line">            res = <span class="built_in">Math</span>.max(res, temp.length);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            temp = temp.slice(temp.indexOf(s[i]) + <span class="number">1</span>);</span><br><span class="line">            temp += s[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>结果：<br>执行用时：116 ms, 在所有 JavaScript 提交中击败了51.27%的用户<br>内存消耗：43.5 MB, 在所有 JavaScript 提交中击败了100.00%的用户</p><p>3 原书最优解：动态规划<br>三个值，maxlength保存最大长度,curlength保存当前长度，preindex保存该字符上次出现的下标<br>一个数组 position[]保存每个字符上次出现的在s中的下标，由于该题目未明确所给字符串中有何值，故长度为128，可以保存ASCALL码中的128个字符</p><p>然后根据当前字符的下标和上次出现的下标来计算当前最大子串<br>只有当当前子串中有重复值时，才更新最大长度<br>否则当前子串长度+1</p><p>注意最后仍要比较一次最大长度和当前长度</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> lengthOfLongestSubstring = <span class="function"><span class="keyword">function</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//首先创建一个记录字符出现下标的值</span></span><br><span class="line">    <span class="keyword">const</span> position=<span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">128</span>).fill(<span class="number">-1</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> maxlength=<span class="number">0</span>,curlength=<span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;s.length;i++)&#123;</span><br><span class="line">        <span class="keyword">let</span> preIndex=position[s[i].charCodeAt()]</span><br><span class="line">        <span class="comment">//根据出现的值的下标</span></span><br><span class="line">        <span class="comment">//如果没出现过,或者距上次出现的长度要大于当前最大子串的长度</span></span><br><span class="line">        <span class="keyword">if</span>(preIndex==<span class="number">-1</span>||i-preIndex&gt;curlength)&#123;</span><br><span class="line">            <span class="comment">//当前的子串长度+1</span></span><br><span class="line">            curlength++</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//上次出现的长度要小于当前最大子串的长度</span></span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//如果上次出现的距离比当前最大字串要小</span></span><br><span class="line">            <span class="comment">// 更新最大值</span></span><br><span class="line">            maxlength&lt;curlength?maxlength=curlength:<span class="literal">null</span>;</span><br><span class="line">            <span class="comment">// 再要减去重复值</span></span><br><span class="line">            curlength=i-preIndex</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 更新对应的positon值,为当前下标值</span></span><br><span class="line">        position[s[i].charCodeAt()]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//结束以后再判断一次最大值和当前子串长度</span></span><br><span class="line">    maxlength&lt;curlength?maxlength=curlength:<span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> maxlength</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>结果：时间复杂度为O(n),空间复杂度为O(1)<br>执行用时：108 ms, 在所有 JavaScript 提交中击败了66.91%的用户<br>内存消耗：40 MB, 在所有 JavaScript 提交中击败了100.00%的用户</p><h1 id="总结反思"><a href="#总结反思" class="headerlink" title="总结反思"></a>总结反思</h1><p>该题目主要考察的就是双指针的用法<br>动态规划方法其实也是利用了双指针的思想</p>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
          <category> 48最长不重复字串 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
            <tag> 双指针 </tag>
            
            <tag> 滑动窗口 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer-47礼物的最大价值</title>
      <link href="/2020/07/26/%E5%89%91%E6%8C%87offer-47%E7%A4%BC%E7%89%A9%E7%9A%84%E6%9C%80%E5%A4%A7%E4%BB%B7%E5%80%BC/"/>
      <url>/2020/07/26/%E5%89%91%E6%8C%87offer-47%E7%A4%BC%E7%89%A9%E7%9A%84%E6%9C%80%E5%A4%A7%E4%BB%B7%E5%80%BC/</url>
      
        <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>在一个 m * n 的棋盘的每一格都放有一个礼物，每个礼物都有一定的价值（价值大于 0）。你可以从棋盘的左上角开始拿格子里的礼物，并每次向右或者向下移动一格、直到到达棋盘的右下角。给定一个棋盘及其上面的礼物的价值，请计算你最多能拿到多少价值的礼物？<br>示例 1:<br>输入:<br>[<br>  [1,3,1],<br>  [1,5,1],<br>  [4,2,1]<br>]<br>输出: 12<br>解释: 路径 1→3→5→2→1 可以拿到最多价值的礼物<br>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/li-wu-de-zui-da-jie-zhi-lcof" target="_blank" rel="noopener">https://leetcode-cn.com/problems/li-wu-de-zui-da-jie-zhi-lcof</a></p><h1 id="算法分析-代码实现"><a href="#算法分析-代码实现" class="headerlink" title="算法分析+代码实现"></a>算法分析+代码实现</h1><p>经典动态规划，构建二维数组dp [ m] [ n ],其中dp[i][j]表示的是当走到当前格时，所能取到的最大值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> maxValue = <span class="function"><span class="keyword">function</span>(<span class="params">grid</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> row=grid.length<span class="comment">//行数</span></span><br><span class="line">    <span class="keyword">let</span> col = grid[<span class="number">0</span>].length<span class="comment">//列数</span></span><br><span class="line">    <span class="comment">//构建dp二维数组</span></span><br><span class="line">    <span class="comment">//map()方法：返回一个由原数组每个元素执行回调函数的结果组成的新数组。</span></span><br><span class="line">    <span class="keyword">let</span> dp =<span class="keyword">new</span> <span class="built_in">Array</span>(row).fill(<span class="number">0</span>).map(<span class="function"><span class="params">item</span>=&gt;</span>item=<span class="keyword">new</span> <span class="built_in">Array</span>(col).fill(<span class="number">0</span>))</span><br><span class="line">    <span class="comment">// 开始构建dp内容</span></span><br><span class="line">    <span class="comment">//明确端点值</span></span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>]=grid[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line">    <span class="comment">// 首先构建左边的和上边的值，当然也是从开始值开始累加的</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">1</span>;i&lt;row;i++)&#123;</span><br><span class="line">        dp[i][<span class="number">0</span>]=dp[i<span class="number">-1</span>][<span class="number">0</span>]+grid[i][<span class="number">0</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> j = <span class="number">1</span>;j&lt;col;j++)&#123;</span><br><span class="line">        dp[<span class="number">0</span>][j]=dp[<span class="number">0</span>][j<span class="number">-1</span>]+grid[<span class="number">0</span>][j]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">1</span>;i&lt;row;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> j = <span class="number">1</span>;j&lt;col;j++)&#123;</span><br><span class="line">            dp[i][j]=grid[i][j]+<span class="built_in">Math</span>.max(dp[i<span class="number">-1</span>][j],dp[i][j<span class="number">-1</span>])</span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[row<span class="number">-1</span>][col<span class="number">-1</span>]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>结果：时间复杂度为O( m * n),空间复杂度为O( m * n)<br>执行用时：104 ms, 在所有 JavaScript 提交中击败了10.98%的用户<br>内存消耗：39.4 MB, 在所有 JavaScript 提交中击败了100.00%的用户</p><p>优化：直接在数组上进行修改</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> maxValue = <span class="function"><span class="keyword">function</span>(<span class="params">grid</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> row=grid.length<span class="comment">//行数</span></span><br><span class="line">    <span class="keyword">let</span> col = grid[<span class="number">0</span>].length<span class="comment">//列数</span></span><br><span class="line">   </span><br><span class="line">    <span class="comment">// 开始构建dp内容</span></span><br><span class="line">   </span><br><span class="line">    <span class="comment">// 首先构建左边的和上边的值</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">1</span>;i&lt;row;i++)&#123;</span><br><span class="line">        grid[i][<span class="number">0</span>]+=grid[i<span class="number">-1</span>][<span class="number">0</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> j = <span class="number">1</span>;j&lt;col;j++)&#123;</span><br><span class="line">        grid[<span class="number">0</span>][j]+=grid[<span class="number">0</span>][j<span class="number">-1</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">1</span>;i&lt;row;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> j = <span class="number">1</span>;j&lt;col;j++)&#123;</span><br><span class="line">            grid[i][j]+=<span class="built_in">Math</span>.max(grid[i<span class="number">-1</span>][j],grid[i][j<span class="number">-1</span>])</span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> grid[row<span class="number">-1</span>][col<span class="number">-1</span>]</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>结果：时间复杂度不变，但是空间复杂度降为1<br>执行用时：80 ms, 在所有 JavaScript 提交中击败了47.54%的用户<br>内存消耗：38.1 MB, 在所有 JavaScript 提交中击败了100.00%的用户</p><h1 id="总结反思"><a href="#总结反思" class="headerlink" title="总结反思"></a>总结反思</h1><p>动态规划理解的时候，是从下往上去找最佳答案，<br>但是注意，设计代码的时候，是从上往下设计的，先有上面的最佳答案，才会有下面的最佳答案<br>一开始我总是理解为从下往上设计代码，然后怎么也理解不了，就算别人写好的代码，我看的时候也总感觉是云里雾里的看不真切，看不明白。<br>然后我就去重新找了一些讲解动态规划思路的博客，先理清楚了动态规划，然后再写代码或者看代码就容易多了</p>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
          <category> 47礼物的最大价值 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer-46把数字翻译成字符串</title>
      <link href="/2020/07/23/%E5%89%91%E6%8C%87offer-46%E6%8A%8A%E6%95%B0%E5%AD%97%E7%BF%BB%E8%AF%91%E6%88%90%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
      <url>/2020/07/23/%E5%89%91%E6%8C%87offer-46%E6%8A%8A%E6%95%B0%E5%AD%97%E7%BF%BB%E8%AF%91%E6%88%90%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>把数字翻译成字符串(中等):</p><p>给定一个数字，我们按照如下规则把它翻译为字符串：0 翻译成 “a” ，1 翻译成 “b”，……，11 翻译成 “l”，……，25 翻译成 “z”。一个数字可能有多个翻译。请编程实现一个函数，用来计算一个数字有多少种不同的翻译方法。<br>示例 1:<br>输入: 12258<br>输出: 5<br>解释: 12258有5种不同的翻译，分别是”bccfi”, “bwfi”, “bczi”, “mcfi”和”mzi”<br>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/ba-shu-zi-fan-yi-cheng-zi-fu-chuan-lcof" target="_blank" rel="noopener">https://leetcode-cn.com/problems/ba-shu-zi-fan-yi-cheng-zi-fu-chuan-lcof</a></p><h1 id="算法分析-代码实现"><a href="#算法分析-代码实现" class="headerlink" title="算法分析+代码实现"></a>算法分析+代码实现</h1><p>基本思路是递归<br>利用数组的shift和unshift完成首数据的出入行为<br>代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> translateNum = <span class="function"><span class="keyword">function</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> way = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">dfs</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!arr.length)&#123;</span><br><span class="line">            way++</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">let</span> first=arr.shift()</span><br><span class="line">        <span class="comment">//往后推一个数       </span></span><br><span class="line">        dfs(arr)</span><br><span class="line"></span><br><span class="line">        <span class="comment">//用完之后将原数据放入</span></span><br><span class="line">        arr.unshift(first)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> Rfirst=arr.shift()</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//说明只有一个数</span></span><br><span class="line">        <span class="keyword">if</span>(!arr.length)&#123;</span><br><span class="line">           arr.unshift(Rfirst)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> secend=arr.shift()</span><br><span class="line">        <span class="comment">//往后推两个数       </span></span><br><span class="line">        <span class="keyword">if</span>(Rfirst+secend&lt;<span class="string">"26"</span>&amp;&amp;Rfirst+secend&gt;<span class="number">9</span>)&#123;</span><br><span class="line">            dfs(arr)</span><br><span class="line">        &#125;</span><br><span class="line">        arr.unshift(secend)</span><br><span class="line">        arr.unshift(Rfirst)</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(num.toString().split(<span class="string">''</span>))</span><br><span class="line">    <span class="keyword">return</span> way </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>结果：因为每个字母可能被分析两次，故时间复杂度为O(2 * * n)<br>执行用时：92 ms, 在所有 JavaScript 提交中击败了7.36%的用户<br>内存消耗：37.5 MB, 在所有 JavaScript 提交中击败了100.00%的用户</p><p>2 动态规划解决,</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//未优化的版本；</span></span><br><span class="line"><span class="keyword">const</span> translateNum = <span class="function">(<span class="params">num</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> str = num.toString()</span><br><span class="line">  <span class="keyword">const</span> n = str.length</span><br><span class="line">  <span class="keyword">const</span> dp = <span class="keyword">new</span> <span class="built_in">Array</span>(n + <span class="number">1</span>)</span><br><span class="line">  dp[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">  dp[<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">2</span>; i &lt; n + <span class="number">1</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> temp = <span class="built_in">Number</span>(str[i - <span class="number">2</span>] + str[i - <span class="number">1</span>])</span><br><span class="line">    <span class="keyword">if</span> (temp &gt;= <span class="number">10</span> &amp;&amp; temp &lt;= <span class="number">25</span>) &#123;</span><br><span class="line">      dp[i] = dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>]</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      dp[i] = dp[i - <span class="number">1</span>]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> dp[n] <span class="comment">// 翻译前n个数的方法数，即翻译整个数字</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：时间复杂度为O(n),空间复杂度为O(n)<br>执行用时：80 ms, 在所有 JavaScript 提交中击败了16.67%的用户<br>内存消耗：37.6 MB, 在所有 JavaScript 提交中击败了100.00%的用户</p><p>可以优化一次，只需要用两个变量保存dp[i-1]和dp[i-2]即可<br>空间复杂度变为O(1)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> translateNum = <span class="function"><span class="keyword">function</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line"><span class="comment">//将numer类型变为字符串,方便变量</span></span><br><span class="line">  num=<span class="built_in">String</span>(num)</span><br><span class="line"><span class="comment">//初始化dp</span></span><br><span class="line">  <span class="keyword">let</span> pre = <span class="number">1</span></span><br><span class="line">  <span class="keyword">let</span> cur = <span class="number">1</span></span><br><span class="line"><span class="comment">//循环求最后dp</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">2</span>;i&lt;=num.length;i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(num.substr(i<span class="number">-2</span>,<span class="number">2</span>)&lt;=<span class="number">25</span>&amp;&amp;num.substr(i<span class="number">-2</span>,<span class="number">2</span>)&gt;=<span class="number">10</span>)&#123;</span><br><span class="line">    <span class="comment">//解构赋值，es6语法</span></span><br><span class="line">      [pre,cur] = [cur,pre+cur]</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      [pre,cur] = [cur,cur]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> cur</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>结果:<br>执行用时：80 ms, 在所有 JavaScript 提交中击败了16.67%的用户<br>内存消耗：37.6 MB, 在所有 JavaScript 提交中击败了100.00%的用户</p><h1 id="总结反思"><a href="#总结反思" class="headerlink" title="总结反思"></a>总结反思</h1><p>首先要可以想到递归，并手写出递归的函数<br>其次要想到动态规划，因为该问题可以分为子问题去解决<br>在动态规划的基础上，我们可以进行更进一步的优化，空间方面的优化</p>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
          <category> 46把数字翻译成字符串 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
            <tag> 递归 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer-45把数组排成最小的数</title>
      <link href="/2020/07/22/%E5%89%91%E6%8C%87offer-45%E6%8A%8A%E6%95%B0%E7%BB%84%E6%8E%92%E6%88%90%E6%9C%80%E5%B0%8F%E7%9A%84%E6%95%B0/"/>
      <url>/2020/07/22/%E5%89%91%E6%8C%87offer-45%E6%8A%8A%E6%95%B0%E7%BB%84%E6%8E%92%E6%88%90%E6%9C%80%E5%B0%8F%E7%9A%84%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>把数组排成最小的数:</p><p>输入一个非负整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。<br>示例 1:<br>输入: [10,2]<br>输出: “102”<br>示例 2:<br>输入: [3,30,34,5,9]<br>输出: “3033459”<br>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/ba-shu-zu-pai-cheng-zui-xiao-de-shu-lcof" target="_blank" rel="noopener">https://leetcode-cn.com/problems/ba-shu-zu-pai-cheng-zui-xiao-de-shu-lcof</a></p><h1 id="算法分析-代码实现"><a href="#算法分析-代码实现" class="headerlink" title="算法分析+代码实现"></a>算法分析+代码实现</h1><p>利用js 的sort方法，添加人为判断条件：当ab&gt;ba时，返回-1，否则返回1<br>MDN中sort描述：<br>arr.sort([compareFunction])：<br>如果 compareFunction(a, b) 小于 0 ，那么 a 会被排列到 b 之前；<br>如果 compareFunction(a, b) 大于 0 ， b 会被排列到 a 之前。<br>链接如下<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/sort" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/sort</a></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> minNumber = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//初次排序</span></span><br><span class="line">    nums.sort(<span class="function">(<span class="params">a,b</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (a+<span class="string">''</span>+b)-(b+<span class="string">''</span>+a)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">//结果使用数组的join方法，将数组拼接成字符串</span></span><br><span class="line">    <span class="keyword">return</span> nums.join(<span class="string">''</span>)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>结果：</p><p>执行用时：84 ms, 在所有 JavaScript 提交中击败了50.96%的用户</p><p>内存消耗：39.6 MB, 在所有 JavaScript 提交中击败了100.00%的用户</p><h1 id="总结反思"><a href="#总结反思" class="headerlink" title="总结反思"></a>总结反思</h1><p>该题目要考察的是能否想到ab&gt;ba这个判断条件，能想到的话，这个题目基本就没难度了</p><p>在 js 中，利用a+””+b将一个number型转换为string型</p><p>然后利用sort自带函数比较排序</p><p>最后使用数组的join方法将数组拼接</p>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
          <category> 45把数组排成最小的数 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> sort排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer-44数字序列中某一位的数字</title>
      <link href="/2020/07/22/%E5%89%91%E6%8C%87offer-44%E6%95%B0%E5%AD%97%E5%BA%8F%E5%88%97%E4%B8%AD%E6%9F%90%E4%B8%80%E4%BD%8D%E7%9A%84%E6%95%B0%E5%AD%97/"/>
      <url>/2020/07/22/%E5%89%91%E6%8C%87offer-44%E6%95%B0%E5%AD%97%E5%BA%8F%E5%88%97%E4%B8%AD%E6%9F%90%E4%B8%80%E4%BD%8D%E7%9A%84%E6%95%B0%E5%AD%97/</url>
      
        <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>数字以0123456789101112131415…的格式序列化到一个字符序列中。在这个序列中，第5位（从下标0开始计数）是5，第13位是1，第19位是4，等等。<br>请写一个函数，求任意第n位对应的数字。<br>示例 1：<br>输入：n = 3<br>输出：3<br>示例 2：<br>输入：n = 11<br>输出：0<br>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/shu-zi-xu-lie-zhong-mou-yi-wei-de-shu-zi-lcof" target="_blank" rel="noopener">https://leetcode-cn.com/problems/shu-zi-xu-lie-zhong-mou-yi-wei-de-shu-zi-lcof</a></p><h1 id="算法分析-代码实现"><a href="#算法分析-代码实现" class="headerlink" title="算法分析+代码实现"></a>算法分析+代码实现</h1><p>基本思路就是按位分析，判断该数字是几位数，然后再根据位数来取商和余，商确定是哪一个值，余确定是该数字的第几位</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> findNthDigit = <span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//0-9：0-9 t开始值 位数l l=1</span></span><br><span class="line">    <span class="comment">//10-99：t+~t+90*2 t开始值：t+1  位数 l=2</span></span><br><span class="line">    <span class="comment">//100-999：190+1~t+3*900 t开始值：t+1 位数 l=3</span></span><br><span class="line">    <span class="keyword">let</span> t=<span class="number">9</span>,l=<span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//当n&lt;10时，直接输出即可</span></span><br><span class="line">    <span class="keyword">if</span>(n&lt;<span class="number">10</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> n</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//首先判断该数字处在几位数的范围内，同时减去上一次计算的临界值</span></span><br><span class="line">    <span class="comment">//保证每次计数时是从10/100/1000等数值开始计算</span></span><br><span class="line">    <span class="keyword">while</span>(n&gt;=t)&#123;</span><br><span class="line">        n-=t</span><br><span class="line">        t=<span class="number">9</span>*<span class="number">10</span>**l*(l+<span class="number">1</span>);</span><br><span class="line">        l++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//然后根据位数来判断该数所处的范围</span></span><br><span class="line">    <span class="comment">//保证n从0开始计数，也就是调整n由计数值变为下标值</span></span><br><span class="line">    n--;</span><br><span class="line">    <span class="comment">//由于是从10/100/1000等开始计算的，所以计算值的时候前面要加上之前丢失的部分</span></span><br><span class="line">    <span class="comment">//加‘’使得start变为string 可以通过下标来确定该数的某一位的值</span></span><br><span class="line">    <span class="keyword">let</span> start = <span class="number">10</span>**(l<span class="number">-1</span>)+<span class="built_in">Math</span>.floor(n/l)+<span class="string">' '</span></span><br><span class="line">    <span class="keyword">return</span> start[n%l]</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>结果：<br>执行用时：72 ms, 在所有 JavaScript 提交中击败了44.64%的用户<br>内存消耗：37.7 MB, 在所有 JavaScript 提交中击败了100.00%的用户</p><h1 id="总结反思"><a href="#总结反思" class="headerlink" title="总结反思"></a>总结反思</h1><p>按位分析，仔细思考<br>要注意的就是js中Number和string的相互转化</p>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
          <category> 44数字序列中某一位的数字 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer-43从1到n整数中1出现的次数</title>
      <link href="/2020/07/21/%E5%89%91%E6%8C%87offer-43-1-n%E6%95%B4%E6%95%B0%E4%B8%AD1%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0/"/>
      <url>/2020/07/21/%E5%89%91%E6%8C%87offer-43-1-n%E6%95%B4%E6%95%B0%E4%B8%AD1%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>输入一个整数 n ，求1～n这n个整数的十进制表示中1出现的次数。<br>例如，输入12，1～12这些整数中包含1 的数字有1、10、11和12，1一共出现了5次。<br> 示例 1：<br>输入：n = 12<br>输出：5<br>示例 2：<br>输入：n = 13<br>输出：6<br>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/1nzheng-shu-zhong-1chu-xian-de-ci-shu-lcof" target="_blank" rel="noopener">https://leetcode-cn.com/problems/1nzheng-shu-zhong-1chu-xian-de-ci-shu-lcof</a></p><h1 id="算法实现-代码分析"><a href="#算法实现-代码分析" class="headerlink" title="算法实现+代码分析"></a>算法实现+代码分析</h1><p>我是一个无情的搬运工</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> countDigitOne = <span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> small= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> base = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(n!==<span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> single = n%<span class="number">10</span>;</span><br><span class="line">        <span class="keyword">let</span> big = <span class="built_in">Math</span>.floor(n/<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">if</span>(single===<span class="number">0</span>) &#123;</span><br><span class="line">            sum+=big*base;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(single===<span class="number">1</span>)&#123;</span><br><span class="line">            sum+=big*base;</span><br><span class="line">            sum+=(small+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            sum+=(big+<span class="number">1</span>)*base;</span><br><span class="line">        &#125;</span><br><span class="line">        single*=base;</span><br><span class="line">        small+=single;</span><br><span class="line">        base*=<span class="number">10</span>;</span><br><span class="line">        n = <span class="built_in">Math</span>.floor(n/<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：<br>执行用时：92 ms, 在所有 JavaScript 提交中击败了8.62%的用户<br>内存消耗：37.4 MB, 在所有 JavaScript 提交中击败了100.00%的用户</p><h1 id="总结反思"><a href="#总结反思" class="headerlink" title="总结反思"></a>总结反思</h1><p>基本思路明白，分析问题时多归纳多总结</p>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
          <category> 43 1~n整数中1出现的次数 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer-42连续子数组的最大值</title>
      <link href="/2020/07/21/%E5%89%91%E6%8C%87offer-42%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC/"/>
      <url>/2020/07/21/%E5%89%91%E6%8C%87offer-42%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC/</url>
      
        <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>输入一个整型数组，数组里有正数也有负数。数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值。<br>要求时间复杂度为O(n)。</p><p>示例1:<br>输入: nums = [-2,1,-3,4,-1,2,1,-5,4]<br>输出: 6<br>解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/lian-xu-zi-shu-zu-de-zui-da-he-lcof" target="_blank" rel="noopener">https://leetcode-cn.com/problems/lian-xu-zi-shu-zu-de-zui-da-he-lcof</a></p><h1 id="算法分析-代码实现"><a href="#算法分析-代码实现" class="headerlink" title="算法分析+代码实现"></a>算法分析+代码实现</h1><p>1 直接遍历<br>利用两个值，一个记录当前累加的和，一个记录最大和<br>当累加和&lt;0时，积累和的值为当前所遍历的元素的值<br>操作结束后比较当前和，最大和大小，然后取最大值赋给最大和</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> maxSubArray = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!nums.length)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> max=curMax=nums[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">1</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">        <span class="comment">//如果之前的和小于零,则抛弃之前的和，直接从当前值开始计算</span></span><br><span class="line">        <span class="keyword">if</span>(curMax&lt;<span class="number">0</span>)&#123;</span><br><span class="line">            curMax = nums[i]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//开始累加</span></span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">          curMax+=nums[i]</span><br><span class="line">        &#125;</span><br><span class="line">        max=<span class="built_in">Math</span>.max(curMax,max)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>结果：时间复杂度为O(n)，空间复杂度为O(1)<br>执行用时：92 ms, 在所有 JavaScript 提交中击败了29.10%的用户<br>内存消耗：40.2 MB, 在所有 JavaScript 提交中击败了100.00%的用户</p><p>2 动态规划<br>该题目可以拆分成多个小问题<br>代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> maxSubArray = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//此时原数组第n个值成为了前n个数组的和的最大值</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">1</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">        <span class="comment">//只有当前项的前一项&gt;0时，才修改当前数值</span></span><br><span class="line">        <span class="keyword">if</span>(nums[i<span class="number">-1</span>]&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">            nums[i]+=nums[i<span class="number">-1</span>]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//这里直接输出nums的最大值</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.max(...nums)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>结果：该方法直接在元素组上修改，如果不想修改的话，空间复杂度就为O(n)<br>执行用时：104 ms, 在所有 JavaScript 提交中击败了12.24%的用户<br>内存消耗：40.6 MB, 在所有 JavaScript 提交中击败了100.00%的用户</p><h1 id="总结反思"><a href="#总结反思" class="headerlink" title="总结反思"></a>总结反思</h1><p>动态规划适用于可以将大问题分解成小问题的情况，但是需要额外空间，使用时要仔细斟酌，以免把简单问题复杂化</p>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
          <category> 42连续子数组的最大值 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer-41数据流中的中位数</title>
      <link href="/2020/07/20/%E5%89%91%E6%8C%87offer-41%E6%95%B0%E6%8D%AE%E6%B5%81%E4%B8%AD%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/"/>
      <url>/2020/07/20/%E5%89%91%E6%8C%87offer-41%E6%95%B0%E6%8D%AE%E6%B5%81%E4%B8%AD%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。<br>例如，<br>[2,3,4] 的中位数是 3<br>[2,3] 的中位数是 (2 + 3) / 2 = 2.5<br>设计一个支持以下两种操作的数据结构：<br>void addNum(int num) - 从数据流中添加一个整数到数据结构中。<br>double findMedian() - 返回目前所有元素的中位数。<br>示例 1：<br>输入：<br>[“MedianFinder”,”addNum”,”addNum”,”findMedian”,”addNum”,”findMedian”]<br>[[],[1],[2],[],[3],[]]<br>输出：[null,null,null,1.50000,null,2.00000]<br>示例 2：<br>输入：<br>[“MedianFinder”,”addNum”,”findMedian”,”addNum”,”findMedian”]<br>[[],[2],[],[3],[]]<br>输出：[null,null,2.00000,null,2.50000]</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/shu-ju-liu-zhong-de-zhong-wei-shu-lcof" target="_blank" rel="noopener">https://leetcode-cn.com/problems/shu-ju-liu-zhong-de-zhong-wei-shu-lcof</a></p><h1 id="算法分析-代码实现"><a href="#算法分析-代码实现" class="headerlink" title="算法分析+代码实现"></a>算法分析+代码实现</h1><p>1 注意到 插入数据以后，要有一个排序的过程，暴力排序或者插入排序,或者二分查找<br>//时间复杂度：O(N),空间复杂度O(1)<br>//利用js数组的push(), unshift(),splice()方法，实现插入排序</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> MedianFinder = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.data=[]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">MedianFinder.prototype.addNum = <span class="function"><span class="keyword">function</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//当前栈中没有元素，则不需要排序，直接push</span></span><br><span class="line">    <span class="keyword">if</span>(!<span class="keyword">this</span>.data.length)&#123;</span><br><span class="line">        <span class="keyword">this</span>.data.push(num)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//接下来进行排序</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//直接利用sort（）快排</span></span><br><span class="line">    <span class="comment">//this.data.push(num)</span></span><br><span class="line">    <span class="comment">//this.data.sort((a,b)=&gt;&#123;return a-b&#125;)</span></span><br><span class="line">    <span class="comment">//return</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//插入排序</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//比最大的大</span></span><br><span class="line">    <span class="comment">//if(num&gt;=this.data[this.data.length-1])&#123;</span></span><br><span class="line">    <span class="comment">//    this.data.push(num)</span></span><br><span class="line">    <span class="comment">//    return</span></span><br><span class="line">    <span class="comment">//&#125;</span></span><br><span class="line">    <span class="comment">//比最小的小</span></span><br><span class="line">    <span class="comment">//if(num&lt;=this.data[0])&#123;</span></span><br><span class="line">    <span class="comment">//    this.data.unshift(num)</span></span><br><span class="line">    <span class="comment">//    return</span></span><br><span class="line">    <span class="comment">//&#125;</span></span><br><span class="line">    <span class="comment">//let numindex=this.data.length-1;</span></span><br><span class="line">    <span class="comment">//for(;numindex&gt;=0;numindex--)&#123;</span></span><br><span class="line">    <span class="comment">//    if(this.data[numindex]&lt;num)&#123;</span></span><br><span class="line">    <span class="comment">//        break</span></span><br><span class="line">    <span class="comment">//    &#125;</span></span><br><span class="line">    <span class="comment">//&#125;</span></span><br><span class="line">    <span class="comment">//寻找data数组中小于num的最大值所在的位置 </span></span><br><span class="line">    <span class="comment">//this.data.splice(numindex+1,0,num)</span></span><br><span class="line">    <span class="comment">//return </span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//二分查找</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> left=<span class="number">0</span>,right=<span class="keyword">this</span>.data.length<span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(left&lt;=right)&#123;</span><br><span class="line">        <span class="keyword">let</span> mid= <span class="built_in">Math</span>.floor((left+right)/<span class="number">2</span>)</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.data[mid]==num)&#123;</span><br><span class="line">            <span class="keyword">this</span>.data.splice(mid+<span class="number">1</span>,<span class="number">0</span>,num)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.data[mid]&lt;num)&#123;</span><br><span class="line">            left=mid+<span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            right=mid<span class="number">-1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//寻找data数组中小于num的最大值所在的位置 </span></span><br><span class="line">    <span class="keyword">this</span>.data.splice(right+<span class="number">1</span>,<span class="number">0</span>,num)</span><br><span class="line">    <span class="keyword">return</span> </span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">MedianFinder.prototype.findMedian = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//数组长度为奇数</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>.data.length&amp;<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.data[(<span class="keyword">this</span>.data.length<span class="number">-1</span>)/<span class="number">2</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">this</span>.data[<span class="keyword">this</span>.data.length/<span class="number">2</span>]+<span class="keyword">this</span>.data[<span class="keyword">this</span>.data.length/<span class="number">2</span><span class="number">-1</span>])/<span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>结果：二分查找&lt;插入排序&lt;暴力排序<br>2 大小堆方法<br>该方法利用两个堆，最小堆：堆内元素不小于最小值，最大堆：堆内元素不大于最大值，<br>而两个临界值和的一半就是中位值</p><h2 id="总结反思"><a href="#总结反思" class="headerlink" title="总结反思"></a>总结反思</h2><p>多使用二分查找</p>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
          <category> 41数据流中的中位数 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 插入排序 </tag>
            
            <tag> 二分查找 </tag>
            
            <tag> 大小堆 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer-40最小的k个数</title>
      <link href="/2020/07/18/%E5%89%91%E6%8C%87offer-40%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0/"/>
      <url>/2020/07/18/%E5%89%91%E6%8C%87offer-40%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>输入整数数组 arr ，找出其中最小的 k 个数。例如，输入4、5、1、6、2、7、3、8这8个数字，则最小的4个数字是1、2、3、4。<br>示例 1：<br>输入：arr = [3,2,1], k = 2<br>输出：[1,2] 或者 [2,1]<br>示例 2：<br>输入：arr = [0,1,2,1], k = 1<br>输出：[0]<br>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/zui-xiao-de-kge-shu-lcof" target="_blank" rel="noopener">https://leetcode-cn.com/problems/zui-xiao-de-kge-shu-lcof</a></p><h1 id="算法分析-代码实现"><a href="#算法分析-代码实现" class="headerlink" title="算法分析+代码实现"></a>算法分析+代码实现</h1><p>1 直接利用sort快排，两行代码解决<br>sort()方法：也是按照快排来的，故时间复杂度O(nlogn) 空间复杂度O(logn)<br>默认地，sort() 函数按照字符串顺序对值进行排序。<br>该函数很适合字符串（”Apple” 会排在 “Banana” 之前）。<br>不过，如果数字按照字符串来排序，则 “25” 大于 “100”，因为 “2” 大于 “1”。<br>正因如此，sort() 方法在对数值排序时会产生不正确的结果。<br>我们通过一个比值函数来修正此问题：<br>sort([compareFunction])<br>如果 compareFunction(a, b) 小于 0 ，那么 a 会被排列到 b 之前；<br>如果 compareFunction(a, b) 大于 0 ， b 会被排列到 a 之前。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> getLeastNumbers = <span class="function"><span class="keyword">function</span>(<span class="params">arr, k</span>) </span>&#123;</span><br><span class="line">    arr.sort(<span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>)</span>&#123;<span class="keyword">return</span> a - b&#125;)</span><br><span class="line">    <span class="keyword">return</span> arr.slice(<span class="number">0</span>,k)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>结果：</p><p>执行用时：140 ms, 在所有 JavaScript 提交中击败了36.39%的用户<br>内存消耗：42.7 MB, 在所有 JavaScript 提交中击败了100.00%的用户</p><p>2 利用快排思想，每次只需排序一部分，相对来说节省了时间<br>思想：分而治之<br>步骤：<br>1．先从数列中取出一个数作为基准数。<br>2．分区过程，将比这个数大的数全放到它的右边，小于或等于它的数全放到它的左边。<br>3．再对左右区间重复第二步，直到各区间只有一个数。<br>注：有好多种快排，有先从后往前找，再从前往后找的，也有一直从前往后，然后递归排序的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> getLeastNumbers = <span class="function"><span class="keyword">function</span>(<span class="params">arr, k</span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">quikSort</span>(<span class="params">arr, left, right</span>) </span>&#123;</span><br><span class="line">        <span class="comment">//将标签元素挖出来，比较结束后再把该元素填回去</span></span><br><span class="line">        <span class="keyword">let</span> pivot = arr[left]</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">while</span>(left &lt; right &amp;&amp; arr[right] &gt;= pivot) right--</span><br><span class="line">            arr[left] = arr[right]</span><br><span class="line">            <span class="keyword">while</span>(left &lt; right &amp;&amp; arr[left] &lt; pivot) left++</span><br><span class="line">            arr[right] = arr[left]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//比较全部结束之后，左指针指向了标签元素该去的位置，然后在该位置填入标签元素</span></span><br><span class="line">        arr[left] = pivot</span><br><span class="line">        <span class="keyword">return</span> left</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> len = arr.length</span><br><span class="line">    <span class="keyword">if</span> (!len || !k) <span class="keyword">return</span> []</span><br><span class="line">    <span class="keyword">let</span> start = <span class="number">0</span></span><br><span class="line">    <span class="keyword">let</span> end = len - <span class="number">1</span></span><br><span class="line">    <span class="comment">// 寻找一次标杆元素的位置</span></span><br><span class="line">    <span class="keyword">let</span> index = quikSort(arr, start, end)</span><br><span class="line">    <span class="comment">// 如果标杆元素的位置不等于 K</span></span><br><span class="line">    <span class="keyword">while</span>(index !== k - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (index &gt; k<span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果上一次查找，标杆元素位置大于目标位置</span></span><br><span class="line">            end = index<span class="number">-1</span></span><br><span class="line">            index = quikSort(arr, start, end)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果上一次查找，标杆元素位置小于目标位置</span></span><br><span class="line">            start = index + <span class="number">1</span></span><br><span class="line">            index = quikSort(arr, start, end)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr.slice(<span class="number">0</span>, index+<span class="number">1</span>)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>结果：<br>执行用时：116 ms, 在所有 JavaScript 提交中击败了76.49%的用户<br>内存消耗：41.1 MB, 在所有 JavaScript 提交中击败了100.00%的用户</p><h1 id="总结分析"><a href="#总结分析" class="headerlink" title="总结分析"></a>总结分析</h1><p>首先要明白快排<br>然后要可以手写快排算法<br>最好可以举一反三，利用快排思想进行优化</p>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
          <category> 40最小的k个数 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 快速排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer-39数组中出现次数超过一半的数字</title>
      <link href="/2020/07/18/%E5%89%91%E6%8C%87offer-39%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E8%B6%85%E8%BF%87%E4%B8%80%E5%8D%8A%E7%9A%84%E6%95%B0%E5%AD%97/"/>
      <url>/2020/07/18/%E5%89%91%E6%8C%87offer-39%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E8%B6%85%E8%BF%87%E4%B8%80%E5%8D%8A%E7%9A%84%E6%95%B0%E5%AD%97/</url>
      
        <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。<br>你可以假设数组是非空的，并且给定的数组总是存在多数元素。<br>示例 1:<br>输入: [1, 2, 3, 2, 2, 2, 5, 4, 2]<br>输出: 2<br>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/shu-zu-zhong-chu-xian-ci-shu-chao-guo-yi-ban-de-shu-zi-lcof" target="_blank" rel="noopener">https://leetcode-cn.com/problems/shu-zu-zhong-chu-xian-ci-shu-chao-guo-yi-ban-de-shu-zi-lcof</a></p><h1 id="算法分析-代码实现"><a href="#算法分析-代码实现" class="headerlink" title="算法分析+代码实现"></a>算法分析+代码实现</h1><p>1 考虑题目条件，出现次数大于数组长度的一半，那么当给数组排序后，新数组的中间的值，必定是题目所求的值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> majorityElement = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> num=nums.sort()</span><br><span class="line">    <span class="keyword">return</span> num[<span class="built_in">Math</span>.floor(num.length/<span class="number">2</span>)]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>结果：两行代码解决，但是会修改原数组，或者说使用了辅助数组，空间复杂度不为O（1）</p><p>执行用时：92 ms, 在所有 JavaScript 提交中击败了25.92%的用户<br>内存消耗：40.6 MB, 在所有 JavaScript 提交中击败了100.00%的用户</p><p>2 再优化一些：结合题目条件，利用投票算法，遍历一次，不修改数组本身的同时得到结果<br>投票算法:value保存当前值time记录该值出现的次数<br>遍历数组，当前值==value time++；<br>不相等的话 如果time==0，则将value更新为当前值，!=0则time–</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> majorityElement = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!nums)&#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> time=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> value</span><br><span class="line">    <span class="keyword">for</span>(item <span class="keyword">of</span> nums)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!time)&#123;</span><br><span class="line">            value=item</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(value==item)&#123;</span><br><span class="line">            time++</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            time--</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>结果：只需要遍历一般，不改变原数组<br>执行用时：76 ms, 在所有 JavaScript 提交中击败了77.03%的用户<br>内存消耗：39.7 MB, 在所有 JavaScript 提交中击败了100.00%的用户</p><h1 id="总结反思"><a href="#总结反思" class="headerlink" title="总结反思"></a>总结反思</h1><p>首先要把最简单的算法实现，然后要记住所谓的投票算法到底是什么</p>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
          <category> 39数组中出现次数超过一半的数字 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 投票算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer-38字符串的排列</title>
      <link href="/2020/07/18/%E5%89%91%E6%8C%87offer-38%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8E%92%E5%88%97/"/>
      <url>/2020/07/18/%E5%89%91%E6%8C%87offer-38%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8E%92%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>输入一个字符串，打印出该字符串中字符的所有排列。<br>你可以以任意顺序返回这个字符串数组，但里面不能有重复元素。<br>示例:<br>输入：s = “abc”<br>输出：[“abc”,”acb”,”bac”,”bca”,”cab”,”cba”]</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/zi-fu-chuan-de-pai-lie-lcof" target="_blank" rel="noopener">https://leetcode-cn.com/problems/zi-fu-chuan-de-pai-lie-lcof</a></p><h1 id="算法分析-代码实现"><a href="#算法分析-代码实现" class="headerlink" title="算法分析+代码实现"></a>算法分析+代码实现</h1><p>所有的排列组合，可以递归成：<br>首元素和它后面的元素交换位置<br>如果原字符串中有重复元素的话，记得考虑去重</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> permutation = <span class="function"><span class="keyword">function</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!s.length)&#123;</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> arr=[]</span><br><span class="line">    <span class="keyword">let</span> path=[];</span><br><span class="line">    <span class="keyword">let</span> dfs = <span class="function"><span class="keyword">function</span>(<span class="params">s,path</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.length==<span class="number">1</span>)&#123;</span><br><span class="line">            arr.push(path+s)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//开始循环，依次将原字符的每一个字符进行递归</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;s.length;i++)&#123;</span><br><span class="line">            path=path+s[i]</span><br><span class="line">            dfs(s.slice(<span class="number">0</span>,i)+s.slice(i+<span class="number">1</span>),path)</span><br><span class="line">            <span class="comment">//将最末尾的元素出栈，保证不会重复计算</span></span><br><span class="line">            path=path.slice(<span class="number">0</span>,<span class="number">-1</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(s,path)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//利用去重函数,如果字符串中有重复元素出现的，就要去重</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Array</span>.from(<span class="keyword">new</span> <span class="built_in">Set</span>(arr))</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>结果：<br>执行用时：152 ms, 在所有 JavaScript 提交中击败了73.12%的用户<br>内存消耗：49.3 MB, 在所有 JavaScript 提交中击败了100.00%的用户</p><h1 id="总结反思"><a href="#总结反思" class="headerlink" title="总结反思"></a>总结反思</h1><p>该问题，考察的主要是排列组合的问题，当明白了原理，再写代码的时候，就会简单许多</p>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
          <category> 38字符串的排列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
            <tag> 排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>webpack-开发环境配置</title>
      <link href="/2020/07/17/webpack-%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
      <url>/2020/07/17/webpack-%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<p>包括基础的资源打包，配置webpack-dev-server等<br>安装webpack命令行工具<br>npm webpack webpack-cli -D</p><h1 id="打包样式资源（即css，less，scss等）"><a href="#打包样式资源（即css，less，scss等）" class="headerlink" title="打包样式资源（即css，less，scss等）"></a>打包样式资源（即css，less，scss等）</h1><p>样式资源直接打包到js文件夹中</p><p>第一步：要配置webpack.config.js的loader配置<br>第二步：安装loader</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm css-loader style-loader  -D</span><br></pre></td></tr></table></figure><p>第三步：执行：<br>webpack （代替：webpack ./src/index.js -o ./build/built.js –mode=production )</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Hash: c324af4481f9d5502109</span><br><span class="line">Version: webpack <span class="number">4.43</span><span class="number">.0</span></span><br><span class="line">Time: <span class="number">1009</span>ms</span><br><span class="line">Built at: <span class="number">2020</span><span class="number">-07</span><span class="number">-16</span> <span class="number">11</span>:<span class="number">27</span>:<span class="number">08</span></span><br><span class="line">   Asset      Size  Chunks             Chunk Names</span><br><span class="line">built.js  <span class="number">16.3</span> KiB    main  [emitted]  main</span><br><span class="line">Entrypoint main = built.js</span><br><span class="line">[../node_modules/css-loader/dist/cjs.js!./src/index.css] <span class="number">320</span> bytes &#123;main&#125; [built]</span><br><span class="line">[./src/index.css] <span class="number">525</span> bytes &#123;main&#125; [built]</span><br><span class="line">[./src/index.js] <span class="number">21</span> bytes &#123;main&#125; [built]</span><br><span class="line">+ <span class="number">2</span> hidden modules</span><br></pre></td></tr></table></figure><p>第四步：尝试新增lessloader<br>首先要修改webpack-config-js的loader配置，每一个loaer配置只负责一种文件，不可复用，<br>然后安装新需要的loader 注意安装less-loader时，同时需要安装less</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i less less-loader -D</span><br></pre></td></tr></table></figure><p>之后执行webpack</p><h1 id="打包html"><a href="#打包html" class="headerlink" title="打包html"></a>打包html</h1><p>这里使用的是plugin插件html-webpack-plugin<br>第一步：安装html-webpack-plugin</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i html-webpack-plugin -D</span><br></pre></td></tr></table></figure><p>第二步：在webconfig.js中引入插件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const HtmlWebpackPlugin &#x3D; require(&#39;html-webpack-plugin&#39;)</span><br></pre></td></tr></table></figure><p>并更新plugins配置，plugins配置：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> HtmlWebpackPlugin()</span><br></pre></td></tr></table></figure><p>第三步：执行webpack命令</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Hash: <span class="number">197</span>ea2269065e134027b</span><br><span class="line">Version: webpack <span class="number">4.43</span><span class="number">.0</span></span><br><span class="line">Time: <span class="number">224</span>ms</span><br><span class="line">Built at: <span class="number">2020</span><span class="number">-07</span><span class="number">-17</span> <span class="number">9</span>:<span class="number">30</span>:<span class="number">09</span></span><br><span class="line">Asset       Size  Chunks             Chunk Names       </span><br><span class="line">built.js   <span class="number">3.83</span> KiB    main  [emitted]  main</span><br><span class="line">index.html  <span class="number">226</span> bytes          [emitted]</span><br><span class="line">Entrypoint main = built.js</span><br><span class="line">[./src/index.js] <span class="number">60</span> bytes &#123;main&#125; [built]</span><br><span class="line">Child HtmlWebpackCompiler:</span><br><span class="line"><span class="number">1</span> asset</span><br><span class="line">Entrypoint HtmlWebpackPlugin_0 = __child-HtmlWebpackPlugin_0</span><br><span class="line"><span class="number">1</span> <span class="built_in">module</span></span><br></pre></td></tr></table></figure><p>html-webpack-plugin功能：</p><ul><li><p>默认会创建一个空的HTML，自动引入打包输出的所有资源（JS/CSS）</p></li><li><p>需要有结构的HTML文件时：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> HtmlWebpackPlugin(&#123;<span class="attr">template</span>: <span class="string">'./src/index.html'</span> &#125;)</span><br><span class="line"><span class="comment">//复制 './src/index.html' 文件，并自动引入打包输出的所有资源（JS/CSS）</span></span><br></pre></td></tr></table></figure><h1 id="打包图片"><a href="#打包图片" class="headerlink" title="打包图片"></a>打包图片</h1><p>url-loader（css文件引入的外部图片）html-loader（html文件直接引入的图片）</p></li></ul><p>第一步：安装<br>npm i url-loader html-loader -D<br>第二步：配置loader<br>1 url-loader</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 处理图片资源</span></span><br><span class="line">test: <span class="regexp">/\.(jpg|png|gif)$/</span>,</span><br><span class="line"><span class="comment">// 使用一个loader,可以直接使用loader:loader名字</span></span><br><span class="line"><span class="comment">// 下载 url-loader file-loader</span></span><br><span class="line">loader: <span class="string">'url-loader'</span>,</span><br><span class="line"><span class="comment">//配置loader</span></span><br><span class="line">options: &#123;</span><br><span class="line"><span class="comment">// 图片大小小于8kb，就会被base64处理</span></span><br><span class="line"><span class="comment">// 优点: 减少请求数量（减轻服务器压力）</span></span><br><span class="line"><span class="comment">// 缺点：图片体积会更大（文件请求速度更慢）</span></span><br><span class="line">limit: <span class="number">8</span> * <span class="number">1024</span>,</span><br><span class="line"><span class="comment">// 给图片进行重命名</span></span><br><span class="line"><span class="comment">// [hash:10]取图片的hash的前10位</span></span><br><span class="line"><span class="comment">// [ext]取文件原来扩展名</span></span><br><span class="line">name: <span class="string">'[hash:10].[ext]'</span></span><br></pre></td></tr></table></figure><p>2 配置html-loader，同时记得配置html-webpack-plugin功能，因为需要引入原html文件的内容，才会有html内部文件的问题</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">test: <span class="regexp">/\.html$/</span>,</span><br><span class="line"><span class="comment">// 处理html文件的img图片（负责引入img，从而能被url-loader进行处理）</span></span><br><span class="line">loader: <span class="string">'html-loader'</span></span><br></pre></td></tr></table></figure><p>第三步：webpack执行</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Hash: <span class="number">1</span>d26b2af0672964230f9</span><br><span class="line">Version: webpack <span class="number">4.43</span><span class="number">.0</span></span><br><span class="line">Time: <span class="number">11993</span>ms</span><br><span class="line">Built at: <span class="number">2020</span><span class="number">-07</span><span class="number">-17</span> <span class="number">14</span>:<span class="number">29</span>:<span class="number">30</span></span><br><span class="line">Entrypoint main = built.js</span><br><span class="line">[../node_modules/css-loader/dist/cjs.js!../node_modules/less-loader/dist/cjs.js!./src/index.less] <span class="number">1.34</span> KiB &#123;main&#125; [built]</span><br><span class="line">[./src/angular.jpg] <span class="number">60</span> bytes &#123;main&#125; [built]</span><br><span class="line">[./src/index.js] <span class="number">22</span> bytes &#123;main&#125; [built]</span><br><span class="line">[./src/index.less] <span class="number">569</span> bytes &#123;main&#125; [built]</span><br><span class="line">[./src/react.png] <span class="number">60</span> bytes &#123;main&#125; [built]</span><br><span class="line">[./src/vue.jpg] <span class="number">5.44</span> KiB &#123;main&#125; [built]</span><br><span class="line"> + <span class="number">3</span> hidden modules</span><br><span class="line">Child HtmlWebpackCompiler:</span><br><span class="line"> Asset      Size  Chunks             Chunk Names</span><br><span class="line"><span class="number">830</span>bf3c820.jpg  <span class="number">12.7</span> KiB          [emitted]</span><br><span class="line">+ <span class="number">1</span> hidden asset</span><br><span class="line">Entrypoint HtmlWebpackPlugin_0 = __child-HtmlWebpackPlugin_0</span><br><span class="line">[../node_modules/html-webpack-plugin/lib/loader.js!./src/index.html] <span class="number">733</span> bytes &#123;HtmlWebpackPlugin_0&#125; [built]</span><br><span class="line">[./src/angular.jpg] <span class="number">60</span> bytes &#123;HtmlWebpackPlugin_0&#125; [built]</span><br><span class="line">+ <span class="number">1</span> hidden <span class="built_in">module</span></span><br></pre></td></tr></table></figure><h1 id="打包其他资源"><a href="#打包其他资源" class="headerlink" title="打包其他资源"></a>打包其他资源</h1><p>也就是不需要打包，直接输出的资源,字体，图标等<br>这里使用的是阿里的字体库，使用时记得将css文件引用的相关文件都拷贝到相关文件夹</p><p>工具安装：npm i file-loader -D<br>配置：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 排除css/js/html资源</span></span><br><span class="line">        exclude: <span class="regexp">/\.(css|js|html|less)$/</span>,</span><br><span class="line">        loader: <span class="string">'file-loader'</span>,</span><br><span class="line">        options: &#123;</span><br><span class="line">          name: <span class="string">'[hash:10].[ext]'</span></span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>执行结果：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Hash: <span class="number">249435</span>f5efc71be66701</span><br><span class="line">Version: webpack <span class="number">4.43</span><span class="number">.0</span></span><br><span class="line">Time: <span class="number">1520</span>ms</span><br><span class="line">Built at: <span class="number">2020</span><span class="number">-07</span><span class="number">-17</span> <span class="number">14</span>:<span class="number">46</span>:<span class="number">57</span></span><br><span class="line">          Asset       Size  Chunks             Chunk Names</span><br><span class="line"> <span class="number">1</span>c714375fa.svg   <span class="number">1.73</span> KiB          [emitted]  </span><br><span class="line"> <span class="number">6189950e0</span>e.ttf   <span class="number">2.09</span> KiB          [emitted]  </span><br><span class="line"> <span class="number">897</span>f4479e5.eot   <span class="number">2.25</span> KiB          [emitted]  </span><br><span class="line"><span class="number">955</span>d9a2215.woff   <span class="number">1.35</span> KiB          [emitted]  </span><br><span class="line">       built.js   <span class="number">23.1</span> KiB    main  [emitted]  main</span><br><span class="line">     index.html  <span class="number">433</span> bytes          [emitted]  </span><br><span class="line">Entrypoint main = built.js</span><br><span class="line">[../node_modules/css-loader/dist/cjs.js!./src/iconfont.css] <span class="number">3.31</span> KiB &#123;main&#125; [built]</span><br><span class="line">[./src/iconfont.css] <span class="number">528</span> bytes &#123;main&#125; [built]</span><br><span class="line">[./src/iconfont.eot?t=<span class="number">1581833245354</span>] <span class="number">58</span> bytes &#123;main&#125; [built]</span><br><span class="line">[./src/iconfont.svg?t=<span class="number">1581833245354</span>] <span class="number">58</span> bytes &#123;main&#125; [built]</span><br><span class="line">[./src/iconfont.ttf?t=<span class="number">1581833245354</span>] <span class="number">58</span> bytes &#123;main&#125; [built]</span><br><span class="line">[./src/iconfont.woff?t=<span class="number">1581833245354</span>] <span class="number">59</span> bytes &#123;main&#125; [built]</span><br><span class="line">[./src/index.js] <span class="number">59</span> bytes &#123;main&#125; [built]</span><br><span class="line">    + <span class="number">3</span> hidden modules</span><br><span class="line">Child HtmlWebpackCompiler:</span><br><span class="line">     <span class="number">1</span> asset</span><br><span class="line">    Entrypoint HtmlWebpackPlugin_0 = __child-HtmlWebpackPlugin_0</span><br><span class="line">    [../node_modules/html-webpack-plugin/lib/loader.js!./src/index.html] <span class="number">704</span> bytes &#123;HtmlWebpackPlugin_0&#125; [built]</span><br></pre></td></tr></table></figure><h1 id="devServer"><a href="#devServer" class="headerlink" title="devServer"></a>devServer</h1><p>解决源文件修改后无法直观显示的问题<br>开发服务器 devServer：用来自动化（自动编译，自动打开浏览器，自动刷新浏览器 等 ）特点：只会在内存中编译打包，不会有任何输出<br>/启动devServer指令为：npx webpack-dev-server</p><p>安装: npm i webpack-dev-server -D</p><p>配置：跟在mode之后</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">devServer: &#123;</span><br><span class="line">    <span class="comment">// 项目构建后路径</span></span><br><span class="line">    contentBase: resolve(__dirname, <span class="string">'build'</span>),</span><br><span class="line">    <span class="comment">// 启动gzip压缩</span></span><br><span class="line">    compress: <span class="literal">true</span>,</span><br><span class="line">    <span class="comment">// 端口号</span></span><br><span class="line">    port: <span class="number">3000</span>,</span><br><span class="line">    <span class="comment">// 自动打开浏览器</span></span><br><span class="line">    open: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">i ｢wds｣: Project is running at http:<span class="comment">//localhost:3000/</span></span><br><span class="line">i ｢wds｣: webpack output is served <span class="keyword">from</span> /</span><br><span class="line">i ｢wds｣: Content not <span class="keyword">from</span> webpack is served <span class="keyword">from</span> C:\Users\ASUS\Desktop\webpack资料\<span class="number">2.</span>webpack开发环境配置\<span class="number">07.</span>devServer\build</span><br><span class="line">i ｢wdm｣: wait until bundle finished: <span class="regexp">/</span></span><br><span class="line"><span class="regexp">i ｢wdm｣: Hash: c6bfb508dbd5217bb071</span></span><br><span class="line"><span class="regexp">Version: webpack 4.43.0</span></span><br><span class="line"><span class="regexp">Time: 3419ms</span></span><br><span class="line"><span class="regexp">Built at: 2020-07-17 15:05:01</span></span><br><span class="line"><span class="regexp">          Asset       Size  Chunks             Chunk Names</span></span><br><span class="line"><span class="regexp"> 1c714375fa.svg   1.73 KiB          [emitted]</span></span><br><span class="line"><span class="regexp"> 6189950e0e.ttf   2.09 KiB          [emitted]</span></span><br><span class="line"><span class="regexp"> 897f4479e5.eot   2.25 KiB          [emitted]</span></span><br><span class="line"><span class="regexp">955d9a2215.woff   1.35 KiB          [emitted]</span></span><br><span class="line"><span class="regexp">       built.js    382 KiB    main  [emitted]  main</span></span><br><span class="line"><span class="regexp">     index.html  497 bytes          [emitted]</span></span><br><span class="line"><span class="regexp">Entrypoint main = built.js</span></span><br><span class="line"><span class="regexp">[0] multi ../</span>node_modules/webpack-dev-server/client?http:<span class="comment">//localhost:3000 ./src/index.js 40 bytes &#123;main&#125; [built]</span></span><br><span class="line">[../node_modules/ansi-html/index.js] <span class="number">4.16</span> KiB &#123;main&#125; [built]</span><br><span class="line">[../node_modules/webpack-dev-server/client/utils/log.js] <span class="number">964</span> by1 KiB &#123;main&#125; [built]tes &#123;main&#125; [built]                                             built]</span><br><span class="line">[../node_modules/webpack-dev-server/client/utils/reloadApp.js] lhost:<span class="number">3000</span>] ../node_modules/webpack-dev-server/client?http:<span class="comment">//localhost:3000 4.29 KiB &#123;main&#125; [bu</span></span><br><span class="line"><span class="number">1.59</span> KiB &#123;main&#125; [built]</span><br><span class="line">[../node_modules/webpack-dev-server/client/utils/sendMessage.js &#123;main&#125; [built]] <span class="number">402</span> bytes &#123;main&#125; [built]                                     &#123;main&#125; [built]</span><br><span class="line">[../node_modules/webpack-dev-server/node_modules/strip-ansi/indl.js] <span class="number">2.91</span> KiB &#123;main&#125; [built]ex.js] <span class="number">161</span> bytes &#123;main&#125; [built]                                tes &#123;main&#125; [built]</span><br><span class="line">[../node_modules/webpack/hot sync ^\.\/log$] ../node_modules/we1<span class="number">.59</span> KiB &#123;main&#125; [built]bpack/hot sync nonrecursive ^\.\/log$ <span class="number">170</span> bytes &#123;main&#125; [built] ] <span class="number">402</span> bytes &#123;main&#125; [built]</span><br><span class="line">[./src/iconfont.css] <span class="number">528</span> bytes &#123;main&#125; [built]                  ex.js] <span class="number">161</span> bytes &#123;main&#125; [built]</span><br><span class="line">[./src/index.js] <span class="number">155</span> bytes &#123;main&#125; [built]                      bpack/hot sync nonrecursive ^\.\/log$ <span class="number">170</span> bytes &#123;main&#125; [built]</span><br><span class="line">    + <span class="number">27</span> hidden modules</span><br><span class="line">Child HtmlWebpackCompiler:</span><br><span class="line">     <span class="number">1</span> asset</span><br><span class="line">    Entrypoint HtmlWebpackPlugin_0 = __child-HtmlWebpackPlugin_0</span><br><span class="line">    [../node_modules/html-webpack-plugin/lib/loader.js!./src/in0dex.html] <span class="number">780</span> bytes &#123;HtmlWebpackPlugin_0&#125; [built]              dex.html] <span class="number">780</span> bytes &#123;HtmlWebpackPlugin_0&#125; [built]</span><br><span class="line">i ｢wdm｣: Compiled successfully.   </span><br><span class="line"></span><br><span class="line"><span class="comment">//当修改当前页面时，结果如下：</span></span><br><span class="line">i ｢wdm｣: Compiling...</span><br><span class="line">i ｢wdm｣: Hash: <span class="number">0</span>a8d4f16d3bbda7cd388</span><br><span class="line">Version: webpack <span class="number">4.43</span><span class="number">.0</span></span><br><span class="line">Time: <span class="number">72</span>ms</span><br><span class="line">Built at: <span class="number">2020</span><span class="number">-07</span><span class="number">-17</span> <span class="number">15</span>:<span class="number">05</span>:<span class="number">35</span></span><br><span class="line">     Asset       Size  Chunks             Chunk Names</span><br><span class="line">index.html  <span class="number">525</span> bytes          [emitted]</span><br><span class="line"> + <span class="number">5</span> hidden assets</span><br><span class="line">Entrypoint main = built.js</span><br><span class="line">   <span class="number">42</span> modules</span><br><span class="line">Child HtmlWebpackCompiler:</span><br><span class="line">     <span class="number">1</span> asset</span><br><span class="line">    Entrypoint HtmlWebpackPlugin_0 = __child-HtmlWebpackPlugin_0</span><br><span class="line">    [../node_modules/html-webpack-plugin/lib/loader.js!./src/index.html] <span class="number">810</span> bytes &#123;HtmlWebpackPlugin_0&#125; [built]</span><br><span class="line">i ｢wdm｣: Compiled successfully.</span><br></pre></td></tr></table></figure><h1 id="综合以上内容，配置生产环境"><a href="#综合以上内容，配置生产环境" class="headerlink" title="综合以上内容，配置生产环境"></a>综合以上内容，配置生产环境</h1><p>将以上内容综合到一个webpack.config.js中</p><p>文件样式如下：<br>由于文件开发时会有多个文件夹，所以配置环境变量时添加outputpath设置<br>将打包后生成的文件放入对应文件夹中</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  开发环境配置：能让代码运行</span></span><br><span class="line"><span class="comment">    运行项目指令：</span></span><br><span class="line"><span class="comment">      webpack 会将打包结果输出出去</span></span><br><span class="line"><span class="comment">      npx webpack-dev-server 只会在内存中编译打包，没有输出</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123; resolve &#125; = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">'html-webpack-plugin'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: <span class="string">'./src/js/index.js'</span>,</span><br><span class="line">  output: &#123;</span><br><span class="line">  <span class="comment">//打包后js文件的存储路径和文件名</span></span><br><span class="line">    filename: <span class="string">'js/built.js'</span>,</span><br><span class="line">    <span class="comment">//打包后的根目录</span></span><br><span class="line">    path: resolve(__dirname, <span class="string">'build'</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      <span class="comment">// loader的配置</span></span><br><span class="line">      <span class="comment">//css等样式资源文件打包后会直接写入js文件中，不需要考虑存储路径</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="comment">// 处理less资源</span></span><br><span class="line">        test: <span class="regexp">/\.less$/</span>,</span><br><span class="line">        use: [<span class="string">'style-loader'</span>, <span class="string">'css-loader'</span>, <span class="string">'less-loader'</span>]</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="comment">// 处理css资源</span></span><br><span class="line">        test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">        use: [<span class="string">'style-loader'</span>, <span class="string">'css-loader'</span>]</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="comment">// 处理图片资源</span></span><br><span class="line">        test: <span class="regexp">/\.(jpg|png|gif)$/</span>,</span><br><span class="line">        loader: <span class="string">'url-loader'</span>,</span><br><span class="line">        options: &#123;</span><br><span class="line">          limit: <span class="number">8</span> * <span class="number">1024</span>,</span><br><span class="line">          name: <span class="string">'[hash:10].[ext]'</span>,</span><br><span class="line">          <span class="comment">//将该文件放入imgs文件夹中</span></span><br><span class="line">          outputPath: <span class="string">'imgs'</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="comment">// 处理html中img资源</span></span><br><span class="line">        <span class="comment">//该图片直接生成对应代码，插入htm文件中，不需要考虑该文件的存储</span></span><br><span class="line">        test: <span class="regexp">/\.html$/</span>,</span><br><span class="line">        loader: <span class="string">'html-loader'</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="comment">// 处理其他资源</span></span><br><span class="line">        exclude: <span class="regexp">/\.(html|js|css|less|jpg|png|gif)/</span>,</span><br><span class="line">        loader: <span class="string">'file-loader'</span>,</span><br><span class="line">        options: &#123;</span><br><span class="line">          name: <span class="string">'[hash:10].[ext]'</span>,</span><br><span class="line">          <span class="comment">//将其他资源放入media文件夹中</span></span><br><span class="line">          outputPath: <span class="string">'media'</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="comment">// plugins的配置</span></span><br><span class="line">    <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">      template: <span class="string">'./src/index.html'</span></span><br><span class="line">    &#125;)</span><br><span class="line">  ],</span><br><span class="line">  mode: <span class="string">'development'</span>,</span><br><span class="line">  devServer: &#123;</span><br><span class="line">    contentBase: resolve(__dirname, <span class="string">'build'</span>),</span><br><span class="line">    compress: <span class="literal">true</span>,</span><br><span class="line">    port: <span class="number">3000</span>,</span><br><span class="line">    open: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> webpack </category>
          
          <category> 开发环境配置 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 资源打包 </tag>
            
            <tag> web-dev-server </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer-37序列化二叉树</title>
      <link href="/2020/07/17/%E5%89%91%E6%8C%87offer-37%E5%BA%8F%E5%88%97%E5%8C%96%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
      <url>/2020/07/17/%E5%89%91%E6%8C%87offer-37%E5%BA%8F%E5%88%97%E5%8C%96%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>请实现两个函数，分别用来序列化和反序列化二叉树。</p><p>示例: </p><p>你可以将以下二叉树：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  1</span><br><span class="line"> &#x2F; \</span><br><span class="line">2   3</span><br><span class="line">   &#x2F; \</span><br><span class="line">  4   5</span><br></pre></td></tr></table></figure><p>序列化为 “[1,2,3,null,null,4,5]”</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/xu-lie-hua-er-cha-shu-lcof" target="_blank" rel="noopener">https://leetcode-cn.com/problems/xu-lie-hua-er-cha-shu-lcof</a></p><h1 id="算法分析-代码实现"><a href="#算法分析-代码实现" class="headerlink" title="算法分析+代码实现"></a>算法分析+代码实现</h1><p>序列化函数：利用队列，注意空结点也要输出，值为null</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> serialize = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root)&#123;</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> stack =[]</span><br><span class="line">    <span class="keyword">let</span> queue = [root]</span><br><span class="line">    <span class="keyword">while</span>(queue.length)&#123;</span><br><span class="line">        <span class="comment">//当前结点出队</span></span><br><span class="line">        node=queue.shift()</span><br><span class="line">        <span class="keyword">if</span>(!node)&#123;</span><br><span class="line">            stack.push(<span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            stack.push(node.val)</span><br><span class="line">            queue.push(node.left)</span><br><span class="line">            queue.push(node.right)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> stack</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>反序列化函数，利用队列，和指针i，队列存储当前根节点，指针i指向当前根结点的子节点</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> deserialize = <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!data.length)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> root=<span class="keyword">new</span> TreeNode(data[<span class="number">0</span>])</span><br><span class="line">    <span class="keyword">let</span> i=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">let</span> queue=[root]</span><br><span class="line">    <span class="keyword">while</span>(queue.length&amp;&amp;i&lt;data.length)&#123;</span><br><span class="line">       <span class="comment">//当前根节点</span></span><br><span class="line">       <span class="keyword">let</span>  curRoot=queue.shift()</span><br><span class="line">        <span class="keyword">if</span>(!curRoot)&#123;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//先加一个左节点</span></span><br><span class="line">        <span class="keyword">if</span>(data[i]!=<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">let</span> cur = <span class="keyword">new</span> TreeNode(data[i])</span><br><span class="line">            curRoot.left = cur;</span><br><span class="line">            queue.push(cur)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            curRoot.left=<span class="literal">null</span></span><br><span class="line">            queue.push(<span class="literal">null</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        i++</span><br><span class="line">        <span class="comment">//再加一个右节点</span></span><br><span class="line">        <span class="keyword">if</span>(data[i]!=<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">let</span> cur =<span class="keyword">new</span> TreeNode(data[i])</span><br><span class="line">            curRoot.right = cur</span><br><span class="line">            queue.push(cur)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            curRoot.right = <span class="literal">null</span></span><br><span class="line">            queue.push(<span class="literal">null</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        i++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>结果：<br>执行用时：148 ms, 在所有 JavaScript 提交中击败了42.61%的用户<br>内存消耗：48.1 MB, 在所有 JavaScript 提交中击败了100.00%的用户</p><h1 id="总结反思"><a href="#总结反思" class="headerlink" title="总结反思"></a>总结反思</h1><p>该题目主要考察的是队列，注意空结点值仍需要存储</p>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
          <category> 37序列化二叉树 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 队列 </tag>
            
            <tag> 序列化二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer-36二叉搜索树和双向链表</title>
      <link href="/2020/07/17/%E5%89%91%E6%8C%87offer-36%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E5%92%8C%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/"/>
      <url>/2020/07/17/%E5%89%91%E6%8C%87offer-36%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E5%92%8C%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的循环双向链表。要求不能创建任何新的节点，只能调整树中节点指针的指向。<br>特别地，我们希望可以就地完成转换操作。当转化完成以后，树中节点的左指针需要指向前驱，树中节点的右指针需要指向后继。还需要返回链表中的第一个节点的指针。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-yu-shuang-xiang-lian-biao-lcof" target="_blank" rel="noopener">https://leetcode-cn.com/problems/er-cha-sou-suo-shu-yu-shuang-xiang-lian-biao-lcof</a></p><h1 id="算法分析-代码实现"><a href="#算法分析-代码实现" class="headerlink" title="算法分析+代码实现"></a>算法分析+代码实现</h1><p>1 简单思路，将该树所有结点按中序遍历递归入栈，然后操作栈中元素，修改栈中元素的左右结点，注意首尾结点要连接成环</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> treeToDoublyList = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root)&#123;</span><br><span class="line">        <span class="keyword">return</span> root</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> stack = [];</span><br><span class="line">    <span class="keyword">let</span> dfs = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)&#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        dfs(root.left)</span><br><span class="line">        stack.push(root)</span><br><span class="line">        dfs(root.right)</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(root)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i =<span class="number">0</span>;i&lt;stack.length<span class="number">-1</span>;i++)&#123;</span><br><span class="line">        stack[i].right=stack[i+<span class="number">1</span>]</span><br><span class="line">        stack[i+<span class="number">1</span>].left = stack[i]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//更新首尾结点</span></span><br><span class="line">    stack[<span class="number">0</span>].left=stack[stack.length<span class="number">-1</span>]</span><br><span class="line">    stack[stack.length<span class="number">-1</span>].right = stack[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">return</span> stack[<span class="number">0</span>]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>结果:递归一次，遍历一次</p><p>执行用时：92 ms, 在所有 JavaScript 提交中击败了8.95%的用户</p><p>内存消耗：40 MB, 在所有 JavaScript 提交中击败了100.00%的用户</p><p>2 不用栈，直接在递归过程中修改代码，需要双指针，头指针和工作指针</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> treeToDoublyList = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root)&#123;</span><br><span class="line">        <span class="keyword">return</span> root</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> pre=head=<span class="literal">null</span></span><br><span class="line">    <span class="keyword">let</span> dfs = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)&#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//找左子节点</span></span><br><span class="line">        dfs(root.left)</span><br><span class="line">        <span class="comment">//当前结点为最左子节点，更新head和pre两个指针</span></span><br><span class="line">        <span class="keyword">if</span>(!pre)&#123;</span><br><span class="line">            head = root;</span><br><span class="line">            pre = root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//pre指针保存的当前节点的左子节点，更新当前结点和左子节点的关系，pre更新为当前结点</span></span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            pre.right = root;</span><br><span class="line">            root.left=pre;</span><br><span class="line">            pre = root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//遍历右子节点</span></span><br><span class="line">        dfs(root.right)</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(root)</span><br><span class="line">    <span class="comment">//递归结束以后形成新的链表，跟新头尾，生成循环链表</span></span><br><span class="line">    head.left=pre;</span><br><span class="line">    pre.right=head;</span><br><span class="line">    <span class="keyword">return</span> head</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>结果：<br>执行用时：92 ms, 在所有 JavaScript 提交中击败了8.95%的用户<br>内存消耗：39.8 MB, 在所有 JavaScript 提交中击败了100.00%的用户</p><h2 id="总结反思"><a href="#总结反思" class="headerlink" title="总结反思"></a>总结反思</h2><p>首先要明白二叉搜索树的定义，然后了解中序遍历<br>结合双指针或者数据栈把算法实现</p>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
          <category> 36二叉搜索树和双向链表 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 递归 </tag>
            
            <tag> 双指针 </tag>
            
            <tag> 二叉搜索树 </tag>
            
            <tag> 双向链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer-35复杂链表的复制</title>
      <link href="/2020/07/16/%E5%89%91%E6%8C%87offer-35%E5%A4%8D%E6%9D%82%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%8D%E5%88%B6/"/>
      <url>/2020/07/16/%E5%89%91%E6%8C%87offer-35%E5%A4%8D%E6%9D%82%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%8D%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>请实现 copyRandomList 函数，复制一个复杂链表。在复杂链表中，每个节点除了有一个 next 指针指向下一个节点，还有一个 random 指针指向链表中的任意节点或者 null。<br>示例 1：<br><img src="/images/%E5%89%91%E6%8C%87-35/e1.png" alt="img"><br>输入：head = [[7,null],[13,0],[11,4],[10,2],[1,0]]<br>输出：[[7,null],[13,0],[11,4],[10,2],[1,0]]<br>示例 2：<br><img src="/images/%E5%89%91%E6%8C%87-35/e2.png" alt="img"><br>输入：head = [[1,1],[2,1]]<br>输出：[[1,1],[2,1]]<br>示例 3：<br><img src="/images/%E5%89%91%E6%8C%87-35/e3.png" alt="img"><br>输入：head = [[3,null],[3,0],[3,null]]<br>输出：[[3,null],[3,0],[3,null]]<br>示例 4：<br>输入：head = []<br>输出：[]<br>解释：给定的链表为空（空指针），因此返回 null。<br>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/fu-za-lian-biao-de-fu-zhi-lcof" target="_blank" rel="noopener">https://leetcode-cn.com/problems/fu-za-lian-biao-de-fu-zhi-lcof</a></p><h1 id="算法分析-代码实现"><a href="#算法分析-代码实现" class="headerlink" title="算法分析+代码实现"></a>算法分析+代码实现</h1><p>算法思路：<br>第一步复制当前节点和next结点<br>第二步更新新节点的random的值<br>第三步拆分所得链表，得到新链表</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> copyRandomList = <span class="function"><span class="keyword">function</span>(<span class="params">head</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">null</span>) &#123;</span><br><span class="line">         <span class="keyword">return</span> head;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">//将拷贝节点放到原节点后面，例如1-&gt;2-&gt;3这样的链表就变成了这样1-&gt;1'-&gt;2'-&gt;3-&gt;3'</span></span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">let</span> node = head, copy = <span class="literal">null</span>; node != <span class="literal">null</span>; node = node.next.next) &#123;</span><br><span class="line">         copy = <span class="keyword">new</span> Node(node.val);</span><br><span class="line">         copy.next = node.next;</span><br><span class="line">         node.next = copy;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">//把拷贝节点的random指针安排上</span></span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">let</span> node = head; node != <span class="literal">null</span>; node = node.next.next) &#123;</span><br><span class="line">         <span class="keyword">if</span> (node.random != <span class="literal">null</span>) &#123;</span><br><span class="line">             node.next.random = node.random.next;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">//分离拷贝节点和原节点，变成1-&gt;2-&gt;3和1'-&gt;2'-&gt;3'两个链表，后者就是答案</span></span><br><span class="line">     <span class="keyword">let</span> newHead = head.next;</span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">let</span> node = head, temp = <span class="literal">null</span>; node != <span class="literal">null</span> &amp;&amp; node.next != <span class="literal">null</span>;) &#123;</span><br><span class="line">         temp = node.next;</span><br><span class="line">         node.next = temp.next;</span><br><span class="line">         node = temp;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">return</span> newHead;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>结果：<br>执行用时：92 ms, 在所有 JavaScript 提交中击败了8.99%的用户<br>内存消耗：39.9 MB, 在所有 JavaScript 提交中击败了100.00%的用户</p><h1 id="总结反思"><a href="#总结反思" class="headerlink" title="总结反思"></a>总结反思</h1><p>该问题考察的主要是深拷贝，其次就是复杂问题简单化</p>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
          <category> 35复杂链表的复制 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表 </tag>
            
            <tag> 深拷贝 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer-34二叉树中和为某一值的路径</title>
      <link href="/2020/07/16/%E5%89%91%E6%8C%87offer-34%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%92%8C%E4%B8%BA%E6%9F%90%E4%B8%80%E5%80%BC%E7%9A%84%E8%B7%AF%E5%BE%84/"/>
      <url>/2020/07/16/%E5%89%91%E6%8C%87offer-34%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%92%8C%E4%B8%BA%E6%9F%90%E4%B8%80%E5%80%BC%E7%9A%84%E8%B7%AF%E5%BE%84/</url>
      
        <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>输入一棵二叉树和一个整数，打印出二叉树中节点值的和为输入整数的所有路径。从树的根节点开始往下一直到叶节点所经过的节点形成一条路径。</p><p>示例:<br>给定如下二叉树，以及目标和 sum = 22，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">  5</span><br><span class="line">   &#x2F;     \</span><br><span class="line">  4       8</span><br><span class="line"> &#x2F;       &#x2F; \</span><br><span class="line">11      13  4</span><br><span class="line">&#x2F;  \       &#x2F; \</span><br><span class="line">7   2     5   1</span><br></pre></td></tr></table></figure><p>返回:<br>[<br>[5,4,11,2],<br>[5,8,4,5]<br>]<br>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/er-cha-shu-zhong-he-wei-mou-yi-zhi-de-lu-jing-lcof" target="_blank" rel="noopener">https://leetcode-cn.com/problems/er-cha-shu-zhong-he-wei-mou-yi-zhi-de-lu-jing-lcof</a></p><h1 id="算法分析-代码实现"><a href="#算法分析-代码实现" class="headerlink" title="算法分析+代码实现"></a>算法分析+代码实现</h1><p>正常思路：递归算法实现</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> pathSum = <span class="function"><span class="keyword">function</span>(<span class="params">root, sum</span>) </span>&#123;</span><br><span class="line"><span class="comment">//如果是空数组的，直接返回[]</span></span><br><span class="line">    <span class="keyword">if</span>(!root)&#123;</span><br><span class="line">        <span class="keyword">return</span> [];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> arr=[]</span><br><span class="line">    <span class="comment">//arr存放相关路径</span></span><br><span class="line">    <span class="keyword">var</span> dfs=<span class="function"><span class="keyword">function</span>(<span class="params">root,sum,path</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)&#123;<span class="keyword">return</span>&#125;</span><br><span class="line">        path.push(root.val)</span><br><span class="line">        <span class="keyword">if</span>(sum===root.val&amp;&amp;!root.left&amp;&amp;!root.right)&#123;</span><br><span class="line">        <span class="comment">//注意这里使用的是深拷贝</span></span><br><span class="line">        <span class="comment">//js中数组是引用类型，浅拷贝的是path数组的地址，当path数组内容改变时，该数组相应的也会发生变化</span></span><br><span class="line">        <span class="comment">//这里为什么可以定义arr呢?js支持闭包</span></span><br><span class="line">            arr.push([...path])</span><br><span class="line">            path.pop()</span><br><span class="line">            <span class="keyword">return</span> </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(sum!=root.val&amp;&amp;!root.left&amp;&amp;!root.right)&#123;</span><br><span class="line">            path.pop()</span><br><span class="line">            <span class="keyword">return</span> </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root.left)&#123;</span><br><span class="line">            dfs(root.left,sum-root.val,path)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root.right)&#123;</span><br><span class="line">            dfs(root.right,sum-root.val,path)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//执行一次以后将该元素出栈 </span></span><br><span class="line">        path.pop()</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(root,sum,[])</span><br><span class="line">    <span class="keyword">return</span> arr</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>结果：<br>执行用时：84 ms, 在所有 JavaScript 提交中击败了84.42%的用户<br>内存消耗：37.8 MB, 在所有 JavaScript 提交中击败了100.00%的用户</p><h1 id="总结反思"><a href="#总结反思" class="headerlink" title="总结反思"></a>总结反思</h1><p>普通的递归，要注意js的引用变量特性和闭包特性</p>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
          <category> 34二叉树中和为某一值的路径 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树 </tag>
            
            <tag> 递归 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>webpack-入门</title>
      <link href="/2020/07/16/webpack-%E5%85%A5%E9%97%A8/"/>
      <url>/2020/07/16/webpack-%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="WebPack到底是什么？"><a href="#WebPack到底是什么？" class="headerlink" title="WebPack到底是什么？"></a>WebPack到底是什么？</h1><p>本质上，webpack 是一个现代 JavaScript 应用程序的静态模块打包器(module bundler)。当 webpack 处理应用程序时，它会递归地构建一个依赖关系图(dependency graph)，其中包含应用程序需要的每个模块，然后将所有这些模块打包成一个或多个 bundle。</p><p>当我们写网站时，会用一些less，sass等预处理语言，直接引入index.html时，浏览器无法编译运行，此时需要一些小工具将less，sass等文件转换为css文件，相关效果才能显示出来；<br>换一个情况，当我们使用es6，es7，es8甚至更高版本的语法编译js文件时，浏览器它翻译不了，或者说是不支持新版语法，因为并不是所有pc都会更新最新版的浏览器，此时我们需要一种工具，将写好的js代码转换成旧版语法的js代码。<br>还有，使用一些字体库，图标库什么的，也需要另一种工具。<br>所谓webpack就是将这些工具综合起来，将那些文件，也就是模块，静态模块，给翻译成浏览器可以理解，编译的内容，这一过程就叫做打包，生成的新的文件就叫做静态资源（bundle）</p><h1 id="几个核心概念"><a href="#几个核心概念" class="headerlink" title="几个核心概念"></a>几个核心概念</h1><p>1 入口Entry<br>入口起点(entry point)指示 webpack 应该使用哪个模块，来作为构建其内部依赖图的开始。进入入口起点后，webpack 会找出有哪些模块和库是入口起点（直接和间接）依赖的。</p><p>2 出口output<br>output 属性告诉 webpack 在哪里输出它所创建的 bundles，以及如何命名这些文件，默认值为 ./dist。基本上，整个应用程序结构，都会被编译到你指定的输出路径的文件夹中。</p><p>3 loader<br>loader 让 webpack 能够去处理那些非 JavaScript 文件（webpack 自身只理解 JavaScript）。loader 可以将所有类型的文件转换为 webpack 能够处理的有效模块，然后你就可以利用 webpack 的打包能力，对它们进行处理。<br>本质上，webpack loader 将所有类型的文件，转换为应用程序的依赖图（和最终的 bundle）可以直接引用的模块。</p><p>4 插件plugins<br>loader 被用于转换某些类型的模块，而插件则可以用于执行范围更广的任务。插件的范围包括，从打包优化和压缩，一直到重新定义环境中的变量。插件接口功能极其强大，可以用来处理各种各样的任务。</p><p>5 模式（mode）<br>通过选择 development 或 production 之中的一个，来设置 mode 参数，你可以启用相应模式下的 webpack 内置的优化</p><h1 id="webpack初体验"><a href="#webpack初体验" class="headerlink" title="webpack初体验"></a>webpack初体验</h1><p>1 首先利用npm初始化环境<br>    npm init<br>2 利用npm安装webpack-cil包，可以通过指令来使用webpack,-g全局安装<br>    npm i webpack webpack-cli -g<br>3 安装开发依赖<br>    npm i webpack webpack-cli -D<br>4 准备工作结束，开始写代码<br>新建两个文件夹，src文件夹，存放初始模块；build：存放打包后的模块<br>src中新建入口文件index.js 该文件是webpack默认的入口起点文件<br>运行指令：<br>开发环境：webpack ./src/index.js -o ./build/built.js –mode=development<br>webpack会以 ./src/index.js 为入口文件开始打包，打包后输出到 ./build/built.js<br>整体打包环境，是开发环境<br>PS C:\Users\ASUS\Desktop\webpack资料\1.webpack基本使用\webpack初体验&gt; webpack ./src/index.js -o ./build/built.js –mode=development<br>输出</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;Hash: d38f6fb5b3d3a4001133</span><br><span class="line">Version: webpack <span class="number">4.43</span><span class="number">.0</span></span><br><span class="line">Time: <span class="number">169</span>ms</span><br><span class="line">Built at: <span class="number">2020</span><span class="number">-07</span><span class="number">-16</span> <span class="number">10</span>:<span class="number">14</span>:<span class="number">47</span></span><br><span class="line">Asset      Size  Chunks             Chunk Names</span><br><span class="line">built.js  <span class="number">4.63</span> KiB    main  [emitted]  main</span><br><span class="line">Entrypoint main = built.js</span><br><span class="line">[./src/index.js] <span class="number">842</span> bytes &#123;main&#125; [built]</span><br></pre></td></tr></table></figure><p>生产环境：webpack ./src/index.js -o ./build/built.js –mode=production<br>webpack会以 ./src/index.js 为入口文件开始打包，打包后输出到 ./build/built.js<br>整体打包环境，是生产环境<br>PS C:\Users\ASUS\Desktop\webpack资料\1.webpack基本使用\webpack初体验&gt; webpack ./src/index.js -o ./build/built.js –mode=production<br>输出：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Hash: <span class="number">47</span>d3fd5e30dd54db54e3</span><br><span class="line">Version: webpack <span class="number">4.43</span><span class="number">.0</span></span><br><span class="line">Time: <span class="number">648</span>ms</span><br><span class="line">Built at: <span class="number">2020</span><span class="number">-07</span><span class="number">-16</span> <span class="number">10</span>:<span class="number">17</span>:<span class="number">37</span></span><br><span class="line">   Asset       Size  Chunks             Chunk Names</span><br><span class="line">built.js  <span class="number">973</span> bytes       <span class="number">0</span>  [emitted]  main</span><br><span class="line">Entrypoint main = built.js</span><br><span class="line">[<span class="number">0</span>] ./src/index.js <span class="number">1.22</span> KiB &#123;<span class="number">0</span>&#125; [built]</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>webpack能处理js/json资源，不能处理css/img等其他资源<br>生产环境和开发环境将ES6模块化编译成浏览器能识别的模块化~<br>生产环境比开发环境多一个压缩js代码。</p>]]></content>
      
      
      <categories>
          
          <category> webpack </category>
          
          <category> 入门 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> webpack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer-33二叉搜索树的后续遍历序列</title>
      <link href="/2020/07/15/%E5%89%91%E6%8C%87offer-33%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%90%8E%E7%BB%AD%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97/"/>
      <url>/2020/07/15/%E5%89%91%E6%8C%87offer-33%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%90%8E%E7%BB%AD%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h1 id="题目描述（中等）"><a href="#题目描述（中等）" class="headerlink" title="题目描述（中等）"></a>题目描述（中等）</h1><p>输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历结果。如果是则返回 true，否则返回 false。假设输入的数组的任意两个数字都互不相同。</p><p>参考以下这颗二叉搜索树：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> 5</span><br><span class="line">   &#x2F; \</span><br><span class="line">  2   6</span><br><span class="line"> &#x2F; \</span><br><span class="line">1   3</span><br></pre></td></tr></table></figure><p>示例 1：<br>输入: [1,6,3,2,5]<br>输出: false<br>示例 2：<br>输入: [1,3,2,6,5]<br>输出: true<br>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof" target="_blank" rel="noopener">https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof</a></p><h1 id="算法分析-代码实现"><a href="#算法分析-代码实现" class="headerlink" title="算法分析+代码实现"></a>算法分析+代码实现</h1><p>二叉搜索树：以根节点为标准，左子节点比根节点大；右子节点比根节点小<br>循环遍历，简单做法<br>将根节点出栈<br>然后根据根节点将原数组分为左右两个子节点数组<br>如果右节点数组的值存在小于根节点的值，则false<br>否则递归两个子数组，取二者返回值的与</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> verifyPostorder = <span class="function"><span class="keyword">function</span>(<span class="params">postorder</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(postorder.length&lt;<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//左子树的值</span></span><br><span class="line">    <span class="keyword">let</span> left =[];</span><br><span class="line">    <span class="comment">//右子树的值</span></span><br><span class="line">    <span class="keyword">let</span> right = [];</span><br><span class="line">    <span class="keyword">let</span> root = postorder.pop()</span><br><span class="line">    <span class="keyword">for</span>(i <span class="keyword">in</span> postorder)&#123;   </span><br><span class="line">        <span class="keyword">if</span>(postorder[i]&lt;root)&#123;</span><br><span class="line">            left.push(postorder[i])</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            right = postorder.slice(i);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//从0~i左子节点 i+1~postorder.length-1右子节点</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> item <span class="keyword">in</span> right)&#123;</span><br><span class="line">        <span class="keyword">if</span>(right[item]&lt;root)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> verifyPostorder(left)&amp;&amp;verifyPostorder(right)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
          <category> 33二叉搜索树的后续遍历序列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后序遍历 </tag>
            
            <tag> 二叉搜索树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer-32从上到下打印二叉树</title>
      <link href="/2020/07/15/%E5%89%91%E6%8C%87offer-32%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
      <url>/2020/07/15/%E5%89%91%E6%8C%87offer-32%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>从上到下打印出二叉树的每个节点，同一层的节点按照从左到右的顺序打印。</p><blockquote><p>例如:<br>给定二叉树: [3,9,20,null,null,15,7],<br>    3<br>   / <br>  9  20<br>    /  <br>   15   7<br>返回：<br>[3,9,20,15,7]<br>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-lcof" target="_blank" rel="noopener">https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-lcof</a></p></blockquote><p>2 :从上到下按层打印二叉树，同一层的节点按从左到右的顺序打印，每一层打印到一行。</p><blockquote><p>例如:<br>给定二叉树: [3,9,20,null,null,15,7],<br>    3<br>   / <br>  9  20<br>    /  <br>   15   7<br>返回其层次遍历结果：<br>[<br>  [3],<br>  [9,20],<br>  [15,7]<br>]<br>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-ii-lcof" target="_blank" rel="noopener">https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-ii-lcof</a></p></blockquote><h1 id="算法分析-代码实现"><a href="#算法分析-代码实现" class="headerlink" title="算法分析+代码实现"></a>算法分析+代码实现</h1><p>1 利用队列，按顺序存储节点<br>主要思路：<br>当前节点出队时，将当前节点的左右子节点入队<br>js中队列和栈都是通过数组自带的方法实现的：<br>入队：push（）<br>出队：shift（）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> levelOrder = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line"><span class="comment">//空树返回空，由于判断条件和队列长度有关，所以无法判断根节点为空的情况</span></span><br><span class="line"><span class="comment">//需要再加一次判断</span></span><br><span class="line"><span class="keyword">if</span>(!root)&#123;</span><br><span class="line">    <span class="keyword">return</span> [];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> NodeQueue = [];</span><br><span class="line"><span class="keyword">let</span> NodeQueueVal=[];</span><br><span class="line"></span><br><span class="line">NodeQueue.push(root)</span><br><span class="line"><span class="comment">//节点队列不为空,执行出入队列算法</span></span><br><span class="line"><span class="keyword">while</span>(NodeQueue.length)&#123;</span><br><span class="line"><span class="comment">//保存出队节点</span></span><br><span class="line">    <span class="keyword">let</span> curNode = NodeQueue.shift()</span><br><span class="line">    <span class="comment">//将出队节点的值保存至辅助数组中</span></span><br><span class="line">    <span class="keyword">if</span>(curNode)&#123;</span><br><span class="line">        NodeQueueVal.push(curNode.val)</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//出队节点左右节点不为空，将左右节点入队</span></span><br><span class="line">    <span class="keyword">if</span>(curNode.left)&#123;</span><br><span class="line">        NodeQueue.push(curNode.left);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(curNode.right)&#123;</span><br><span class="line">        NodeQueue.push(curNode.right);</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> NodeQueueVal</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>结果：<br>执行用时：68 ms, 在所有 JavaScript 提交中击败了85.68%的用户<br>内存消耗：36.9 MB, 在所有 JavaScript 提交中击败了100.00%的用户</p><p>2 基本思路不变，但是队列存储的是当前层的所有节点值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> levelOrder = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line"><span class="comment">//空树返回空</span></span><br><span class="line"><span class="keyword">if</span>(!root)&#123;</span><br><span class="line">    <span class="keyword">return</span> [];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> NodeQueue = [root];</span><br><span class="line"><span class="keyword">let</span> NodeQueueVal=[];</span><br><span class="line">   </span><br><span class="line"><span class="comment">//节点队列不为空</span></span><br><span class="line"><span class="keyword">while</span>(NodeQueue.length)&#123;</span><br><span class="line">        <span class="keyword">var</span> tmp = [];</span><br><span class="line">        <span class="keyword">var</span> next = [];</span><br><span class="line">        <span class="keyword">for</span>(item <span class="keyword">of</span> NodeQueue)&#123;</span><br><span class="line">            tmp.push(item.val);</span><br><span class="line">            <span class="keyword">if</span>(item.left)&#123;</span><br><span class="line">                next.push(item.left)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(item.right)&#123;</span><br><span class="line">                next.push(item.right)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        NodeQueue = next;</span><br><span class="line">        NodeQueueVal.push(tmp);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">return</span> NodeQueueVal</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>结果：<br>执行用时：68 ms, 在所有 JavaScript 提交中击败了88.70%的用户<br>内存消耗：37.1 MB, 在所有 JavaScript 提交中击败了100.00%的用户</p><h1 id="总结反思"><a href="#总结反思" class="headerlink" title="总结反思"></a>总结反思</h1><p>该题目考察的是队列，多练习多复习，才能将算法和队列结合起来。当明白考察的是队列时，题目就变得简单多了</p>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
          <category> 32从上到下打印二叉树 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树 </tag>
            
            <tag> 队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer-31栈的压入弹出序列</title>
      <link href="/2020/07/14/%E5%89%91%E6%8C%87offer-31%E6%A0%88%E7%9A%84%E5%8E%8B%E5%85%A5%E5%BC%B9%E5%87%BA%E5%BA%8F%E5%88%97/"/>
      <url>/2020/07/14/%E5%89%91%E6%8C%87offer-31%E6%A0%88%E7%9A%84%E5%8E%8B%E5%85%A5%E5%BC%B9%E5%87%BA%E5%BA%8F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如，序列 {1,2,3,4,5} 是某栈的压栈序列，序列 {4,5,3,2,1} 是该压栈序列对应的一个弹出序列，但 {4,3,5,1,2} 就不可能是该压栈序列的弹出序列。</p><p>示例 1：<br>输入：pushed = [1,2,3,4,5], popped = [4,5,3,2,1]<br>输出：true<br>解释：我们可以按以下顺序执行：<br>push(1), push(2), push(3), push(4), pop() -&gt; 4,<br>push(5), pop() -&gt; 5, pop() -&gt; 3, pop() -&gt; 2, pop() -&gt; 1<br>示例 2：<br>输入：pushed = [1,2,3,4,5], popped = [4,3,5,1,2]<br>输出：false<br>解释：1 不能在 2 之前弹出。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/zhan-de-ya-ru-dan-chu-xu-lie-lcof" target="_blank" rel="noopener">https://leetcode-cn.com/problems/zhan-de-ya-ru-dan-chu-xu-lie-lcof</a></p><h1 id="算法分析-代码实现"><a href="#算法分析-代码实现" class="headerlink" title="算法分析+代码实现"></a>算法分析+代码实现</h1><p>分析</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始代码</span></span><br><span class="line"><span class="keyword">var</span> validateStackSequences = <span class="function"><span class="keyword">function</span>(<span class="params">pushed, popped</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//利用辅助栈来判断当前栈顶元素</span></span><br><span class="line">    <span class="keyword">let</span> stack=[]</span><br><span class="line">    <span class="keyword">let</span> i=<span class="number">0</span>,j=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=pushed.length&amp;&amp;j&lt;=poped.length)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!stack.length)&#123;</span><br><span class="line">            stack.push[pushed[i]]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果出栈元素和栈顶元素不相等时</span></span><br><span class="line">        <span class="keyword">if</span>(stack[stack.length<span class="number">-1</span>]!=popped[j])&#123;</span><br><span class="line">        </span><br><span class="line">            <span class="keyword">if</span>(pushed[i] != popped[j])&#123;</span><br><span class="line">                stack.push(pushed[i])</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//当入站元素和出栈元素相同时，则进行一次出栈入栈操作</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(pushed[i]===popped[j])&#123;</span><br><span class="line">                stack.push(pushed[i]);</span><br><span class="line">                stack.pop()</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            stack.pop();</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> stack.length===<span class="number">0</span></span><br><span class="line">   </span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//简化版代码</span></span><br><span class="line"><span class="keyword">var</span> validateStackSequences = <span class="function"><span class="keyword">function</span>(<span class="params">pushed, popped</span>) </span>&#123; </span><br><span class="line">    <span class="comment">//利用辅助栈来判断当前栈顶元素</span></span><br><span class="line">    <span class="keyword">let</span> stack=[]</span><br><span class="line">    <span class="keyword">let</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(item <span class="keyword">of</span> pushed)&#123;</span><br><span class="line">        <span class="comment">//先入栈</span></span><br><span class="line">        stack.push(item);</span><br><span class="line">        <span class="comment">//如果stack不空且stack栈顶元素和poped数组的当前元素相等</span></span><br><span class="line">        <span class="keyword">while</span>(stack.length&amp;&amp;stack[stack.length<span class="number">-1</span>]===popped[i])&#123;</span><br><span class="line">            stack.pop();</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> stack.length===<span class="number">0</span></span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>结果：二者思路基本一致，所谓的简化指的是代码量上的简化，但是就理解程度来说，未简化版的要更好理解一些<br>执行用时：80 ms, 在所有 JavaScript 提交中击败了54.03%的用户<br>内存消耗：37.3 MB, 在所有 JavaScript 提交中击败了100.00%的用户</p><h1 id="总结反思"><a href="#总结反思" class="headerlink" title="总结反思"></a>总结反思</h1><p>同时利用出栈和入栈，只需要考虑当前出栈顺序是否满足即可</p>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
          <category> 31栈的压入弹出序列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 出入栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer-30包含min函数的栈</title>
      <link href="/2020/07/14/%E5%89%91%E6%8C%87offer-30%E5%8C%85%E5%90%ABmin%E5%87%BD%E6%95%B0%E7%9A%84%E6%A0%88/"/>
      <url>/2020/07/14/%E5%89%91%E6%8C%87offer-30%E5%8C%85%E5%90%ABmin%E5%87%BD%E6%95%B0%E7%9A%84%E6%A0%88/</url>
      
        <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的 min 函数在该栈中，调用 min、push 及 pop 的时间复杂度都是 O(1)。<br>示例:<br>MinStack minStack = new MinStack();<br>minStack.push(-2);<br>minStack.push(0);<br>minStack.push(-3);<br>minStack.min();   –&gt; 返回 -3.<br>minStack.pop();<br>minStack.top();      –&gt; 返回 0.<br>minStack.min();   –&gt; 返回 -2.</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/bao-han-minhan-shu-de-zhan-lcof" target="_blank" rel="noopener">https://leetcode-cn.com/problems/bao-han-minhan-shu-de-zhan-lcof</a></p><h1 id="算法分析-代码实现"><a href="#算法分析-代码实现" class="headerlink" title="算法分析+代码实现"></a>算法分析+代码实现</h1><p>利用辅助栈，每当数据栈中存入新数据时，都要实时更新辅助栈顶的值，保证二者长度相等的同时，辅助栈顶的值为对应数据栈的最小值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> MinStack = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//实际栈</span></span><br><span class="line">    <span class="keyword">this</span>.stack=[]</span><br><span class="line">    <span class="comment">//辅助栈</span></span><br><span class="line">    <span class="keyword">this</span>.test =[]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">x</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;void&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">MinStack.prototype.push = <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(x!=<span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="comment">//实际栈入栈</span></span><br><span class="line">        <span class="keyword">this</span>.stack.push(x)</span><br><span class="line">        <span class="comment">//如果辅助栈为空，则先将x入栈</span></span><br><span class="line">        <span class="keyword">if</span>(!<span class="keyword">this</span>.test.length)&#123;</span><br><span class="line">            <span class="keyword">this</span>.test.push(x)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果当前值比辅助栈的最小值小，将该数字压入辅助栈</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(x&lt;<span class="keyword">this</span>.test[<span class="keyword">this</span>.test.length<span class="number">-1</span>])&#123;</span><br><span class="line">            <span class="keyword">this</span>.test.push(x)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//将栈顶的元素重新入栈，使辅助栈和原数据栈长度保持一致</span></span><br><span class="line">            <span class="keyword">this</span>.test.push(<span class="keyword">this</span>.test[<span class="keyword">this</span>.test.length<span class="number">-1</span>])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;void&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">MinStack.prototype.pop = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>.stack.length)&#123;</span><br><span class="line">        <span class="comment">//数据栈和辅助栈同时出栈，保证长度一直相等</span></span><br><span class="line">        <span class="keyword">this</span>.test.pop();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.stack.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">MinStack.prototype.top = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//返回数据栈的最上方的值但不出栈</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.stack[<span class="keyword">this</span>.stack.length<span class="number">-1</span>]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">MinStack.prototype.min = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.test[<span class="keyword">this</span>.test.length<span class="number">-1</span>]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>结果：<br>执行用时：124 ms, 在所有 JavaScript 提交中击败了70.34%的用户<br>内存消耗：41.7 MB, 在所有 JavaScript 提交中击败了100.00%的用户</p><h1 id="总结反思"><a href="#总结反思" class="headerlink" title="总结反思"></a>总结反思</h1><p>该题目考察的就是一个画图理解的问题，分析时勤动笔，多找一些典型，就能把算法实现</p>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
          <category> 30包含min函数的栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 栈 </tag>
            
            <tag> 自定义函数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer-29顺时针打印矩阵</title>
      <link href="/2020/07/13/%E5%89%91%E6%8C%87offer-29%E9%A1%BA%E6%97%B6%E9%92%88%E6%89%93%E5%8D%B0%E7%9F%A9%E9%98%B5/"/>
      <url>/2020/07/13/%E5%89%91%E6%8C%87offer-29%E9%A1%BA%E6%97%B6%E9%92%88%E6%89%93%E5%8D%B0%E7%9F%A9%E9%98%B5/</url>
      
        <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。<br>示例 1：<br>输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]<br>输出：[1,2,3,6,9,8,7,4,5]<br>示例 2：<br>输入：matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]<br>输出：[1,2,3,4,8,12,11,10,9,5,6,7]<br>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/shun-shi-zhen-da-yin-ju-zhen-lcof" target="_blank" rel="noopener">https://leetcode-cn.com/problems/shun-shi-zhen-da-yin-ju-zhen-lcof</a></p><h1 id="算法分析-代码实现"><a href="#算法分析-代码实现" class="headerlink" title="算法分析+代码实现"></a>算法分析+代码实现</h1><p>1 一层一层循环，直到最后一层，通过添加判定条件来确定什么时候跳出循环</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> spiralOrder = <span class="function"><span class="keyword">function</span>(<span class="params">matrix</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!matrix.length)&#123;</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> res = [];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> right = matrix[<span class="number">0</span>].length<span class="number">-1</span></span><br><span class="line">    <span class="keyword">let</span> down=matrix.length<span class="number">-1</span></span><br><span class="line">    <span class="keyword">let</span> left = <span class="number">0</span></span><br><span class="line">    <span class="keyword">let</span> up = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span>(left&lt;=right&amp;&amp;up&lt;=down)&#123;</span><br><span class="line">        <span class="comment">//最上边从左到右</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> r=left;r&lt;=right;r++)&#123;</span><br><span class="line">            res.push(matrix[up][r])</span><br><span class="line">        &#125;       </span><br><span class="line">            up++;</span><br><span class="line">        <span class="comment">//最右边从上到下</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> d=up;d&lt;=down;d++)&#123;</span><br><span class="line">            res.push(matrix[d][right])</span><br><span class="line">        &#125;       </span><br><span class="line">            right--;</span><br><span class="line">        <span class="comment">//确定循环结束条件，保证不会多次递归</span></span><br><span class="line">        <span class="keyword">if</span>(up&gt;down||right&lt;left) <span class="keyword">break</span>;      </span><br><span class="line">        </span><br><span class="line">        <span class="comment">//最下边从右到左</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> l =right;l&gt;=left;l--)&#123;</span><br><span class="line">            res.push(matrix[down][l])</span><br><span class="line">        &#125;</span><br><span class="line">            down--;</span><br><span class="line">        <span class="comment">//最左边从下到上</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> u = down;u&gt;=up;u--)&#123;</span><br><span class="line">            res.push(matrix[u][left])</span><br><span class="line">        &#125;</span><br><span class="line">            left++   </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>结果：<br>执行用时：96 ms, 在所有 JavaScript 提交中击败了77.67%的用户<br>内存消耗：39.1 MB, 在所有 JavaScript 提交中击败了100.00%的用户<br>2 思路大致一样，但是只遍历环，最后一行或者最后一列在循环外输出</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> spiralOrder = <span class="function"><span class="keyword">function</span>(<span class="params">matrix</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!matrix.length)&#123;</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> res = [];</span><br><span class="line">    <span class="keyword">let</span> right = matrix[<span class="number">0</span>].length<span class="number">-1</span></span><br><span class="line">    <span class="keyword">let</span> down=matrix.length<span class="number">-1</span></span><br><span class="line">    <span class="keyword">let</span> left = <span class="number">0</span></span><br><span class="line">    <span class="keyword">let</span> up = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span>(left&lt;right&amp;&amp;up&lt;down)&#123;</span><br><span class="line">        <span class="comment">//最上边从左到右</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> r=left;r&lt;right;r++)&#123;</span><br><span class="line">            res.push(matrix[up][r])</span><br><span class="line">        &#125;       </span><br><span class="line">            </span><br><span class="line">        <span class="comment">//最右边从上到下</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> d=up;d&lt;down;d++)&#123;</span><br><span class="line">            res.push(matrix[d][right])</span><br><span class="line">        &#125;       </span><br><span class="line">            </span><br><span class="line">        </span><br><span class="line">        <span class="comment">//最下边从右到左</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> l =right;l&gt;left;l--)&#123;</span><br><span class="line">            res.push(matrix[down][l])</span><br><span class="line">        &#125;</span><br><span class="line">            </span><br><span class="line">        <span class="comment">//最左边从下到上</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> u = down;u&gt;up;u--)&#123;</span><br><span class="line">            res.push(matrix[u][left])</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//循环结束以后，环向内收缩</span></span><br><span class="line">            up++;</span><br><span class="line">            right--;   </span><br><span class="line">            down--; </span><br><span class="line">            left++;  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//注意跳出循环后，判断条件包括了等于号</span></span><br><span class="line">    <span class="comment">//上下相等，只剩中间一行</span></span><br><span class="line">    <span class="keyword">if</span>(up===down)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> r=left;r&lt;=right;r++)&#123;</span><br><span class="line">            res.push(matrix[up][r])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//左右相等，只剩最后一列</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(left===right)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> d=up;d&lt;=down;d++)&#123;</span><br><span class="line">            res.push(matrix[d][right])</span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>结果：<br>执行用时：104 ms, 在所有 JavaScript 提交中击败了45.70%的用户<br>内存消耗：39.6 MB, 在所有 JavaScript 提交中击败了100.00%的用户</p><p>链接：<a href="https://leetcode-cn.com/problems/shun-shi-zhen-da-yin-ju-zhen-lcof/solution/shou-hui-tu-jie-liang-chong-bian-li-de-ce-lue-na-c/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/shun-shi-zhen-da-yin-ju-zhen-lcof/solution/shou-hui-tu-jie-liang-chong-bian-li-de-ce-lue-na-c/</a></p><h1 id="总结反思"><a href="#总结反思" class="headerlink" title="总结反思"></a>总结反思</h1><p>多列举一些特殊情况来总结循环终止条件<br>同时注意排除特殊情况<br>在js中 []!=null 最好通过array.length来判断该数组是否为空</p>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
          <category> 29顺时针打印矩阵 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 矩阵 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer-28对称的二叉树</title>
      <link href="/2020/07/13/%E5%89%91%E6%8C%87offer-28%E5%AF%B9%E7%A7%B0%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
      <url>/2020/07/13/%E5%89%91%E6%8C%87offer-28%E5%AF%B9%E7%A7%B0%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>请实现一个函数，用来判断一棵二叉树是不是对称的。如果一棵二叉树和它的镜像一样，那么它是对称的。<br>例如，二叉树 [1,2,2,3,4,4,3] 是对称的。<br>    1<br>   / <br>  2   2<br> / \ / <br>3  4 4  3<br>但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的:<br>    1<br>   / <br>  2   2<br>   \   <br>   3    3<br> 示例 1：<br>输入：root = [1,2,2,3,4,4,3]<br>输出：true<br>示例 2：<br>输入：root = [1,2,2,null,3,null,3]<br>输出：false</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/dui-cheng-de-er-cha-shu-lcof" target="_blank" rel="noopener">https://leetcode-cn.com/problems/dui-cheng-de-er-cha-shu-lcof</a></p><h1 id="算法分析-代码实现"><a href="#算法分析-代码实现" class="headerlink" title="算法分析+代码实现"></a>算法分析+代码实现</h1><p>1 递归算法解决</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> isSymmetric = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> isEquir = <span class="function"><span class="keyword">function</span>(<span class="params">root1,  root2</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//两个节点都是空，则二者相等</span></span><br><span class="line">    <span class="keyword">if</span>(!root1&amp;&amp;!root2)&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">true</span> </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//有一个不为空</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(!root1||!root2)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回比较值：当前节点给相等，比较左子树的左节点和右子树的右节点；左子树的右节点和右子树的左节点</span></span><br><span class="line">    <span class="keyword">return</span> root1.val==root2.val &amp;&amp; isEquir(root1.left,root2.right) &amp;&amp; isEquir(root1.right,root2.left)</span><br><span class="line">&#125;   </span><br><span class="line">    <span class="comment">//直接从根节点开始比较，不需要考虑空树</span></span><br><span class="line">    <span class="keyword">return</span> isEquir(root,root)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>结果：<br>执行用时：84 ms, 在所有 JavaScript 提交中击败了43.39%的用户<br>内存消耗：36.7 MB, 在所有 JavaScript 提交中击败了100.00%的用户</p><h1 id="总结反思"><a href="#总结反思" class="headerlink" title="总结反思"></a>总结反思</h1><p>双参数，需要再写一个递归函数<br>递归函数还是要多看，多理解多掌握</p>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
          <category> 28对称的二叉树 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树 </tag>
            
            <tag> 递归 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer-27二叉树的镜像</title>
      <link href="/2020/07/13/%E5%89%91%E6%8C%87offer-27%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%95%9C%E5%83%8F/"/>
      <url>/2020/07/13/%E5%89%91%E6%8C%87offer-27%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%95%9C%E5%83%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>请完成一个函数，输入一个二叉树，该函数输出它的镜像。<br>例如输入：<br>     4<br>   /   <br>  2     7<br> / \   / <br>1   3 6   9<br>镜像输出：<br>     4<br>   /   <br>  7     2<br> / \   / <br>9   6 3   1<br>示例 1：<br>输入：root = [4,2,7,1,3,6,9]<br>输出：[4,7,2,9,6,3,1]<br>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/er-cha-shu-de-jing-xiang-lcof" target="_blank" rel="noopener">https://leetcode-cn.com/problems/er-cha-shu-de-jing-xiang-lcof</a></p><h1 id="算法分析-代码实现"><a href="#算法分析-代码实现" class="headerlink" title="算法分析+代码实现"></a>算法分析+代码实现</h1><p>递归算法，先上后下直接递归就好</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mirrorTree = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root)&#123;</span><br><span class="line">        <span class="keyword">return</span> root</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(root.left||root.right)&#123;</span><br><span class="line">        <span class="keyword">let</span> test = root.left;</span><br><span class="line">        root.left = root.right;</span><br><span class="line">        root.right = test;</span><br><span class="line">    &#125;</span><br><span class="line">    mirrorTree(root.left)</span><br><span class="line">    mirrorTree(root.right)</span><br><span class="line">    <span class="keyword">return</span> root</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>结果：<br>执行用时：88 ms, 在所有 JavaScript 提交中击败了7.32%的用户<br>内存消耗：33.1 MB, 在所有 JavaScript 提交中击败了100.00%的用户</p><h1 id="总结反思"><a href="#总结反思" class="headerlink" title="总结反思"></a>总结反思</h1><p>一定要先理解函数过程，再设计递归函数，这样才能又快又好地写出递归算法</p>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
          <category> 27二叉树的镜像 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树 </tag>
            
            <tag> 递归 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer-26树的子结构</title>
      <link href="/2020/07/12/%E5%89%91%E6%8C%87offer-26%E6%A0%91%E7%9A%84%E5%AD%90%E7%BB%93%E6%9E%84/"/>
      <url>/2020/07/12/%E5%89%91%E6%8C%87offer-26%E6%A0%91%E7%9A%84%E5%AD%90%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>输入两棵二叉树A和B，判断B是不是A的子结构。(约定空树不是任意一个树的子结构)<br>B是A的子结构， 即 A中有出现和B相同的结构和节点值。<br>例如:<br>给定的树 A:</p><pre><code> 3/ \</code></pre><p>   4   5<br>  / <br> 1   2<br>给定的树 B：<br>   4<br>  /<br> 1<br>返回 true，因为 B 与 A 的一个子树拥有相同的结构和节点值。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/shu-de-zi-jie-gou-lcof" target="_blank" rel="noopener">https://leetcode-cn.com/problems/shu-de-zi-jie-gou-lcof</a></p><h1 id="算法分析-代码实现"><a href="#算法分析-代码实现" class="headerlink" title="算法分析+代码实现"></a>算法分析+代码实现</h1><p>递归算法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> isSubStructure = <span class="function"><span class="keyword">function</span>(<span class="params">A, B</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//空树不是任意一个树的子结构</span></span><br><span class="line">    <span class="keyword">if</span>(!A||!B)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断A当前节点，或者A左子节点，或者右子节点和B</span></span><br><span class="line">    <span class="keyword">return</span> isEqual(A,B)||isSubStructure(A.left,B)||isSubStructure(A.right,B)     </span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> isEqual = <span class="function"><span class="keyword">function</span>(<span class="params">A,B</span>)</span>&#123;</span><br><span class="line">        <span class="comment">//B遍历结束，说明匹配成功</span></span><br><span class="line">        <span class="keyword">if</span>(!B)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//A遍历结束，B还没结束，肯定不匹配</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(!A)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//A,B值不相等，返回false</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(A.val!=B.val)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(A.val===B.val)&#123;</span><br><span class="line">            <span class="comment">//当前节点相等的话，判断左子节点和右子节点</span></span><br><span class="line">            <span class="keyword">return</span> isEqual(A.left,B.left)&amp;&amp;isEqual(A.right,B.right)</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：<br>执行用时：116 ms, 在所有 JavaScript 提交中击败了46.50%的用户<br>内存消耗：56.9 MB, 在所有 JavaScript 提交中击败了100.00%的用户</p><h1 id="总结反思"><a href="#总结反思" class="headerlink" title="总结反思"></a>总结反思</h1><p>总的来说，该问题还是一个递归问题，一开始想着使用原来的函数，但是写到后面发现无法区分A的当前节点和B的匹配进度，A的子节点和B的匹配进度<br>故重新写了一个函数，瞬间简单了<br>所以，递归时直接写子函数，总是没错的</p>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
          <category> 26树的子结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树 </tag>
            
            <tag> 递归 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer-25合并两个排序链表</title>
      <link href="/2020/07/12/%E5%89%91%E6%8C%87offer-25%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8/"/>
      <url>/2020/07/12/%E5%89%91%E6%8C%87offer-25%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>输入两个递增排序的链表，合并这两个链表并使新链表中的节点仍然是递增排序的。</p><p>示例1：<br>输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4<br>输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/he-bing-liang-ge-pai-xu-de-lian-biao-lcof" target="_blank" rel="noopener">https://leetcode-cn.com/problems/he-bing-liang-ge-pai-xu-de-lian-biao-lcof</a></p><h1 id="算法分析-代码实现"><a href="#算法分析-代码实现" class="headerlink" title="算法分析+代码实现"></a>算法分析+代码实现</h1><p>1 双指针</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mergeTwoLists = <span class="function"><span class="keyword">function</span>(<span class="params">l1, l2</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//空链表</span></span><br><span class="line">    <span class="comment">//l1空 返回l2</span></span><br><span class="line">    <span class="keyword">if</span>(!l1)&#123;</span><br><span class="line">        <span class="keyword">return</span> l2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//l2空 返回l1</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(!l2)&#123;</span><br><span class="line">        <span class="keyword">return</span> l1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//定义头节点</span></span><br><span class="line">    <span class="keyword">if</span>(l1.val&lt;l2.val)&#123;</span><br><span class="line">        head = l1</span><br><span class="line">        l1 = l1.next</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        head = l2</span><br><span class="line">        l2 = l2.next</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> test=head;</span><br><span class="line">    <span class="keyword">while</span>(l1&amp;&amp;l2)&#123;</span><br><span class="line">        <span class="keyword">if</span>(l1.val&lt;l2.val)&#123;</span><br><span class="line">            test.next =<span class="keyword">new</span> ListNode(l1.val);</span><br><span class="line">            l1=l1.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            test.next =<span class="keyword">new</span> ListNode(l2.val);</span><br><span class="line">            l2=l2.next</span><br><span class="line">        &#125;</span><br><span class="line">        test = test.next</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!l1)&#123;</span><br><span class="line">        test.next=l2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!l2)&#123;</span><br><span class="line">        test.next =l1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>结果:<br>执行用时：100 ms, 在所有 JavaScript 提交中击败了56.76%的用户<br>内存消耗：40.3 MB, 在所有 JavaScript 提交中击败了100.00%的用户</p><p>2  递归写法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mergeTwoLists = <span class="function"><span class="keyword">function</span>(<span class="params">l1, l2</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//空链表</span></span><br><span class="line">    <span class="comment">//l1空 返回l2</span></span><br><span class="line">    <span class="keyword">if</span>(!l1)&#123;</span><br><span class="line">        <span class="keyword">return</span> l2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//l2空 返回l1</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(!l2)&#123;</span><br><span class="line">        <span class="keyword">return</span> l1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(l1&amp;&amp;l2)&#123;</span><br><span class="line">        <span class="keyword">if</span>(l1.val&lt;l2.val)&#123;</span><br><span class="line">           l1.next = mergeTwoLists(l1.next,l2)</span><br><span class="line">           <span class="keyword">return</span> l1</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">          l2.next = mergeTwoLists(l1,l2.next)</span><br><span class="line">          <span class="keyword">return</span> l2</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>结果:<br>执行用时：80 ms, 在所有 JavaScript 提交中击败了98.99%的用户<br>内存消耗：39.5 MB, 在所有 JavaScript 提交中击败了100.00%的用户</p><h1 id="总结反思"><a href="#总结反思" class="headerlink" title="总结反思"></a>总结反思</h1><p>双指针的写法一定要掌握<br>递归算法的话,也要了解,最好是自己可以写出来</p>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
          <category> 25合并两个链表 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表 </tag>
            
            <tag> 递归 </tag>
            
            <tag> 双指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer-24反转链表</title>
      <link href="/2020/07/12/%E5%89%91%E6%8C%87offer-24%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/"/>
      <url>/2020/07/12/%E5%89%91%E6%8C%87offer-24%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>定义函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点。<br>示例:<br>输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL<br>输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/fan-zhuan-lian-biao-lcof" target="_blank" rel="noopener">https://leetcode-cn.com/problems/fan-zhuan-lian-biao-lcof</a></p><h1 id="算法分析-代码实现"><a href="#算法分析-代码实现" class="headerlink" title="算法分析+代码实现"></a>算法分析+代码实现</h1><p>1 用栈存储，然后依次出栈生成节点</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> reverseList = <span class="function"><span class="keyword">function</span>(<span class="params">head</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> stack = []<span class="comment">//用栈存储节点值</span></span><br><span class="line">    <span class="comment">//数组为空时，直接返回空</span></span><br><span class="line">    <span class="keyword">if</span>(!head)&#123;</span><br><span class="line">        <span class="keyword">return</span> head</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(head)&#123;</span><br><span class="line">        stack.push(head.val)</span><br><span class="line">        head = head.next</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> res= <span class="keyword">new</span> ListNode(stack.pop())<span class="comment">//定义头节点</span></span><br><span class="line">    <span class="keyword">let</span> test =res<span class="comment">//标记反转后链表的头指针  </span></span><br><span class="line">    <span class="keyword">while</span>(stack.length)&#123;</span><br><span class="line">        res.next = <span class="keyword">new</span> ListNode(stack.pop())</span><br><span class="line">        res = res.next</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> test;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>结果：（多次实验，这是最好的一次）<br>执行用时：72 ms, 在所有 JavaScript 提交中击败了74.50%的用户<br>内存消耗：36.3 MB, 在所有 JavaScript 提交中击败了100.00%的用户</p><p>2 三指针，遍历第一次的同时完成反转</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> reverseList = <span class="function"><span class="keyword">function</span>(<span class="params">head</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//当前顺序链表的当前的节点的前一个值，也是反转链表的下一个值</span></span><br><span class="line">    <span class="keyword">let</span> prev = <span class="literal">null</span></span><br><span class="line">    <span class="comment">//顺序链表和反转链表的当前节点</span></span><br><span class="line">    <span class="keyword">let</span> cur = head</span><br><span class="line">    <span class="keyword">while</span>(cur)&#123;</span><br><span class="line">        <span class="comment">//1 保存顺序链表后一个节点</span></span><br><span class="line">        <span class="keyword">let</span> next = cur.next</span><br><span class="line">        <span class="comment">//2 改变当前指针的next值,指向顺序链表的当前值的前一个</span></span><br><span class="line">        cur.next = prev</span><br><span class="line">        <span class="comment">//3 更新prev节点，指向当前节点</span></span><br><span class="line">        prev = cur</span><br><span class="line">        <span class="comment">//4 更新cur的值，指向顺序链表的下一个节点</span></span><br><span class="line">        cur = next</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//cur最终会成为null，故返回的应该是cur的前一个节点prev</span></span><br><span class="line">    <span class="keyword">return</span> prev</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>结果：<br>执行用时：72 ms, 在所有 JavaScript 提交中击败了74.50%的用户<br>内存消耗：35.6 MB, 在所有 JavaScript 提交中击败了100.00%的用户</p><h1 id="总结反思"><a href="#总结反思" class="headerlink" title="总结反思"></a>总结反思</h1><p>最主要的是要理解和掌握三指针的使用，不懂的时候就多画图，有助于理解</p>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
          <category> 24反转链表 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表 </tag>
            
            <tag> 栈 </tag>
            
            <tag> 反转链表 </tag>
            
            <tag> 三指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer-22链表中倒数第k个节点</title>
      <link href="/2020/07/12/%E5%89%91%E6%8C%87offer-22%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E8%8A%82%E7%82%B9/"/>
      <url>/2020/07/12/%E5%89%91%E6%8C%87offer-22%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E8%8A%82%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。例如，一个链表有6个节点，从头节点开始，它们的值依次是1、2、3、4、5、6。这个链表的倒数第3个节点是值为4的节点。</p><p>示例：<br>给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 k = 2.<br>返回链表 4-&gt;5.</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof" target="_blank" rel="noopener">https://leetcode-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof</a></p><h1 id="算法分析-代码实现"><a href="#算法分析-代码实现" class="headerlink" title="算法分析+代码实现"></a>算法分析+代码实现</h1><p>1 两次遍历，一次确定长度，一次寻找合适对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> getKthFromEnd = <span class="function"><span class="keyword">function</span>(<span class="params">head, k</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> test =head;</span><br><span class="line">    <span class="keyword">let</span> num = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//此处的num指的是链表长度，从1开始，便于思考和计算</span></span><br><span class="line">    <span class="keyword">while</span>(head.next)&#123;</span><br><span class="line">        num++;</span><br><span class="line">        head = head.next</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//此处num指的是</span></span><br><span class="line">    num = num-k;</span><br><span class="line">    <span class="keyword">while</span>(num)&#123;</span><br><span class="line">        num--;</span><br><span class="line">        test = test.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> test</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>结果：<br>执行用时：72 ms, 在所有 JavaScript 提交中击败了71.96%的用户<br>内存消耗：33.1 MB, 在所有 JavaScript 提交中击败了100.00%的用户</p><p>2 一次遍历：利用双指针，卡好间隔，当后一个指针指向结尾时，前一个指针刚好指向第k个</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> getKthFromEnd = <span class="function"><span class="keyword">function</span>(<span class="params">head, k</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> test =head;</span><br><span class="line">    <span class="keyword">let</span> num = k<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(num)&#123;</span><br><span class="line">        num--;</span><br><span class="line">        test = test.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(test.next)&#123;</span><br><span class="line">        head=head.next;</span><br><span class="line">        test=test.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>结果：<br>执行用时：72 ms, 在所有 JavaScript 提交中击败了71.96%的用户<br>内存消耗：33.3 MB, 在所有 JavaScript 提交中击败了100.00%的用户</p><h1 id="总结反思"><a href="#总结反思" class="headerlink" title="总结反思"></a>总结反思</h1><p>其实该问题主要考察的就是双指针的问题 ，以及对链表结构的理解<br>和上一题基本差不多</p>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
          <category> 22链表中倒数第k个节点 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表 </tag>
            
            <tag> 双指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer-21调整数组顺序使奇数位于偶数前</title>
      <link href="/2020/07/11/%E5%89%91%E6%8C%87offer-21%E8%B0%83%E6%95%B4%E6%95%B0%E7%BB%84%E9%A1%BA%E5%BA%8F%E4%BD%BF%E5%A5%87%E6%95%B0%E4%BD%8D%E4%BA%8E%E5%81%B6%E6%95%B0%E5%89%8D/"/>
      <url>/2020/07/11/%E5%89%91%E6%8C%87offer-21%E8%B0%83%E6%95%B4%E6%95%B0%E7%BB%84%E9%A1%BA%E5%BA%8F%E4%BD%BF%E5%A5%87%E6%95%B0%E4%BD%8D%E4%BA%8E%E5%81%B6%E6%95%B0%E5%89%8D/</url>
      
        <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有奇数位于数组的前半部分，所有偶数位于数组的后半部分。<br>示例：<br>输入：nums = [1,2,3,4]<br>输出：[1,3,2,4]<br>注：[3,1,2,4] 也是正确的答案之一。 </p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/diao-zheng-shu-zu-shun-xu-shi-qi-shu-wei-yu-ou-shu-qian-mian-lcof" target="_blank" rel="noopener">https://leetcode-cn.com/problems/diao-zheng-shu-zu-shun-xu-shi-qi-shu-wei-yu-ou-shu-qian-mian-lcof</a></p><h1 id="算法分析-代码实现"><a href="#算法分析-代码实现" class="headerlink" title="算法分析+代码实现"></a>算法分析+代码实现</h1><p>1 冒泡排序</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> exchange = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> max = nums.length</span><br><span class="line">    <span class="keyword">let</span> flag = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(max)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i= <span class="number">0</span>;i&lt;max<span class="number">-1</span>;i++)&#123;</span><br><span class="line">        <span class="comment">//nums[i]是偶数，nums[i+1]是奇数</span></span><br><span class="line">        <span class="keyword">if</span>(!(nums[i]%<span class="number">2</span>)&amp;&amp;nums[i+<span class="number">1</span>]%<span class="number">2</span>)&#123;</span><br><span class="line">            flag = nums[i];</span><br><span class="line">            nums[i]=nums[i+<span class="number">1</span>];</span><br><span class="line">            nums[i+<span class="number">1</span>]=flag;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    max--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>结果：时间花销太大</p><p>执行用时：6740 ms, 在所有 JavaScript 提交中击败了5.05%的用户<br>内存消耗：43.5 MB, 在所有 JavaScript 提交中击败了100.00%的用户<br>2 分组讨论，用空间换时间，时间复杂度为O(n),空间复杂度为O(n)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> exchange = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!nums.length)&#123;</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> odd=[]<span class="comment">//存放奇数</span></span><br><span class="line">    <span class="keyword">let</span> oven=[]<span class="comment">//存放偶数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i= <span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">        <span class="comment">//nums[i]是奇数</span></span><br><span class="line">        <span class="keyword">if</span>(nums[i]%<span class="number">2</span>)&#123;</span><br><span class="line">            odd.push(nums[i])</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//偶数</span></span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            oven.push(nums[i])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//利用es6的...运算符</span></span><br><span class="line">    odd.push(...oven)</span><br><span class="line">    <span class="keyword">return</span> odd</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>结果：时间大幅降低，但是是以空间换取时间的做法<br>执行用时：112 ms, 在所有 JavaScript 提交中击败了75.53%的用户<br>内存消耗：46.3 MB, 在所有 JavaScript 提交中击败了100.00%的用户</p><p>3 利用双指针，符合条件，两个指针的内容换过来</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//未优化版</span></span><br><span class="line"><span class="keyword">var</span> exchange = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> i=<span class="number">0</span>,j=nums.length<span class="number">-1</span></span><br><span class="line">    <span class="keyword">while</span>(i&lt;j)&#123;</span><br><span class="line">        <span class="comment">//nums[i]是偶数</span></span><br><span class="line">        <span class="keyword">if</span>(!(nums[i]%<span class="number">2</span>))&#123;</span><br><span class="line">            <span class="comment">//nums[j]是奇数</span></span><br><span class="line">            <span class="keyword">if</span>(nums[j]%<span class="number">2</span>)&#123;</span><br><span class="line">                <span class="comment">//二者互换</span></span><br><span class="line">                <span class="keyword">let</span> flag = nums[i];</span><br><span class="line">                nums[i]=nums[j];</span><br><span class="line">                nums[j]=flag;</span><br><span class="line">                i++;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                j--</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//优化版</span></span><br><span class="line"><span class="keyword">var</span> exchange = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> i = <span class="number">0</span>, j = nums.length <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">        <span class="keyword">while</span> (nums[i] &amp; <span class="number">1</span> &amp;&amp; i &lt; j) &#123;</span><br><span class="line">            i += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!(nums[j] &amp; <span class="number">1</span>) &amp;&amp; i &lt; j) &#123;</span><br><span class="line">            j -= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//解构赋值</span></span><br><span class="line">        [nums[i], nums[j]] = [nums[j], nums[i]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>结果: 时间空间复杂度都是最低的<br>执行用时：108 ms, 在所有 JavaScript 提交中击败了85.42%的用户<br>内存消耗：43.6 MB, 在所有 JavaScript 提交中击败了100.00%的用户</p><h1 id="总结反思"><a href="#总结反思" class="headerlink" title="总结反思"></a>总结反思</h1><p>1 冒泡排序要熟练掌握，但是时间开销较大，使用时注意<br>2 优化时可以选择以时间换空间做法<br>3 双指针也是一种方法，记得使用</p>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
          <category> 21调整数组顺序使奇数位于偶数前 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 冒泡排序 </tag>
            
            <tag> 双指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer-20表示数值的字符串</title>
      <link href="/2020/07/11/%E5%89%91%E6%8C%87offer-20%E8%A1%A8%E7%A4%BA%E6%95%B0%E5%80%BC%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
      <url>/2020/07/11/%E5%89%91%E6%8C%87offer-20%E8%A1%A8%E7%A4%BA%E6%95%B0%E5%80%BC%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。例如，字符串”+100”、”5e2”、”-123”、”3.1416”、”0123”都表示数值，但”12e”、”1a3.14”、”1.2.3”、”+-5”、”-1E-16”及”12e+5.4”都不是。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/biao-shi-shu-zhi-de-zi-fu-chuan-lcof" target="_blank" rel="noopener">https://leetcode-cn.com/problems/biao-shi-shu-zhi-de-zi-fu-chuan-lcof</a></p><h1 id="算法分析-代码实现"><a href="#算法分析-代码实现" class="headerlink" title="算法分析+代码实现"></a>算法分析+代码实现</h1><p>1 正则</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//string.trim()表示把字符串前后的空格去掉</span></span><br><span class="line"><span class="keyword">var</span> isNumber = <span class="function"><span class="keyword">function</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="regexp">/^[+-]?(\d+(\.\d*)?|(\.\d+))(e[+-]?\d+)?$/</span>.test(s.trim());</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>结果：正则是真的香<br>执行用时：88 ms, 在所有 JavaScript 提交中击败了96.06%的用户<br>内存消耗：37.2 MB, 在所有 JavaScript 提交中击败了100.00%的用户</p><p>2 利用js自带的number方法<br>Number.isNaN() 方法确定传递的值是否为 NaN<br>Number 对象主要用于：<br>如果参数无法被转换为数字，则返回 NaN。<br>在非构造器上下文中 (如：没有 new 操作符)，Number 能被用来执行类型转换。<br>Number(s)如果将数组</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> isNumber = <span class="function"><span class="keyword">function</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line">  s = s.trim()</span><br><span class="line">  <span class="keyword">if</span> (s == <span class="string">''</span>) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  <span class="keyword">return</span> !<span class="built_in">Number</span>.isNaN(<span class="built_in">Number</span>(s))</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>结果：想法不错，但是结果不太好<br>执行用时：116 ms, 在所有 JavaScript 提交中击败了16.20%的用户<br>内存消耗：37.3 MB, 在所有 JavaScript 提交中击败了100.00%的用户</p><h1 id="总结反思"><a href="#总结反思" class="headerlink" title="总结反思"></a>总结反思</h1><p>判断字符串时，首先就要想到正则表达式<br>然后再想其他的一般方法，譬如转换类型啊，使用自带函数什么的<br>最后再想：自己实现该方法，因为自己不能保证所有情况都考虑到。</p>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
          <category> 20表示数值的字符串 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 表示数值的字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer-19正则表达式的匹配</title>
      <link href="/2020/07/10/%E5%89%91%E6%8C%87offer-19%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E5%8C%B9%E9%85%8D/"/>
      <url>/2020/07/10/%E5%89%91%E6%8C%87offer-19%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E5%8C%B9%E9%85%8D/</url>
      
        <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>请实现一个函数用来匹配包含’. ‘和’ * ‘的正则表达式。模式中的字符’.’表示任意一个字符，而’ * ‘表示它前面的字符可以出现任意次（含0次）。在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串”aaa”与模式”a.a”和”ab * ac * a”匹配，但与”aa.a”和”ab * a”均不匹配。</p><p>示例 1:<br>输入:s = “aa”,,p  = “a”<br>输出: false<br>解释: “a” 无法匹配 “aa” 整个字符串。<br>示例 2:<br>输入:s = “aa”,p  = “a * “<br>输出: true<br>解释: 因为 ‘ * ‘ 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 ‘a’。因此，字符串 “aa” 可被视为 ‘a’ 重复了一次。<br>示例 3:<br>输入:s = “ab”,p  = “. * “<br>输出: true<br>解释: “. * “ 表示可匹配零个或多个（’ * ‘）任意字符（’.’）。<br>示例 4:<br>输入:s = “aab”,p  = “c * a * b”<br>输出: true<br>解释: 因为 ‘ * ‘ 表示零个或多个，这里 ‘c’ 为 0 个, ‘a’ 被重复一次。因此可以匹配字符串 “aab”。<br>示例 5:<br>输入:s = “mississippi”,p  = “mis * is * p  * .”<br>输出: false</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/zheng-ze-biao-da-shi-pi-pei-lcof" target="_blank" rel="noopener">https://leetcode-cn.com/problems/zheng-ze-biao-da-shi-pi-pei-lcof</a></p><h1 id="算法分析-代码实现"><a href="#算法分析-代码实现" class="headerlink" title="算法分析+代码实现"></a>算法分析+代码实现</h1><p>题解：<br><a href="https://leetcode-cn.com/problems/regular-expression-matching/solution/shou-hui-tu-jie-wo-tai-nan-liao-by-hyj8/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/regular-expression-matching/solution/shou-hui-tu-jie-wo-tai-nan-liao-by-hyj8/</a></p><h1 id="反思总结"><a href="#反思总结" class="headerlink" title="反思总结"></a>反思总结</h1><p>力扣上面的难题，考察对正则表达式和对字符串的理解，以及特殊情况的处理<br>赌一手面试不出，明白思路即可</p>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
          <category> 19正则表达式的匹配 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 剑指offer </tag>
            
            <tag> 正则表达式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer-18删除链表的节点</title>
      <link href="/2020/07/10/%E5%89%91%E6%8C%87offer-18%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E8%8A%82%E7%82%B9/"/>
      <url>/2020/07/10/%E5%89%91%E6%8C%87offer-18%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E8%8A%82%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定单向链表的头指针和一个要删除的节点的值，定义一个函数删除该节点。<br>返回删除后的链表的头节点。（此题对比原题有改动）<br>示例 1:<br>输入: head = [4,5,1,9], val = 5<br>输出: [4,1,9]<br>解释: 给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 1 -&gt; 9.<br>示例 2:<br>输入: head = [4,5,1,9], val = 1<br>输出: [4,5,9]<br>解释: 给定你链表中值为 1 的第三个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 5 -&gt; 9.</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/shan-chu-lian-biao-de-jie-dian-lcof" target="_blank" rel="noopener">https://leetcode-cn.com/problems/shan-chu-lian-biao-de-jie-dian-lcof</a></p><h1 id="算法分析-代码实现"><a href="#算法分析-代码实现" class="headerlink" title="算法分析+代码实现"></a>算法分析+代码实现</h1><p>1 利用哨兵节点，存储当前节点和上一节点或者，当前节点和下一节点<br>哨兵节点的用法灵活，一般是不保存任何数据的节点。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第一种：</span></span><br><span class="line"><span class="keyword">var</span> deleteNode = <span class="function"><span class="keyword">function</span>(<span class="params">head, val</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> pre = <span class="keyword">new</span> ListNode(<span class="number">-1</span>); <span class="comment">// 哨兵节点</span></span><br><span class="line">    pre.next = head;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> node = pre;</span><br><span class="line">    <span class="keyword">while</span> (node.next) &#123;</span><br><span class="line">        <span class="keyword">if</span> (node.next.val === val) &#123;</span><br><span class="line">            node.next = node.next.next;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        node = node.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pre.next;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//第二种 哨兵节点 存储当前节点和下一节点，通过判断下一节点来选择是否跳过下一节点</span></span><br><span class="line"><span class="keyword">var</span> deleteNode = <span class="function"><span class="keyword">function</span> (<span class="params">head, val</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> pre = head</span><br><span class="line">    <span class="keyword">let</span> node = pre.next</span><br><span class="line">    <span class="keyword">if</span> (pre.val === val) &#123;</span><br><span class="line">        <span class="keyword">return</span> head.next</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (node) &#123;</span><br><span class="line">        <span class="keyword">if</span> (node.val === val) &#123;</span><br><span class="line">            pre.next = node.next</span><br><span class="line">        &#125;</span><br><span class="line">        pre = node</span><br><span class="line">        node = node.next</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>结果：时间复杂度O（n），空间复杂度O（1）<br>执行用时：80 ms, 在所有 JavaScript 提交中击败了65.60%的用户<br>内存消耗：36.9 MB, 在所有 JavaScript 提交中击败了100.00%的用户</p><p>2 递归： 利用递归思想，来删除节点</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> deleteNode = <span class="function"><span class="keyword">function</span>(<span class="params">head, val</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head.val === val)&#123;</span><br><span class="line">        <span class="keyword">return</span> head.next</span><br><span class="line">    &#125;</span><br><span class="line">    head.next = deleteNode(head.next,val)</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>结果：使用递归后，节省了代码量，但是增加了系统内存消耗，不推荐使用<br>执行用时：80 ms, 在所有 JavaScript 提交中击败了65.60%的用户<br>内存消耗：37 MB, 在所有 JavaScript 提交中击败了100.00%的用户</p><h1 id="总结反思"><a href="#总结反思" class="headerlink" title="总结反思"></a>总结反思</h1><p>该题目主要考查的是哨兵节点的使用，要注意理解并掌握该方法</p>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
          <category> 18删除链表的节点 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表 </tag>
            
            <tag> 递归 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer-17打印从1到最大的n位十进制数</title>
      <link href="/2020/07/09/%E5%89%91%E6%8C%87offer-17%E6%89%93%E5%8D%B0%E4%BB%8E1%E5%88%B0%E6%9C%80%E5%A4%A7%E7%9A%84n%E4%BD%8D%E5%8D%81%E8%BF%9B%E5%88%B6%E6%95%B0/"/>
      <url>/2020/07/09/%E5%89%91%E6%8C%87offer-17%E6%89%93%E5%8D%B0%E4%BB%8E1%E5%88%B0%E6%9C%80%E5%A4%A7%E7%9A%84n%E4%BD%8D%E5%8D%81%E8%BF%9B%E5%88%B6%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>输入数字 n，按顺序打印出从 1 到最大的 n 位十进制数。比如输入 3，则打印出 1、2、3 一直到最大的 3 位数 999。</p><p>示例 1:<br>输入: n = 1<br>输出: [1,2,3,4,5,6,7,8,9]</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/da-yin-cong-1dao-zui-da-de-nwei-shu-lcof" target="_blank" rel="noopener">https://leetcode-cn.com/problems/da-yin-cong-1dao-zui-da-de-nwei-shu-lcof</a></p><h1 id="算法分析-代码实现"><a href="#算法分析-代码实现" class="headerlink" title="算法分析+代码实现"></a>算法分析+代码实现</h1><p>1 我一开始想的就是：一位一位的算，然后慢慢扩大数组中的数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> printNumbers = <span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line"><span class="comment">//n&lt;0;</span></span><br><span class="line"><span class="keyword">if</span>(n&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> base = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> res = [];</span><br><span class="line"><span class="keyword">while</span>(n)&#123;</span><br><span class="line">    n--;</span><br><span class="line">    <span class="keyword">let</span> i=base;</span><br><span class="line">    base=base*<span class="number">10</span>;</span><br><span class="line">    <span class="keyword">for</span>(;i&lt;base;i++)&#123;</span><br><span class="line">        res.push(i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>结果：<br>执行用时：116 ms, 在所有 JavaScript 提交中击败了84.86%的用户<br>内存消耗：45.4 MB, 在所有 JavaScript 提交中击败了100.00%的用户<br>代码有些过长<br>2 直接算出最大值，然后一个循环递归</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> printNumbers = <span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line"><span class="comment">//n&lt;0;</span></span><br><span class="line"><span class="keyword">if</span>(n&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> max = <span class="number">10</span>**n;</span><br><span class="line"><span class="keyword">let</span> res = []</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">1</span>;i&lt;max;i++)&#123;</span><br><span class="line">    res.push(i)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>执行用时：124 ms, 在所有 JavaScript 提交中击败了70.86%的用户<br>内存消耗：45.4 MB, 在所有 JavaScript 提交中击败了100.00%的用户</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本题在原书上是考察大数的存储，而js的number型为双精度，32位，故不存在这个问题；<br>考点也就剩下了一个：快速求幂<br>可以使用：</p><ol><li>math.pow()方法</li><li><ul><li><ul><li>运算符</li></ul></li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
          <category> 17打印从1到最大n位的十进制数 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 剑指offer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer-16数值的整数次方</title>
      <link href="/2020/07/09/%E5%89%91%E6%8C%87offer-16%E6%95%B0%E5%80%BC%E7%9A%84%E6%95%B4%E6%95%B0%E6%AC%A1%E6%96%B9/"/>
      <url>/2020/07/09/%E5%89%91%E6%8C%87offer-16%E6%95%B0%E5%80%BC%E7%9A%84%E6%95%B4%E6%95%B0%E6%AC%A1%E6%96%B9/</url>
      
        <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>实现函数double Power(double base, int exponent)，求base的exponent次方。不得使用库函数，同时不需要考虑大数问题。</p><p>示例 1:<br>输入: 2.00000, 10<br>输出: 1024.00000<br>示例 2:<br>输入: 2.10000, 3<br>输出: 9.26100<br>示例 3:<br>输入: 2.00000, -2<br>输出: 0.25000<br>解释: 2-2 = 1/22 = 1/4 = 0.25</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/shu-zhi-de-zheng-shu-ci-fang-lcof" target="_blank" rel="noopener">https://leetcode-cn.com/problems/shu-zhi-de-zheng-shu-ci-fang-lcof</a></p><h1 id="知识回顾"><a href="#知识回顾" class="headerlink" title="知识回顾"></a>知识回顾</h1><ol><li>js中的Math.pow(a,b)方法，求a的b次方</li><li>Javascript完全套用了Java的位运算符，包括按位与&amp;、按位或|、按位异或^、按位非~、左移&lt;&lt;、带符号的右移&gt;&gt;和用0补足的右移&gt;&gt;&gt;。<h1 id="算法分析-代码实现"><a href="#算法分析-代码实现" class="headerlink" title="算法分析+代码实现"></a>算法分析+代码实现</h1>1 简单解法：分情况讨论，然后按次数累乘<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myPow = <span class="function"><span class="keyword">function</span>(<span class="params">x, n</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//底数为0；</span></span><br><span class="line">    <span class="keyword">if</span>(x === <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//指数为零</span></span><br><span class="line">    <span class="keyword">if</span>(n === <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//正常情况</span></span><br><span class="line">    base = x;</span><br><span class="line">    <span class="comment">//求幂</span></span><br><span class="line">    <span class="keyword">if</span>(n&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">while</span>(n&gt;<span class="number">1</span>)&#123;</span><br><span class="line">            n--;</span><br><span class="line">            x*=base;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//求导</span></span><br><span class="line">    <span class="keyword">if</span>(n&lt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">while</span>(n&lt;<span class="number">-1</span>)&#123;</span><br><span class="line">            n++;</span><br><span class="line">            x*=base;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>/x</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>结果：超时<br>2 换思路：递减太费时，可以考虑乘方，这样一次可以降多个幂<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myPow = <span class="function"><span class="keyword">function</span>(<span class="params">x, n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n === <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (n === <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> isNegative = n &lt; <span class="number">0</span>; <span class="comment">// 是否是负指数</span></span><br><span class="line">    <span class="keyword">let</span> absn = <span class="built_in">Math</span>.abs(n);</span><br><span class="line">    <span class="keyword">let</span> result = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (absn) &#123;</span><br><span class="line">        <span class="comment">// 如果n最右位是1，将当前x累乘到result</span></span><br><span class="line">        <span class="keyword">if</span> (absn &amp; <span class="number">1</span>) &#123;</span><br><span class="line">            result = result * x;</span><br><span class="line">        &#125;</span><br><span class="line">        x = x * x; <span class="comment">// x自乘法</span></span><br><span class="line">        absn = <span class="built_in">Math</span>.floor(absn / <span class="number">2</span>); </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> isNegative ? <span class="number">1</span> / result : result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>结果：<br>执行用时：72 ms, 在所有 JavaScript 提交中击败了70.49%的用户<br>内存消耗：33.2 MB, 在所有 JavaScript 提交中击败了100.00%的用户</li></ol><h1 id="反思总结"><a href="#反思总结" class="headerlink" title="反思总结"></a>反思总结</h1><p>使用&gt;&gt;时总是报超时？</p><p>Javascript完全套用了Java的位运算符，包括按位与&amp;、按位或|、按位异或^、按位非~、左移&lt;&lt;、带符号的右移&gt;&gt;和用0补足的右移&gt;&gt;&gt;。<br>这套运算符针对的是整数，所以对Javascript完全无用，因为Javascript内部，所有数字都保存为双精度浮点数。如果使用它们的话，Javascript不得不将运算数先转为整数，然后再进行运算，这样就降低了速度。</p><p>——《12种不宜使用的JavaScript语法》<br><a href="http://www.ruanyifeng.com/blog/2010/01/12_javascript_syntax_structures_you_should_not_use.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2010/01/12_javascript_syntax_structures_you_should_not_use.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
          <category> 16数值的整数次方 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 剑指offer </tag>
            
            <tag> js </tag>
            
            <tag> 数值的整数次方 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer-15二进制中1的个数</title>
      <link href="/2020/07/08/%E5%89%91%E6%8C%87offer-15%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%AD1%E7%9A%84%E4%B8%AA%E6%95%B0/"/>
      <url>/2020/07/08/%E5%89%91%E6%8C%87offer-15%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%AD1%E7%9A%84%E4%B8%AA%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>请实现一个函数，输入一个整数，输出该数二进制表示中 1 的个数。例如，把 9 表示成二进制是 1001，有 2 位是 1。因此，如果输入 9，则该函数输出 2。</p><p>示例 1：<br>输入：00000000000000000000000000001011<br>输出：3<br>解释：输入的二进制串 00000000000000000000000000001011 中，共有三位为 ‘1’。<br>示例 2：<br>输入：00000000000000000000000010000000<br>输出：1<br>解释：输入的二进制串 00000000000000000000000010000000 中，共有一位为 ‘1’。<br>示例 3：<br>输入：11111111111111111111111111111101<br>输出：31<br>解释：输入的二进制串 11111111111111111111111111111101 中，共有 31 位为 ‘1’。<br>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/er-jin-zhi-zhong-1de-ge-shu-lcof" target="_blank" rel="noopener">https://leetcode-cn.com/problems/er-jin-zhi-zhong-1de-ge-shu-lcof</a></p><h1 id="知识回顾"><a href="#知识回顾" class="headerlink" title="知识回顾"></a>知识回顾</h1><ol><li><p>移位运算:<br>“&lt;&lt;”运算符<br>“&lt;&lt;”运算符执行左移位运算。在移位运算过程中，符号位始终保持不变。如果右侧空出位置，则自动填充为 0；超出 32 位的值，则自动丢弃。<br>“&gt;&gt;”运算符<br>“&gt;&gt;”运算符执行有符号右移位运算。与左移运算操作相反，它把 32 位数字中的所有有效位整体右移，再使用符号位的值填充空位。移动过程中超出的值将被丢弃。<br>“&gt;&gt;&gt;”运算符<br>“&gt;&gt;&gt;”运算符执行五符号右移位运算。它把无符号的 32 位整数所有数位整体右移。对于无符号数或正数右移运算，无符号右移与有符号右移运算的结果是相同的。</p></li><li><p>toString():<br>toString(num),这个把num传入一个number类型的数值，会直接转换成num进制的数 </p></li></ol><h1 id="算法分析-代码实现"><a href="#算法分析-代码实现" class="headerlink" title="算法分析+代码实现"></a>算法分析+代码实现</h1><ol><li><p>一般思路:先和1与,看最低位是否为0;然后和10与,看第二位是否为0…依次类推,直到最高位</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> hammingWeight = <span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> nums=<span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> flag=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(flag)&#123;</span><br><span class="line">        <span class="keyword">if</span>(n&amp;flag)&#123;</span><br><span class="line">            nums++</span><br><span class="line">        &#125;</span><br><span class="line">        flag = flag&lt;&lt;<span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>结果:<br>执行用时：68 ms, 在所有 JavaScript 提交中击败了97.77%的用户<br>内存消耗：35.3 MB, 在所有 JavaScript 提交中击败了100.00%的用户</p></li><li><p>优化思路:判断次数过多,尽可能优化判断次数<br>举个例子： 7的二进制位00111, 6的二进制位00110 ,那么00111&amp;00110=00110,我们发现n&amp;(n-1)每次可以消掉1个1,每次消掉一个1记录一下就可以统计出二进制中1的个数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> hammingWeight = <span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(n)&#123;</span><br><span class="line">        n=n&amp;(n<span class="number">-1</span>);</span><br><span class="line">        res++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>结果:<br>执行用时：84 ms, 在所有 JavaScript 提交中击败了50.70%的用户<br>内存消耗：35.4 MB, 在所有 JavaScript 提交中击败了100.00%的用户</p></li><li><p>新思路:利用toString()方法,将数转化为字符串,然后判断字符串中的数字</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> hammingWeight = <span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> str = n.toString(<span class="number">2</span>).toString()</span><br><span class="line">    <span class="keyword">let</span> nums = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; str.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">parseInt</span>(str[i]) === <span class="number">1</span>) &#123;</span><br><span class="line">            nums ++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>正则,正就完了</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> hammingWeight = <span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">   <span class="keyword">const</span> r =  n.toString(<span class="number">2</span>).match(<span class="regexp">/1/g</span>);</span><br><span class="line">    <span class="keyword">return</span> r ? r.length : <span class="number">0</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>结果:<br>执行用时：84 ms, 在所有 JavaScript 提交中击败了50.70%的用户<br>内存消耗：36 MB, 在所有 JavaScript 提交中击败了100.00%的用户</p></li></ol><h1 id="总结反思"><a href="#总结反思" class="headerlink" title="总结反思"></a>总结反思</h1><p>题目很简单,难在思考的角度</p><p>方法1和2 是基本方法,或者说没有用到语言特性的方法<br>方法3,4利用了js语言自带的函数,特性等</p><p>当面试手写代码时,可以主动去问一下面试官,需要哪种方法,常用的?还是说使用函数,但是使用函数的时候,要注意,自己是真的了解了函数的用法,要不然容易自己把自己带进沟里去.</p>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
          <category> 15二进制中1的个数 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 剑指offer </tag>
            
            <tag> 位运算 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer-14剪绳子</title>
      <link href="/2020/07/07/%E5%89%91%E6%8C%87offer-14%E5%89%AA%E7%BB%B3%E5%AD%90/"/>
      <url>/2020/07/07/%E5%89%91%E6%8C%87offer-14%E5%89%AA%E7%BB%B3%E5%AD%90/</url>
      
        <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n&gt;1并且m&gt;1），每段绳子的长度记为 k[0],k[1]…k[m-1] 。请问 k[0] * k[1]<em>…</em>k[m-1] 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。<br>示例 1：<br>输入: 2<br>输出: 1<br>解释: 2 = 1 + 1, 1 × 1 = 1<br>示例 2:<br>输入: 10<br>输出: 36<br>解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36<br>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/jian-sheng-zi-lcof" target="_blank" rel="noopener">https://leetcode-cn.com/problems/jian-sheng-zi-lcof</a></p><h1 id="知识回顾"><a href="#知识回顾" class="headerlink" title="知识回顾"></a>知识回顾</h1><p>1 动态规划：<br>如果面试题是求一个问题的<br>最优解(通常是求最大值或者最小值),而且该问题能够分解成若干个子问<br>题，并且子问题之间还有重叠的更小的子问题，就可以考虑用动态规划来<br>解决这个问题。</p><ul><li>求一个问题的最优解</li><li>整体问题的最优解是依赖各个子问题的最优解</li><li>大问题分解成若干个小问题，这些小问题之间还有相互重叠的更小的子问题</li><li>从上往下分析问题，从下往上求解问题<br>2 贪心算法：每一步都做最优解</li><li>需要通过数学方式来证明贪婪选择是正确的</li></ul><h1 id="算法分析-代码实现"><a href="#算法分析-代码实现" class="headerlink" title="算法分析+代码实现"></a>算法分析+代码实现</h1><p>1 动态规划：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> cuttingRope = <span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(n ==<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">3</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> max=[];</span><br><span class="line">    max[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    max[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    max[<span class="number">2</span>]=<span class="number">2</span>;</span><br><span class="line">    max[<span class="number">3</span>]=<span class="number">3</span>;</span><br><span class="line">    <span class="comment">//一直统计到长度为n时最优解</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i =<span class="number">4</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        max[i]=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">//当前长度为i时，从0，i到i/2，i/2不同切割方式寻找最优解</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> j=<span class="number">0</span>;j&lt;=<span class="built_in">Math</span>.floor(i/<span class="number">2</span>);j++)&#123;</span><br><span class="line">           bestRes = max[j]*max[i-j];</span><br><span class="line">           bestRes&gt;max[i]?max[i]= bestRes:<span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max[n]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>结果：时间复杂度为：O(n2);空间复杂度为O（n）,因为要存储子问题的最优解<br>执行用时：72 ms, 在所有 JavaScript 提交中击败了51.73%的用户<br>内存消耗：35.6 MB, 在所有 JavaScript 提交中击败了100.00%的用户</p><p>2 贪心算法：</p><p>原理：多分析，多总结<br>n&gt;=5时，3（n-3）&gt;=2(n-2)，即尽可能分多个三。当最后剩下1时，此时要把剩下的1和之前的3合并成4并分成2 * 2，因为2 * 2 &gt;3 * 1</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> cuttingRope = <span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(n ==<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">3</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//记录有几个三</span></span><br><span class="line">    <span class="keyword">let</span> m=<span class="built_in">Math</span>.floor(n/<span class="number">3</span>);</span><br><span class="line">    rest=n-m*<span class="number">3</span></span><br><span class="line">    <span class="keyword">if</span>(rest == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Math</span>.pow(<span class="number">3</span>,m)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(rest == <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Math</span>.pow(<span class="number">3</span>,m<span class="number">-1</span>)*<span class="number">4</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(rest == <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Math</span>.pow(<span class="number">3</span>,m)*<span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>结果：时间复杂度O（1）<br>执行用时：60 ms, 在所有 JavaScript 提交中击败了94.12%的用户<br>内存消耗：32.2 MB, 在所有 JavaScript 提交中击败了100.00%的用户</p>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
          <category> 14剪绳子 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 剑指offer </tag>
            
            <tag> 动态规划 </tag>
            
            <tag> 贪心算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer-13机器人运动范围</title>
      <link href="/2020/07/07/%E5%89%91%E6%8C%87offer-13%E6%9C%BA%E5%99%A8%E4%BA%BA%E8%BF%90%E5%8A%A8%E8%8C%83%E5%9B%B4/"/>
      <url>/2020/07/07/%E5%89%91%E6%8C%87offer-13%E6%9C%BA%E5%99%A8%E4%BA%BA%E8%BF%90%E5%8A%A8%E8%8C%83%E5%9B%B4/</url>
      
        <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>地上有一个m行n列的方格，从坐标 [0,0] 到坐标 [m-1,n-1] 。一个机器人从坐标 [0, 0] 的格子开始移动，它每次可以向左、右、上、下移动一格（不能移动到方格外），也不能进入行坐标和列坐标的数位之和大于k的格子。例如，当k为18时，机器人能够进入方格 [35, 37] ，因为3+5+3+7=18。但它不能进入方格 [35, 38]，因为3+5+3+8=19。请问该机器人能够到达多少个格子？<br>示例 1：<br>输入：m = 2, n = 3, k = 1<br>输出：3<br>示例 2：<br>输入：m = 3, n = 1, k = 0<br>输出：1<br>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof" target="_blank" rel="noopener">https://leetcode-cn.com/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof</a></p><h1 id="算法分析-代码实现"><a href="#算法分析-代码实现" class="headerlink" title="算法分析+代码实现"></a>算法分析+代码实现</h1><p>该题目可以看作是上一题的一个变型，算法思路就是回溯，走一步看四步</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> movingCount = <span class="function"><span class="keyword">function</span>(<span class="params">m, n, k</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//长宽有问题，返回null</span></span><br><span class="line">    <span class="keyword">if</span>(m&lt;=<span class="number">0</span>||n&lt;=<span class="number">0</span>||k&lt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//k为0,则不动</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(k === <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//设置计数数组</span></span><br><span class="line">    <span class="keyword">let</span> nums =[];</span><br><span class="line">    <span class="comment">//初始化方格</span></span><br><span class="line">    <span class="keyword">let</span> board = [];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">        board[i]=[]</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">            board[i][j]=<span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> fsp = <span class="function"><span class="keyword">function</span>(<span class="params">board,i,j,k</span>)</span>&#123;</span><br><span class="line">        sum = i%<span class="number">10</span>+<span class="built_in">Math</span>.floor(i/<span class="number">10</span>)+j%<span class="number">10</span>+<span class="built_in">Math</span>.floor(j/<span class="number">10</span>)</span><br><span class="line">        <span class="comment">//条件不符合，返回上一步</span></span><br><span class="line">        <span class="keyword">if</span>(i&lt;<span class="number">0</span>||i&gt;=m||j&lt;<span class="number">0</span>||j&gt;=n||board[i][j]==<span class="number">1</span>||sum&gt;k)&#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//没计数过</span></span><br><span class="line">        <span class="keyword">if</span>(board[i][j]==<span class="number">0</span>)&#123;   </span><br><span class="line">            board[i][j]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(sum&lt;=k)&#123;    </span><br><span class="line">                nums.push(i+<span class="string">''</span>+j)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//上下左右各走一次的</span></span><br><span class="line">        fsp(board,i<span class="number">-1</span>,j,k)</span><br><span class="line">        fsp(board,i+<span class="number">1</span>,j,k)</span><br><span class="line">        fsp(board,i,j<span class="number">-1</span>,k)</span><br><span class="line">        fsp(board,i,j+<span class="number">1</span>,k)</span><br><span class="line">    &#125;</span><br><span class="line">    fsp(board,<span class="number">0</span>,<span class="number">0</span>,k)</span><br><span class="line">    <span class="keyword">return</span> nums.length;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>结果：<br>执行用时：76 ms, 在所有 JavaScript 提交中击败了81.98%的用户<br>内存消耗：38.4 MB, 在所有 JavaScript 提交中击败了100.00%的用户</p><h1 id="总结反思"><a href="#总结反思" class="headerlink" title="总结反思"></a>总结反思</h1><p>1：提问：nums在哪？<br>在函数的闭包里<br>2: 写递归函数时一定要搞清楚判断条件，多想一想再写代码</p>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
          <category> 13机器人运动范围 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 剑指offer </tag>
            
            <tag> 回溯 </tag>
            
            <tag> 八皇后问题 </tag>
            
            <tag> 递归 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer-12矩阵中的路径</title>
      <link href="/2020/07/06/%E5%89%91%E6%8C%87offer-12%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E8%B7%AF%E5%BE%84/"/>
      <url>/2020/07/06/%E5%89%91%E6%8C%87offer-12%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E8%B7%AF%E5%BE%84/</url>
      
        <content type="html"><![CDATA[<h1 id="题目要求"><a href="#题目要求" class="headerlink" title="题目要求"></a>题目要求</h1><p>请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一格开始，每一步可以在矩阵中向左、右、上、下移动一格。如果一条路径经过了矩阵的某一格，那么该路径不能再次进入该格子。例如，在下面的3×4的矩阵中包含一条字符串“bfce”的路径（路径中的字母用加粗标出）。<br>[[“a”,”b”,”c”,”e”],<br>[“s”,”f”,”c”,”s”],<br>[“a”,”d”,”e”,”e”]]<br>但矩阵中不包含字符串“abfb”的路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入这个格子。<br>示例 1：<br>输入：board = [[“A”,”B”,”C”,”E”],[“S”,”F”,”C”,”S”],[“A”,”D”,”E”,”E”]], word = “ABCCED”<br>输出：true<br>示例 2：<br>输入：board = [[“a”,”b”],[“c”,”d”]], word = “abcd”<br>输出：false<br>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/ju-zhen-zhong-de-lu-jing-lcof" target="_blank" rel="noopener">https://leetcode-cn.com/problems/ju-zhen-zhong-de-lu-jing-lcof</a></p><h1 id="算法分析-代码实现"><a href="#算法分析-代码实现" class="headerlink" title="算法分析+代码实现"></a>算法分析+代码实现</h1><p>回溯法：当我们到达某一个节点时，尝试所有可能的选项，并在满足条件的前提下递归地抵达下一个节点</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> exist = <span class="function"><span class="keyword">function</span>(<span class="params">board, word</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> row = board.length;<span class="comment">//行</span></span><br><span class="line">    <span class="keyword">var</span> col = board[<span class="number">0</span>].length;<span class="comment">//列</span></span><br><span class="line">    <span class="comment">//board[i][j],index表示当前字符串匹配元素</span></span><br><span class="line">    <span class="keyword">var</span> dfs = <span class="function"><span class="keyword">function</span>(<span class="params">i,j,board,word,index</span>)</span>&#123;</span><br><span class="line">        <span class="comment">//条件不符合，返回false</span></span><br><span class="line">        <span class="keyword">if</span>(i&lt;<span class="number">0</span> || i&gt;=row || j&lt;<span class="number">0</span> || j&gt;=col || board[i][j]!== word[index])<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">//字符串匹配结束</span></span><br><span class="line">       <span class="keyword">if</span>(word.length<span class="number">-1</span> === index)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">//条件符合，将当前元素修改/锁住</span></span><br><span class="line">        <span class="keyword">var</span> tmp=board[i][j]</span><br><span class="line">        board[i][j]=<span class="string">'-'</span>;</span><br><span class="line">        <span class="comment">//上下左右递归执行一次算法，有可能上下左右越界，也可能字符串长度越界，所以最开始条件要加上</span></span><br><span class="line">        <span class="keyword">var</span> res = dfs(i<span class="number">-1</span>,j,board,word,index+<span class="number">1</span>) || dfs(i+<span class="number">1</span>,j,board,word,index+<span class="number">1</span>) || dfs(i,j<span class="number">-1</span>,board,word,index+<span class="number">1</span>)||dfs(i,j+<span class="number">1</span>,board,word,index+<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//将原矩阵还原</span></span><br><span class="line">        board[i][j]=tmp</span><br><span class="line">        <span class="comment">//返回递归结果</span></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历整个board，找到初始位置点</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>;i &lt; row; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; col; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(dfs(i,j,board,word,<span class="number">0</span>)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 没找到</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>结果：<br>执行用时：84 ms, 在所有 JavaScript 提交中击败了97.61%的用户<br>内存消耗：37.7 MB, 在所有 JavaScript 提交中击败了100.00%的用户</p>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
          <category> 12矩阵中的路径 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 剑指offer </tag>
            
            <tag> 回溯 </tag>
            
            <tag> 递归 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer-11旋转数组的最小数字</title>
      <link href="/2020/07/06/%E5%89%91%E6%8C%87offer-11%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97/"/>
      <url>/2020/07/06/%E5%89%91%E6%8C%87offer-11%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97/</url>
      
        <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。例如，数组 [3,4,5,1,2] 为 [1,2,3,4,5] 的一个旋转，该数组的最小值为1。<br>示例 1：<br>输入：[3,4,5,1,2]<br>输出：1<br>示例 2：<br>输入：[2,2,2,0,1]<br>输出：0<br>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof" target="_blank" rel="noopener">https://leetcode-cn.com/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof</a></p><h1 id="知识补充"><a href="#知识补充" class="headerlink" title="知识补充"></a>知识补充</h1><p>查找:<br>顺序查找(最普通),二分查找(本题目考察),哈希查找,二叉排序树查找<br>排序:<br>插入排序,冒泡排序,归并排序,快速排序</p><h1 id="算法分析-代码实现"><a href="#算法分析-代码实现" class="headerlink" title="算法分析+代码实现"></a>算法分析+代码实现</h1><p>1 利用顺序查找,遍历最小的值,然后返回</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> minArray = <span class="function"><span class="keyword">function</span>(<span class="params">numbers</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 直接返回空</span></span><br><span class="line">    <span class="keyword">if</span>(!numbers.length)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//长度为1</span></span><br><span class="line">    <span class="keyword">if</span>(numbers.length==<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> numbers[<span class="number">0</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 长度为2</span></span><br><span class="line">    <span class="keyword">if</span>(numbers.length==<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> numbers[<span class="number">0</span>]&gt;numbers[<span class="number">1</span>]?numbers[<span class="number">1</span>]:numbers[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 长度大于等于三</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">1</span>;i&lt;numbers.length;i++)&#123;</span><br><span class="line">        <span class="comment">// 直接比较到最后一个都没找出来，就比较第一个和最后一个</span></span><br><span class="line">        <span class="keyword">if</span>(i==(numbers.length<span class="number">-1</span>))&#123;</span><br><span class="line">        <span class="keyword">return</span> numbers[<span class="number">0</span>]&gt;numbers[i]?numbers[i]:numbers[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 找出该数，该数字满足大于前一个，小于或者等于后一个</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(numbers[i<span class="number">-1</span>]&gt;numbers[i]&amp;&amp;numbers[i]&lt;=numbers[i+<span class="number">1</span>])&#123;</span><br><span class="line">            <span class="keyword">return</span> numbers[i]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>结果:平均时间复杂度为O(n/2),最差时间复杂度为O(n)<br>执行用时：80 ms, 在所有 JavaScript 提交中击败了32.19%的用户<br>内存消耗：35.4 MB, 在所有 JavaScript 提交中击败了100.00%的用户</p><p>2 二分查找</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> minArray = <span class="function"><span class="keyword">function</span>(<span class="params">numbers</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//空数组，直接返回null</span></span><br><span class="line">    <span class="keyword">if</span>(!numbers.length)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> index1 = <span class="number">0</span>;<span class="comment">//第一个指针</span></span><br><span class="line">    <span class="keyword">let</span> index2 = numbers.length<span class="number">-1</span><span class="comment">//第二个指针</span></span><br><span class="line">    <span class="keyword">let</span> indexMid = index1;<span class="comment">//中间指针</span></span><br><span class="line">    <span class="comment">// 指针未重合</span></span><br><span class="line">    <span class="keyword">while</span>(index1 != index2)&#123;</span><br><span class="line">        <span class="comment">//更新中间值</span></span><br><span class="line">        indexMid = <span class="built_in">Math</span>.floor((index1+index2)/<span class="number">2</span>)</span><br><span class="line">        <span class="comment">//如果中间值处在index1的递增部分时，跟新index1的值为indexmid</span></span><br><span class="line">        <span class="keyword">if</span>(numbers[index1]&gt;numbers[indexMid])&#123;</span><br><span class="line">            index2=indexMid</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果中间值处在index2的递增部分时，更新index2的值为indexmid</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(numbers[index2]&lt;numbers[indexMid])&#123;</span><br><span class="line">            index1=indexMid+<span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果出现相等情况时，将index2向左移动一位，再进行判断，</span></span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            index2--</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> numbers[index2]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>结果:<br>执行用时：64 ms, 在所有 JavaScript 提交中击败了92.32%的用户<br>内存消耗：33.4 MB, 在所有 JavaScript 提交中击败了100.00%的用户</p>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
          <category> 11旋转数组最小数字 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 剑指offer </tag>
            
            <tag> 查找和排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer-10斐波那契数列</title>
      <link href="/2020/07/05/%E5%89%91%E6%8C%87offer-10%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/"/>
      <url>/2020/07/05/%E5%89%91%E6%8C%87offer-10%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>写一个函数，输入 n ，求斐波那契（Fibonacci）数列的第 n 项。斐波那契数列的定义如下：</p><p>F(0) = 0,   F(1) = 1<br>F(N) = F(N - 1) + F(N - 2), 其中 N &gt; 1.<br>斐波那契数列由 0 和 1 开始，之后的斐波那契数就是由之前的两数相加而得出。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/fei-bo-na-qi-shu-lie-lcof" target="_blank" rel="noopener">https://leetcode-cn.com/problems/fei-bo-na-qi-shu-lie-lcof</a></p><h1 id="算法分析-代码实现"><a href="#算法分析-代码实现" class="headerlink" title="算法分析+代码实现"></a>算法分析+代码实现</h1><p>1 暴力算法（直接超时）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fib = <span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(n==<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> fib(n<span class="number">-1</span>)+fib(n<span class="number">-2</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>为什么会超时？对于同一数字，会重复递归，增加时间和空间的开销</p><p>2 从头开始算,每个值只算一次这样就避免了重复递归<br>解法1：使用数组，但是增加了开销</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fib = <span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> i=[<span class="number">0</span>,<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">if</span>(n&lt;<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> i[n]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(i.length&lt;n+<span class="number">1</span>)&#123;</span><br><span class="line">        i.push((i[i.length<span class="number">-1</span>]+i[i.length<span class="number">-2</span>])%(<span class="number">1e9</span>+<span class="number">7</span>))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i.pop();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>结果：<br>执行用时：84 ms, 在所有 JavaScript 提交中击败了10.18%的用户<br>内存消耗：32.2 MB, 在所有 JavaScript 提交中击败了100.00%的用户<br>解法2：不使用数组</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fib = <span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> i=[<span class="number">0</span>,<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">if</span>(n&lt;<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> i[n]</span><br><span class="line">    &#125;</span><br><span class="line">    fibone = i[<span class="number">0</span>];</span><br><span class="line">    fibtwo = i[<span class="number">1</span>];</span><br><span class="line">    fibn = <span class="number">0</span>; </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> j=<span class="number">2</span>;j&lt;=n;++j)&#123;</span><br><span class="line">        fibn = (fibone +fibtwo)%(<span class="number">1e9</span>+<span class="number">7</span>);</span><br><span class="line">        fibone = fibtwo</span><br><span class="line">        fibtwo = fibn</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> fibn;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>结果：</p><p>执行用时：72 ms, 在所有 JavaScript 提交中击败了38.25%的用户<br>内存消耗：31.9 MB, 在所有 JavaScript 提交中击败了100.00%的用户</p><h1 id="青蛙跳台阶问题："><a href="#青蛙跳台阶问题：" class="headerlink" title="青蛙跳台阶问题："></a>青蛙跳台阶问题：</h1><p>经分析后，我们可以得知：该问题是斐波那契数列的一个变种问题</p><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。<br>答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。<br>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/qing-wa-tiao-tai-jie-wen-ti-lcof" target="_blank" rel="noopener">https://leetcode-cn.com/problems/qing-wa-tiao-tai-jie-wen-ti-lcof</a></p>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
          <category> 斐波那契数列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 剑指offer </tag>
            
            <tag> 斐波那契数列 </tag>
            
            <tag> 递归 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer-09用两个栈实现队列</title>
      <link href="/2020/07/05/%E5%89%91%E6%8C%87offer-09%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/"/>
      <url>/2020/07/05/%E5%89%91%E6%8C%87offer-09%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，deleteHead 操作返回 -1 )<br>示例1：<br>输入：<br>[“CQueue”,”appendTail”,”deleteHead”,”deleteHead”]<br>[[],[3],[],[]]<br>输出：[null,null,3,-1]<br>示例2：<br>输入：<br>[“CQueue”,”deleteHead”,”appendTail”,”appendTail”,”deleteHead”,”deleteHead”]<br>[[],[],[5],[2],[],[]]<br>输出：[null,-1,null,null,5,2]</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof" target="_blank" rel="noopener">https://leetcode-cn.com/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof</a></p><h1 id="算法分析-代码实现"><a href="#算法分析-代码实现" class="headerlink" title="算法分析+代码实现"></a>算法分析+代码实现</h1><p>栈：先进后出<br>队列：后进先出<br>1 js思路，js里面可以使用数组的reserve（）方法直接实现队列功能</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> CQueue = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//定义两个个数组</span></span><br><span class="line">    <span class="keyword">this</span>.stack=[]</span><br><span class="line">    <span class="keyword">this</span>.queue=[]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">value</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;void&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">CQueue.prototype.appendTail = <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//将入队值放入栈中</span></span><br><span class="line">    <span class="keyword">this</span>.stack.push(value)</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">CQueue.prototype.deleteHead = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果队列不为空</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>.queue.length)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.queue.pop()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果队列为空，则需要将栈中元素入队</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(<span class="keyword">this</span>.stack.length&amp;&amp; !<span class="keyword">this</span>.queue.length)&#123;</span><br><span class="line">        <span class="comment">// 栈元素倒序入队</span></span><br><span class="line">        <span class="keyword">this</span>.queue = <span class="keyword">this</span>.stack</span><br><span class="line">        <span class="keyword">this</span>.queue.reverse()</span><br><span class="line">        <span class="keyword">this</span>.stack=[]</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.queue.pop()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果栈和队都为空，则返回-1</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(!<span class="keyword">this</span>.stack.length&amp;&amp;!<span class="keyword">this</span>.queue.length)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>结果：<br>执行用时：488 ms, 在所有 JavaScript 提交中击败了71.96%的用户<br>内存消耗：47.5 MB, 在所有 JavaScript 提交中击败了100.00%的用户</p>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
          <category> 09用两个栈实现队列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 剑指offer </tag>
            
            <tag> 栈 </tag>
            
            <tag> 队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer-08二叉树的下一个节点</title>
      <link href="/2020/07/04/%E5%89%91%E6%8C%87offer-08%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E8%8A%82%E7%82%B9/"/>
      <url>/2020/07/04/%E5%89%91%E6%8C%87offer-08%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E8%8A%82%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一棵二叉树和其中的一个节点，如何找出中序遍历的下一个节点？树中的节点除了有两个分别指向左右子节点的指针，还有一个指向父节点的指针</p><h1 id="算法分析-代码实现"><a href="#算法分析-代码实现" class="headerlink" title="算法分析+代码实现"></a>算法分析+代码实现</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">GetNext</span>(<span class="params">pNode</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//如果该节点为空</span></span><br><span class="line">    <span class="keyword">if</span>（pNode===<span class="literal">null</span>）&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果该节点存在右子树，则下一节点是其右子树的最左子节点</span></span><br><span class="line">    <span class="keyword">if</span>（pNode.right!= <span class="literal">null</span>）&#123;</span><br><span class="line">        pNode=pNode.right;</span><br><span class="line">        <span class="keyword">while</span>(pNode.left!=<span class="literal">null</span>)&#123;</span><br><span class="line">          pNode = pNode.left</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pNode;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果该节点没有右子树，且是该父节点的左子节点，则下一节点是其父节点</span></span><br><span class="line">    <span class="keyword">if</span>（pNode.next.left ===pNode&amp;&amp;pNode.right==<span class="literal">null</span>）&#123;</span><br><span class="line">        <span class="keyword">return</span> pNode.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果该节点没有右子节点，且是该父节点的右子节点</span></span><br><span class="line">    <span class="comment">//则需要从上遍历，直到找到一个是其父节点的左子节点的节点</span></span><br><span class="line">    <span class="comment">//则所找到的节点的父节点是该节点的下一节点，找不到就说明没有下一节点</span></span><br><span class="line">     <span class="keyword">if</span>（pNode.next.right ===pNode&amp;&amp;pNode.right==<span class="literal">null</span>）&#123;</span><br><span class="line">        pNode = pNode.next;</span><br><span class="line">         <span class="comment">//不是根节点</span></span><br><span class="line">         <span class="keyword">while</span>（pNode.next!=<span class="literal">null</span>）&#123;</span><br><span class="line">             <span class="comment">//该节点是其父节点的左子节点</span></span><br><span class="line">             <span class="keyword">if</span>(pNode.next.left==pNode)&#123;</span><br><span class="line">                 <span class="keyword">return</span> pNode</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="keyword">else</span> pNode = pNode.next</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">//已经是根节点。则该节点不存在下一节点</span></span><br><span class="line">         <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
          <category> 08二叉树的下一个节点 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 剑指offer </tag>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>google上不去？</title>
      <link href="/2020/07/04/google%E4%B8%8A%E4%B8%8D%E5%8E%BB%EF%BC%9F/"/>
      <url>/2020/07/04/google%E4%B8%8A%E4%B8%8D%E5%8E%BB%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<p>最近在上Google时发现自己上不去Google了，然后就开始了头铁的解决之路</p><h1 id="尝试1"><a href="#尝试1" class="headerlink" title="尝试1:"></a>尝试1:</h1><p>以为是vps的节点问题，更换了多次节点，发现还是没用，人都傻了。<br>然后我就想，这个机场出问题了？应该不会吧.。。<br>又顺手尝试了一下YouTube，发现YouTube可以顺利打开，这下人又傻了，那这是什么问题？</p><h1 id="尝试2"><a href="#尝试2" class="headerlink" title="尝试2"></a>尝试2</h1><p>我去电报群里面问了一下，大家说，可能是代理的问题，因为如果不开代理的话，你是无法访问外网的。<br>我说实话一直就不理解代理是什么意思，只是知道从哪里开，哪里关。<br>然后各种开开关关，发现关了代理的话YouTube也上不去了，这肯定不对<br>这就说明了和代理没问题</p><h1 id="尝试3"><a href="#尝试3" class="headerlink" title="尝试3"></a>尝试3</h1><p>大家都沉默了一段时候以后，救星出现了，他说：这是ssr的问题，之前他也出现过这种情况，修改一下系统代理模式，由全局换到自定义就好了。<br>至此，顺利解决</p><h1 id="后记："><a href="#后记：" class="headerlink" title="后记："></a>后记：</h1><p>当救星说出是ssr问题的时候，我立马从Google找到了相关问题以及下方的解决方案。<br>解答链接<a href="https://github.com/shadowsocksrr/shadowsocksr-csharp/issues/119" target="_blank" rel="noopener">https://github.com/shadowsocksrr/shadowsocksr-csharp/issues/119</a></p><p>说起来惭愧，这学期的网络原理就没学多少东西。而在使用vpn的时候，出现的问题绝大部分都是网络问题。只有了解网络知识，才能更好的解决方案。<br>对症下药，总得先明白症状才行。</p><p>不多说了，好好学习网络原理吧。</p>]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vpn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer-07重建二叉树</title>
      <link href="/2020/07/04/%E5%89%91%E6%8C%87offer-07%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
      <url>/2020/07/04/%E5%89%91%E6%8C%87offer-07%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>输入某二叉树的前序遍历和中序遍历的结果，请重建该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。<br>例如，给出<br>前序遍历 preorder = [3,9,20,15,7]<br>中序遍历 ignorer = [9,3,15,20,7]<br>返回如下的二叉树：</p><p>  3<br>  /  <br> 9   20<br>  /    <br> 15   7</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof" target="_blank" rel="noopener">https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof</a></p><h1 id="知识回顾"><a href="#知识回顾" class="headerlink" title="知识回顾"></a>知识回顾</h1><p>二叉树：树的一种特殊形式，每个节点最多只有两个子节点（下图为例）<br>前序遍历：先访问根节点，再访问左子节点，后访问右子节点<br>遍历顺序：10，6，4，8，14，12，16<br>中序遍历：先访问左子节点，再访问根节点，后访问右子节点<br>遍历顺序：4，6，8，10，12，14，16<br>后序遍历：先访问左子节点，再访问右子节点，后访问根节点<br>遍历顺序：4，8，6，12，16，14，10<br>宽度优先遍历：先访问书的第一层节点，再访问树的第二层节点，直到访问树的<br>遍历顺序：10，6，14，4，8，12，16<br>最后一层节点<br>    10<br>   /  <br>  6         14<br> /   \         /     <br>4     8     12     16</p><h1 id="算法分析-代码实现"><a href="#算法分析-代码实现" class="headerlink" title="算法分析+代码实现"></a>算法分析+代码实现</h1><p>1 通用递归算法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> buildTree = <span class="function"><span class="keyword">function</span>(<span class="params">preorder, inorder</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果前序遍历数组为零，则返回空</span></span><br><span class="line">    <span class="keyword">if</span>(!preorder.length)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 先构建根节点</span></span><br><span class="line">    <span class="keyword">let</span> rootNode = <span class="keyword">new</span> TreeNode(preorder[<span class="number">0</span>]);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//创建左子树的前序遍历数组</span></span><br><span class="line">    preorderLeft=preorder.slice(<span class="number">1</span>,inorder.indexOf(preorder[<span class="number">0</span>])+<span class="number">1</span>)</span><br><span class="line">    <span class="comment">// 创建左子树的中序遍历数组</span></span><br><span class="line">    inorderLeft = inorder.slice(<span class="number">0</span>,inorder.indexOf(preorder[<span class="number">0</span>]))</span><br><span class="line">    rootNode.left = buildTree(preorderLeft,inorderLeft)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建右子树的前序遍历</span></span><br><span class="line">    preorderRight = preorder.slice(inorder.indexOf(preorder[<span class="number">0</span>])+<span class="number">1</span>)</span><br><span class="line">    <span class="comment">// 创建右子树的中序遍历</span></span><br><span class="line">    inorderRight  = inorder.slice(inorder.indexOf(preorder[<span class="number">0</span>])+<span class="number">1</span>)</span><br><span class="line">    rootNode.right = buildTree(preorderRight,inorderRight)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> rootNode;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>注意：使用递归时，要给每一个变量定义类型，var，let都行<br>防止其成为全局变量，污染整个环境</p><p>结果:<br>执行用时：200 ms, 在所有 JavaScript 提交中击败了11.79%的用户<br>内存消耗：111.4 MB, 在所有 JavaScript 提交中击败了100.00%的用户<br>优化：<br>slice方法会增加新的数组，可以记录下开头和结尾，节省时间和空间<br>只改参数，不改数组</p>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
          <category> 07重建二叉树 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树 </tag>
            
            <tag> 递归 </tag>
            
            <tag> 树的遍历 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer-06从尾到头打印链表</title>
      <link href="/2020/07/01/%E5%89%91%E6%8C%87offer-06%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8/"/>
      <url>/2020/07/01/%E5%89%91%E6%8C%87offer-06%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。<br>示例 ：<br>输入：head = [1,3,2]<br>输出：[2,3,1]<br><a href="https://leetcode-cn.com/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof/</a></p><h1 id="算法分析-代码实现"><a href="#算法分析-代码实现" class="headerlink" title="算法分析+代码实现"></a>算法分析+代码实现</h1><p>最简单的做法就是调用数组的resver方法，先把链表的所有值从头到尾打印到数组中，然后调用resver方法，将数组中的内容倒序</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> reversePrint = <span class="function"><span class="keyword">function</span>(<span class="params">head</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> num = [],flag = <span class="literal">true</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(flag&amp;&amp;head)&#123;</span><br><span class="line">        <span class="keyword">if</span>(head.next==<span class="literal">null</span>)&#123;</span><br><span class="line">            num.push(head.val)     </span><br><span class="line">            flag =<span class="literal">false</span>;        </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;           </span><br><span class="line">            num.push(head.val)</span><br><span class="line">            head = head.next </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> num.reverse()</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>结果：时间复杂度为O（n），空间复杂度为O(1)<br>执行用时：80 ms, 在所有 JavaScript 提交中击败了65.64%的用户<br>内存消耗：36.9 MB, 在所有 JavaScript 提交中击败了100.00%的用户</p>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
          <category> 06从尾到头打印链表 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 剑指offer </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer-05替换空格</title>
      <link href="/2020/06/30/%E5%89%91%E6%8C%87offer-05%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC/"/>
      <url>/2020/06/30/%E5%89%91%E6%8C%87offer-05%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC/</url>
      
        <content type="html"><![CDATA[<h1 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h1><p> 请实现一个函数，把字符串 s 中的每个空格替换成”%20”。<br>示例：<br>输入：s = “We are happy.”<br>输出：”We%20are%20happy.”</p><h1 id="算法分析-代码实现"><a href="#算法分析-代码实现" class="headerlink" title="算法分析+代码实现"></a>算法分析+代码实现</h1><p>目的：代码量最少</p><p>1 利用字符串的split()和数组的join()方法<br>Split() 方法使用指定的分隔符字符串将一个String对象分割成子字符串数组，以一个指定的分割字串来决定每个拆分的位置<br>join() 方法将一个数组（或一个类数组对象）的所有元素连接成一个字符串并返回这个字符串。如果数组只有一个项目，那么将返回该项目而不使用分隔符。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> replaceSpace = <span class="function"><span class="keyword">function</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s.split(<span class="string">' '</span>).join(<span class="string">'%20'</span>)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>结果：<br>执行用时：76 ms, 在所有 JavaScript 提交中击败了19.36%的用户<br>内存消耗：32.2 MB, 在所有 JavaScript 提交中击败了100.00%的用户</p><p>2 利用正则表达式<br>这是必须想到的方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> replaceSpace = <span class="function"><span class="keyword">function</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s.replace(<span class="regexp">/ /g</span>,<span class="string">'%20'</span>)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>结果：</p><p>执行用时：68 ms, 在所有 JavaScript 提交中击败了56.01%的用户<br>内存消耗：32.2 MB, 在所有 JavaScript 提交中击败了100.00%的用户</p><p>3 利用双指针，也就是想考察的方法<br>注意一点：两个指针，分别用来表示原字符串的末尾位置和新字符串的末尾位置</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> replaceSpace = <span class="function"><span class="keyword">function</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> blank=<span class="number">0</span><span class="comment">//记录空格数</span></span><br><span class="line">    <span class="keyword">for</span>(i <span class="keyword">in</span> s)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i]==<span class="string">' '</span>)</span><br><span class="line">        blank++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> index1=s.length<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">let</span> index2=s.length+<span class="number">2</span>*blank<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">let</span> l=[]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(index1&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="keyword">if</span>(s[index1]!=<span class="string">' '</span>)&#123;</span><br><span class="line">            l[index2]=s[index1];</span><br><span class="line">            index2--;</span><br><span class="line">            index1--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            l[index2]=<span class="number">0</span></span><br><span class="line">            index2--</span><br><span class="line">            l[index2]=<span class="number">2</span></span><br><span class="line">            index2--</span><br><span class="line">            l[index2]=<span class="string">'%'</span></span><br><span class="line">            index2--</span><br><span class="line">            index1--</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l.join(<span class="string">''</span>)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>结果：<br>执行用时：64 ms, 在所有 JavaScript 提交中击败了76.80%的用户<br>内存消耗：32.5 MB, 在所有 JavaScript 提交中击败了100.00%的用户</p>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
          <category> 05替换空格 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 剑指offer </tag>
            
            <tag> 双指针 </tag>
            
            <tag> 正则 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer-04二维数组中的查找</title>
      <link href="/2020/06/30/%E5%89%91%E6%8C%87offer-04%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE/"/>
      <url>/2020/06/30/%E5%89%91%E6%8C%87offer-04%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE/</url>
      
        <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p><p>示例:<br>现有矩阵 matrix 如下：<br>[<br>  [1,   4,  7, 11, 15],<br>  [2,   5,  8, 12, 19],<br>  [3,   6,  9, 16, 22],<br>  [10, 13, 14, 17, 24],<br>  [18, 21, 23, 26, 30]<br>]<br>给定 target = 5，返回 true。<br>给定 target = 20，返回 false。</p><p>链接：<a href="https://leetcode-cn.com/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof" target="_blank" rel="noopener">https://leetcode-cn.com/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof</a></p><h1 id="算法分析-代码实现"><a href="#算法分析-代码实现" class="headerlink" title="算法分析+代码实现"></a>算法分析+代码实现</h1><p>1 我的第一思路，是根据对角线的值来逼近，确定值可能得范围<br>最后确定出其所处位置必定为两个对角线所在线段的夹角区域<br>然后遍历两个区域来寻找</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;matrix.length<span class="number">-1</span>;i++)&#123;</span><br><span class="line">            <span class="comment">// 两个对角线的值，将该函数确定在两个小矩阵范围内</span></span><br><span class="line">            <span class="keyword">if</span>(target&gt;=matrix[i][i]&amp;&amp;target&lt;=matrix[i+<span class="number">1</span>][i+<span class="number">1</span>])&#123;</span><br><span class="line">                <span class="built_in">console</span>.log(matrix.length)</span><br><span class="line">                <span class="comment">// 遍历左下方矩阵：matrix[i+1~length-1][0~i]</span></span><br><span class="line">                <span class="comment">//遍历右上方矩阵matrix[0~i][i+1~length]</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">let</span> k=i+<span class="number">1</span>;k&lt;matrix.length;k++)&#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">let</span> j=<span class="number">0</span>;j&lt;i+<span class="number">1</span>;j++)&#123;</span><br><span class="line">                        <span class="keyword">if</span>(target == matrix[k][j])&#123;</span><br><span class="line">                            <span class="built_in">console</span>.log(<span class="string">"找到："</span>)</span><br><span class="line">                            <span class="built_in">console</span>.log(<span class="string">"matrix["</span>+k+<span class="string">"]["</span>+j+<span class="string">"]:"</span>+matrix[k][j])</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span>(target == matrix[j][k])&#123;</span><br><span class="line">                            <span class="built_in">console</span>.log(<span class="string">"找到："</span>)</span><br><span class="line">                            <span class="built_in">console</span>.log(<span class="string">"matrix["</span>+j+<span class="string">"]["</span>+k+<span class="string">"]:"</span>+matrix[j][k])</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>2 判断右上角或者左下角的值，一次排除一列或者一行</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> findNumberIn2DArray = <span class="function"><span class="keyword">function</span>(<span class="params">matrix, target</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> result = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">if</span>(matrix!= [])&#123;</span><br><span class="line">    <span class="keyword">let</span> j=matrix.length<span class="number">-1</span></span><br><span class="line">    <span class="keyword">while</span>(j&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">//如果比当前行最小值都小，舍弃当前行</span></span><br><span class="line">        <span class="keyword">if</span>(target &lt;matrix[j])&#123;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">let</span> k=j;k&gt;=<span class="number">0</span>;k--)&#123;</span><br><span class="line">                <span class="keyword">if</span>(matrix[k].includes(target))&#123;</span><br><span class="line">                    result = <span class="literal">true</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果不存在，则跳出循环</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;          </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>利用了js数组中的includes（）方法，<br>表面时间复杂度为：O(n)<br>其实时间复杂度为O(n2)<br>结果如下：<br>执行用时：88 ms, 在所有 JavaScript 提交中击败了26.54%的用户<br>内存消耗：34.9 MB, 在所有 JavaScript 提交中击败了100.00%的用户</p><p>3 暴力降维，由二维转化为一维<br>利用es6的…运算符+数组的push方法<br>数组的contac方法也可以</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> findNumberIn2DArray = <span class="function"><span class="keyword">function</span>(<span class="params">matrix, target</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> arr=[]</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i =<span class="number">0</span>;i&lt;matrix.length;i++)&#123;</span><br><span class="line">        arr.push(...matrix[i])</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr.includes(target)    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>结果：时间复杂度为：O（n）空间复杂度为：O(n2)<br>执行用时：84 ms, 在所有 JavaScript 提交中击败了35.65%的用户<br>内存消耗：38.1 MB, 在所有 JavaScript 提交中击败了100.00%的用户</p>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
          <category> 04-二维数组中的查找 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 剑指offer </tag>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我的云之路-ECS简介</title>
      <link href="/2020/06/29/%E6%88%91%E7%9A%84%E4%BA%91%E4%B9%8B%E8%B7%AF-ECS%E7%AE%80%E4%BB%8B/"/>
      <url>/2020/06/29/%E6%88%91%E7%9A%84%E4%BA%91%E4%B9%8B%E8%B7%AF-ECS%E7%AE%80%E4%BB%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是ECS"><a href="#什么是ECS" class="headerlink" title="什么是ECS"></a>什么是ECS</h1><p>云服务器( Elastic Compute Service ,简称ECS )是一种简单高效、处理能力可弹性伸缩的计算服务,帮助您快速构建更稳定、安全的应用,提升运维效率,降低IT成本,使您更专注于核心业务创新。</p><h1 id="应用的基础运行环境"><a href="#应用的基础运行环境" class="headerlink" title="应用的基础运行环境"></a>应用的基础运行环境</h1><p>每个ECS实例上都运行着用户选择的操作系统,-般是某 个Linux或Windows的发行版,用户的应用程序运行在实例的操作系统之上。</p><h1 id="ECS的弹性伸缩"><a href="#ECS的弹性伸缩" class="headerlink" title="ECS的弹性伸缩"></a>ECS的弹性伸缩</h1><p>ECS的最重要的特点是弹性,支持纵向和横向扩展两种能力。<br>纵向的弹性,即单个服务器的配置变更。<br>横向的弹性。对于游戏应用或直播平台出现的高峰期,云计算可以使用弹性的方式帮助客户度过这样的高峰。当业务高峰消失时,可以将多余的资源释放掉,以减少业务成本的开支。</p><h1 id="优势（和传统服务器相比）"><a href="#优势（和传统服务器相比）" class="headerlink" title="优势（和传统服务器相比）"></a>优势（和传统服务器相比）</h1><p>稳定<br>实例可用性达99.95% ,云盘数据可靠性不低于999999%<br>自动者机迁移，自动快照备份(需手动配快照策略) . 数据恢复更方便</p><p>弹性<br>白由配置CPU.内存、带宽,可随时升级<br>升级配置数据不丢失,业务暂停时间可控</p><p>安全<br>免费提供DDoS防护、木马查杀，防暴力破解等服务<br>可轻松实现多用户对多服务器的访问控制</p><p>成本<br>高性价比,支持包年包月或按量计费，满足不同需求<br>无需服务器网络和硬件等维护, 0成本运维</p><p>易用性<br>丰富的操作系统和应用软件，通过境像可-键简单部署<br>同一境像可在多台ECS中快速复制环境,轻松扩展</p><p>可拓展性<br>ECS可与阿里云各种丰富的云产品无缝街接<br>可持续为业务发展提供完整的计算，存储、安全等解决方案</p>]]></content>
      
      
      <categories>
          
          <category> 我的云之路 </category>
          
          <category> ECS简介 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ECS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ES6-扩展部分</title>
      <link href="/2020/06/26/ES6-%E6%89%A9%E5%B1%95%E9%83%A8%E5%88%86/"/>
      <url>/2020/06/26/ES6-%E6%89%A9%E5%B1%95%E9%83%A8%E5%88%86/</url>
      
        <content type="html"><![CDATA[<h1 id="字符串扩展"><a href="#字符串扩展" class="headerlink" title="字符串扩展"></a>字符串扩展</h1><ol><li>includes(str) : 判断是否包含指定的字符串</li><li>startsWith(str) : 判断是否以指定字符串开头</li><li>endsWith(str) : 判断是否以指定字符串结尾</li><li>repeat(count) : 重复指定次数<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">'abcdefg'</span>;</span><br><span class="line">   <span class="built_in">console</span>.log(str.includes(<span class="string">'a'</span>));<span class="comment">//true</span></span><br><span class="line">   <span class="built_in">console</span>.log(str.includes(<span class="string">'h'</span>));<span class="comment">//false</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">//startsWith(str) : 判断是否以指定字符串开头</span></span><br><span class="line">   <span class="built_in">console</span>.log(str.startsWith(<span class="string">'a'</span>));<span class="comment">//true</span></span><br><span class="line">   <span class="built_in">console</span>.log(str.startsWith(<span class="string">'d'</span>));<span class="comment">//false</span></span><br><span class="line">   <span class="comment">//endsWith(str) : 判断是否以指定字符串结尾</span></span><br><span class="line">   <span class="built_in">console</span>.log(str.endsWith(<span class="string">'g'</span>));<span class="comment">//true</span></span><br><span class="line">   <span class="built_in">console</span>.log(str.endsWith(<span class="string">'d'</span>));<span class="comment">//false</span></span><br><span class="line">   <span class="comment">//repeat(count) : 重复指定次数a</span></span><br><span class="line">   <span class="built_in">console</span>.log(str.repeat(<span class="number">5</span>));</span><br></pre></td></tr></table></figure><h1 id="数值扩展"><a href="#数值扩展" class="headerlink" title="数值扩展"></a>数值扩展</h1></li><li>二进制与八进制数值表示法: 二进制用0b, 八进制用0o</li><li>Number.isFinite(i) : 判断是否是有限大的数</li><li>Number.isNaN(i) : 判断是否是NaN</li><li>Number.isInteger(i) : 判断是否是整数</li><li>Number.parseInt(str) : 将字符串转换为对应的数值</li><li>Math.trunc(i) : 直接去除小数部分<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">0b1010</span>);<span class="comment">//10</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">0o56</span>);<span class="comment">//46</span></span><br><span class="line"><span class="comment">//Number.isFinite(i) : 判断是否是有限大的数</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>.isFinite(<span class="literal">NaN</span>));<span class="comment">//false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>.isFinite(<span class="number">5</span>));<span class="comment">//true</span></span><br><span class="line"><span class="comment">//Number.isNaN(i) : 判断是否是NaN</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>.isNaN(<span class="literal">NaN</span>));<span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>.isNaN(<span class="number">5</span>));<span class="comment">//falsse</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Number.isInteger(i) : 判断是否是整数</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>.isInteger(<span class="number">5.23</span>));<span class="comment">//false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>.isInteger(<span class="number">5.0</span>));<span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>.isInteger(<span class="number">5</span>));<span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Number.parseInt(str) : 将字符串转换为对应的数值</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>.parseInt(<span class="string">'123abc'</span>));<span class="comment">//123</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>.parseInt(<span class="string">'a123abc'</span>));<span class="comment">//NaN</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Math.trunc(i) : 直接去除小数部分</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.trunc(<span class="number">13.123</span>));<span class="comment">//13</span></span><br></pre></td></tr></table></figure><h1 id="数组扩展"><a href="#数组扩展" class="headerlink" title="数组扩展"></a>数组扩展</h1></li><li>Array.from(v) : 将伪数组对象或可遍历对象转换为真数组</li><li>Array.of(v1, v2, v3) : 将一系列值转换成数组</li><li>find(function(value, index, arr){return true}) : 找出第一个满足条件返回true的元素</li><li>findIndex(function(value, index, arr){return true}) : 找出第一个满足条件返回true的元素下标<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Array.from(v) : 将伪数组对象或可遍历对象转换为真数组</span></span><br><span class="line">    <span class="keyword">let</span> btns = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'button'</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(btns.length);<span class="comment">//3</span></span><br><span class="line">    <span class="built_in">Array</span>.from(btns).forEach(<span class="function"><span class="keyword">function</span> (<span class="params">item, index</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(item, index);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">//Array.of(v1, v2, v3) : 将一系列值转换成数组</span></span><br><span class="line">    <span class="keyword">let</span> arr = <span class="built_in">Array</span>.of(<span class="number">1</span>, <span class="string">'abc'</span>, <span class="literal">true</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(arr);</span><br><span class="line">    <span class="comment">//find(function(value, index, arr)&#123;return true&#125;) : 找出第一个满足条件返回true的元素</span></span><br><span class="line">    <span class="keyword">let</span> arr1 = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">3</span>];</span><br><span class="line">    <span class="keyword">let</span> result = arr1.find(<span class="function"><span class="keyword">function</span> (<span class="params">item, index</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> item &gt;<span class="number">3</span></span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">console</span>.log(result);<span class="comment">//5</span></span><br><span class="line">    <span class="comment">//findIndex(function(value, index, arr)&#123;return true&#125;) : 找出第一个满足条件返回true的元素下标</span></span><br><span class="line">    <span class="keyword">let</span> result1 = arr1.findIndex(<span class="function"><span class="keyword">function</span> (<span class="params">item, index</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> item &gt;<span class="number">3</span></span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">console</span>.log(result1);<span class="comment">//2</span></span><br></pre></td></tr></table></figure><h1 id="对象扩展"><a href="#对象扩展" class="headerlink" title="对象扩展"></a>对象扩展</h1></li><li>Object.is(v1, v2): 判断2个数据是否完全相等<br>根据字符串编码来确定是否相等<br>注意与==，===区分<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.is(<span class="string">'abc'</span>, <span class="string">'abc'</span>));<span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">NaN</span> == <span class="literal">NaN</span>);<span class="comment">//false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.is(<span class="literal">NaN</span>, <span class="literal">NaN</span>));<span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">0</span> == <span class="number">-0</span>);<span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.is(<span class="number">0</span>, <span class="number">-0</span>));<span class="comment">//false</span></span><br></pre></td></tr></table></figure></li><li>Object.assign(target, source1, source2..):将源对象的属性复制到目标对象上<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;<span class="attr">name</span> : <span class="string">'kobe'</span>, <span class="attr">age</span> : <span class="number">39</span>, <span class="attr">c</span>: &#123;<span class="attr">d</span>: <span class="number">2</span>&#125;&#125;;</span><br><span class="line"><span class="keyword">let</span> obj1 = &#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.assign(obj1, obj);</span><br><span class="line"><span class="built_in">console</span>.log(obj1, obj1.name);</span><br></pre></td></tr></table></figure></li><li>直接操作 <strong>proto</strong> 属性<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj2 = &#123;&#125;;</span><br><span class="line">obj2.__proto__ = obj1;</span><br><span class="line"><span class="keyword">let</span> obj3 = &#123;<span class="attr">name</span> : <span class="string">'anverson'</span>, <span class="attr">age</span> : <span class="number">41</span>&#125;;</span><br><span class="line"><span class="keyword">let</span> obj4 = &#123;&#125;;</span><br><span class="line">obj4.__proto__ = obj3;</span><br><span class="line"><span class="built_in">console</span>.log(obj4, obj4.name, obj4.age);</span><br></pre></td></tr></table></figure><h1 id="深度克隆deepclone"><a href="#深度克隆deepclone" class="headerlink" title="深度克隆deepclone"></a>深度克隆deepclone</h1>基本数据</li></ol><ul><li>据分为基本的数据类型(String, Number, boolean, Null, Undefined)和对象数据类型<br>基本数据类型：<br>特点： 存储的是该对象的实际数据<br>对象数据类型：<br>特点： 存储的是该对象在栈中引用，真实的数据存放在堆内存里<h2 id="复制数据"><a href="#复制数据" class="headerlink" title="复制数据"></a>复制数据</h2>基本数据类型存放的就是实际的数据，可直接复制<br>let number2 = 2;<br>let number1 = number2;<h2 id="克隆数据：对象-数组"><a href="#克隆数据：对象-数组" class="headerlink" title="克隆数据：对象/数组"></a>克隆数据：对象/数组</h2>1、区别： 浅拷贝/深度拷贝<br>判断： 拷贝是否产生了新的数据还是拷贝的是数据的引用<br>知识点：对象数据存放的是对象在栈内存的引用，直接复制的是对象的引用<br>let obj = {username: ‘kobe’}<br>let obj1 = obj; // obj1 复制了obj在栈内存的引用<br>2、常用的拷贝技术<br>1). arr.concat(): 数组浅拷贝<br>2). arr.slice(): 数组浅拷贝<br>3). JSON.parse(JSON.stringify(arr/obj)): 数组或对象深拷贝, 但不能处理函数数据<br>4). 浅拷贝包含函数数据的对象/数组<br>5). 深拷贝包含函数数据的对象/数组</li></ul><h1 id="set和map容器"><a href="#set和map容器" class="headerlink" title="set和map容器"></a>set和map容器</h1><h2 id="Set容器"><a href="#Set容器" class="headerlink" title="Set容器 :"></a>Set容器 :</h2><p>无序不可重复的多个value的集合体</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Set()</span></span><br><span class="line"><span class="comment">//Set(array)</span></span><br><span class="line"><span class="comment">//add(value)</span></span><br><span class="line"><span class="comment">//delete(value)</span></span><br><span class="line"><span class="comment">//has(value)</span></span><br><span class="line"><span class="comment">//clear()</span></span><br><span class="line">* size</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">set</span> = new Set([1,2,3,4,3,2,1,6]);</span><br><span class="line">console.log(<span class="keyword">set</span>);</span><br><span class="line"><span class="keyword">set</span>.add('abc');</span><br><span class="line">console.log(<span class="keyword">set</span>, <span class="keyword">set</span>.size);</span><br><span class="line">//delete(value)</span><br><span class="line"><span class="keyword">set</span>.delete(2);</span><br><span class="line">console.log(<span class="keyword">set</span>);</span><br><span class="line">//has(value)</span><br><span class="line">console.log(<span class="keyword">set</span>.has(2));//false</span><br><span class="line">console.log(<span class="keyword">set</span>.has(1));//true</span><br><span class="line">//clear()</span><br><span class="line"><span class="keyword">set</span>.clear();</span><br><span class="line">console.log(<span class="keyword">set</span>);</span><br></pre></td></tr></table></figure><h2 id="Map容器"><a href="#Map容器" class="headerlink" title="Map容器 :"></a>Map容器 :</h2><p>无序的 key不重复的多个key-value的集合体</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Map()</span></span><br><span class="line"><span class="comment">//Map(array)</span></span><br><span class="line"><span class="comment">//set(key, value)//添加</span></span><br><span class="line"><span class="comment">//get(key)</span></span><br><span class="line"><span class="comment">//delete(key)</span></span><br><span class="line"><span class="comment">//has(key)</span></span><br><span class="line"><span class="comment">// clear()</span></span><br><span class="line"><span class="comment">//size</span></span><br><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>([[<span class="string">'abc'</span>, <span class="number">12</span>],[<span class="number">25</span>, <span class="string">'age'</span>]]);</span><br><span class="line"><span class="built_in">console</span>.log(map);</span><br><span class="line">map.set(<span class="string">'男'</span>, <span class="string">'性别'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(map);</span><br><span class="line"><span class="built_in">console</span>.log(map.get(<span class="number">25</span>));<span class="comment">//age</span></span><br><span class="line"><span class="comment">//delete(key)</span></span><br><span class="line">map.delete(<span class="string">'男'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(map);</span><br><span class="line"><span class="built_in">console</span>.log(map.has(<span class="string">'男'</span>));<span class="comment">//false</span></span><br><span class="line"><span class="built_in">console</span>.log(map.has(<span class="string">'abc'</span>));<span class="comment">//true</span></span><br><span class="line">map.clear();</span><br><span class="line"><span class="built_in">console</span>.log(map);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ES6 </category>
          
          <category> 扩展部分 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ES6扩展 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ES6-ES5回顾</title>
      <link href="/2020/06/22/ES6-ES5%E5%9B%9E%E9%A1%BE/"/>
      <url>/2020/06/22/ES6-ES5%E5%9B%9E%E9%A1%BE/</url>
      
        <content type="html"><![CDATA[<h1 id="严格模式"><a href="#严格模式" class="headerlink" title="严格模式"></a>严格模式</h1><p>这种模式使得Javascript在更严格的语法条件下运行</p><p>目的(作用)</p><ul><li>消除Javascript语法的一些不合理、不严谨之处，减少一些怪异行为</li><li>消除代码运行的一些不安全之处，为代码的安全运行保驾护航</li><li>为未来新版本的Javascript做好铺垫</li></ul><p>使用</p><ul><li>在全局或函数的第一条语句定义为: ‘use strict’;</li><li>如果浏览器不支持, 只解析为一条简单的语句, 没有任何副作用</li></ul><p>语法和行为改变</p><ul><li>必须用var声明变量</li><li>对象不能有重名的属性</li><li>禁止自定义的函数中的this指向window</li><li>创建eval作用域</li></ul><blockquote><p>eval()方法，可以解析传入eval函数的代码执行语句<br>eval(‘alert(name)’)，代码会执行<br>如果不开全局模式，eval内部定义的变量，默认为全局变量<br>会污染作用域，同时容易被恶意代码攻击</p></blockquote><h1 id="json对象"><a href="#json对象" class="headerlink" title="json对象"></a>json对象</h1><ol><li>JSON.stringify(obj/arr):js对象(数组)转换为json对象(数组)</li><li>JSON.parse(json):json对象(数组)转换为js对象(数组)</li></ol><h1 id="object对象扩展"><a href="#object对象扩展" class="headerlink" title="object对象扩展"></a>object对象扩展</h1><ol><li>Object.create(prototype, [descriptors])<br>作用: 以指定对象为原型创建新的对象,为新的对象指定新的属性, 并对属性进行描述<br>参数:<br>value : 指定值<br>writable : 标识当前属性值是否是可修改的, 默认为false<br>configurable: 标识当前属性是否可以被删除 默认为false<br>enumerable： 标识当前属性是否能用for in 枚举 默认为false<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;<span class="attr">name</span> : <span class="string">'curry'</span>, <span class="attr">age</span> : <span class="number">29</span>&#125;</span><br><span class="line"><span class="keyword">var</span> obj1 = &#123;&#125;;</span><br><span class="line">obj1 = <span class="built_in">Object</span>.create(obj, &#123;</span><br><span class="line">    sex : &#123;</span><br><span class="line">        value : <span class="string">'男'</span>,</span><br><span class="line">        writable : <span class="literal">true</span><span class="comment">//该属性可修改</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">obj1.sex = <span class="string">'女'</span>;<span class="comment">//</span></span><br><span class="line"><span class="built_in">console</span>.log(obj1.sex);</span><br><span class="line"><span class="comment">//writable属性为false时，无法修改sex属性，为true时才可修改</span></span><br></pre></td></tr></table></figure></li><li>Object.defineProperties(object, descriptors)<br>作用: 为指定对象定义扩展多个属性<br>get ：用来获取当前属性值的回调函数<br>set ：修改当前属性值时触发的回调函数，并且实参即为修改后的值<br>存取器属性：setter,getter一个用来存值，一个用来取值<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj2 = &#123;</span><br><span class="line">        firstName : <span class="string">'curry'</span>,</span><br><span class="line">        lastName : <span class="string">'stephen'</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperties(obj2, &#123;</span><br><span class="line">    fullName : &#123;</span><br><span class="line">        <span class="keyword">get</span> : function () &#123;</span><br><span class="line">        <span class="comment">//获取该属性值时，该函数自动调用</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.firstName + <span class="string">'-'</span> + <span class="keyword">this</span>.lastName</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="keyword">set</span> : function (data) &#123;</span><br><span class="line">        <span class="comment">//修改该属性值时，该函数自动调用</span></span><br><span class="line">            <span class="keyword">var</span> names = data.split(<span class="string">'-'</span>);</span><br><span class="line">            <span class="keyword">this</span>.firstName = names[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">this</span>.lastName = names[<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(obj2.fullName);</span><br><span class="line">obj2.firstName = <span class="string">'tim'</span>;</span><br><span class="line">obj2.lastName = <span class="string">'duncan'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(obj2.fullName);</span><br><span class="line">obj2.fullName = <span class="string">'kobe-bryant'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(obj2.fullName);</span><br></pre></td></tr></table></figure>对象本身的两个方法:<br>get propertyName(){} 用来得到当前属性值的回调函数<br>set propertyName(){} 用来监视当前属性值变化的回调函数<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">        firstName : <span class="string">'kobe'</span>,</span><br><span class="line">        lastName : <span class="string">'bryant'</span>,</span><br><span class="line">        <span class="keyword">get</span> fullName()&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.firstName + <span class="string">' '</span> + <span class="keyword">this</span>.lastName</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="keyword">set</span> fullName(data)&#123;</span><br><span class="line">            <span class="keyword">var</span> names = data.split(<span class="string">' '</span>);</span><br><span class="line">            <span class="keyword">this</span>.firstName = names[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">this</span>.lastName = names[<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">console</span>.log(obj.fullName);</span><br><span class="line">    obj.fullName = <span class="string">'curry stephen'</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(obj.fullName);</span><br></pre></td></tr></table></figure></li></ol><h1 id="Array的扩展"><a href="#Array的扩展" class="headerlink" title="Array的扩展"></a>Array的扩展</h1><ol><li>Array.prototype.indexOf(value) : 得到值在数组中的第一个下标</li><li>Array.prototype.lastIndexOf(value) : 得到值在数组中的最后一个下标</li><li>Array.prototype.forEach(function(item, index){}) : 遍历数组</li><li>Array.prototype.map(function(item, index){}) : 遍历数组返回一个新的数组，返回加工之后的值</li><li>Array.prototype.filter(function(item, index){}) : 遍历过滤出一个新的子数组， 返回条件为true的值<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">6</span>];</span><br><span class="line">    <span class="built_in">console</span>.log(arr.indexOf(<span class="number">6</span>));<span class="comment">//2</span></span><br><span class="line">    <span class="comment">//Array.prototype.lastIndexOf(value) : 得到值在数组中的最后一个下标</span></span><br><span class="line">    <span class="built_in">console</span>.log(arr.lastIndexOf(<span class="number">6</span>));<span class="comment">//5</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//Array.prototype.forEach(function(item, index)&#123;&#125;) : 遍历数组</span></span><br><span class="line">    arr.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">item, index</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(item, index);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Array.prototype.map(function(item, index)&#123;&#125;) : 遍历数组返回一个新的数组，返回加工之后的值</span></span><br><span class="line">    <span class="keyword">var</span> arr1 = arr.map(<span class="function"><span class="keyword">function</span> (<span class="params">item, index</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> item + <span class="number">10</span></span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">console</span>.log(arr, arr1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Array.prototype.filter(function(item, index)&#123;&#125;) : 遍历过滤出一个新的子数组， 返回条件为true的值</span></span><br><span class="line">    <span class="keyword">var</span> arr2 = arr.filter(<span class="function"><span class="keyword">function</span> (<span class="params">item, index</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> item &gt; <span class="number">4</span></span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">console</span>.log(arr, arr2);</span><br></pre></td></tr></table></figure></li></ol><h1 id="Function扩展"><a href="#Function扩展" class="headerlink" title="Function扩展"></a>Function扩展</h1><ol><li>Function.prototype.bind(obj) : 将函数内的this绑定为obj, 并将函数返回</li><li>面试题: 区别bind()与call()和apply()?<ul><li>都能指定函数中的this</li><li>call()/apply()是立即调用函数</li><li>bind()是将函数返回</li></ul></li><li>需要传入参数时<ul><li>call()直接从第二个参数开始，依次传入</li><li>apply()第二参数必须是数组，传入放在数组里<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun</span>(<span class="params">age</span>) </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>.name = <span class="string">'kobe'</span>;</span><br><span class="line">       <span class="keyword">this</span>.age = age;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line">   fun.bind(obj, <span class="number">12</span>)();<span class="comment">//直接自调用bind返回函数</span></span><br><span class="line">   fun.call(obj,<span class="number">33</span>);</span><br><span class="line">   <span class="built_in">console</span>.log(obj.age);<span class="comment">//输出为33</span></span><br><span class="line">   <span class="comment">//fun.apply(obj,33);//报错</span></span><br><span class="line">   fun.apply(obj,[<span class="number">33</span>]);<span class="comment">//</span></span><br><span class="line">   <span class="built_in">console</span>.log(obj.age);<span class="comment">//输出为33</span></span><br></pre></td></tr></table></figure></li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> ES6 </category>
          
          <category> ES5回顾 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ES6 </tag>
            
            <tag> ES5 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ES6-常用关键字和方法</title>
      <link href="/2020/06/22/ES6-%E5%B8%B8%E7%94%A8%E5%8F%98%E5%8C%96/"/>
      <url>/2020/06/22/ES6-%E5%B8%B8%E7%94%A8%E5%8F%98%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h1 id="let-const关键字"><a href="#let-const关键字" class="headerlink" title="let const关键字"></a>let const关键字</h1><h2 id="let"><a href="#let" class="headerlink" title="let"></a>let</h2><p>作用：与var类似, 用于声明一个变量<br>特点：<br>在块作用域内有效<br>不能重复声明<br>不会预处理, 不存在提升</p><p>应用：</p><p>循环遍历加监听<br>使用let取代var是趋势</p><h2 id="const"><a href="#const" class="headerlink" title="const"></a>const</h2><p>作用: 定义一个常量<br>特点:</p><p>不能修改<br>其它特点同let</p><p>应用: 保存不用改变的数据</p><h1 id="变量的解构赋值"><a href="#变量的解构赋值" class="headerlink" title="变量的解构赋值"></a>变量的解构赋值</h1><p>从对象或数组中提取数据, 并赋值给变量(多个)<br>解构赋值：先解析结构，再赋值内容<br>用途：给多个形参赋值</p><h2 id="对象的解构赋值"><a href="#对象的解构赋值" class="headerlink" title="对象的解构赋值"></a>对象的解构赋值</h2><p>根据对象的属性名来取值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123;n, a&#125; = &#123;<span class="attr">n</span>:<span class="string">'tom'</span>, <span class="attr">a</span>:<span class="number">12</span>&#125;</span><br></pre></td></tr></table></figure><h2 id="数组的解构赋值"><a href="#数组的解构赋值" class="headerlink" title="数组的解构赋值"></a>数组的解构赋值</h2><p>根据数组下标来取值，可以通过添加逗号来顺延所取的内容</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [a,b] = [<span class="number">1</span>, <span class="string">'atguigu'</span>];</span><br></pre></td></tr></table></figure><h1 id="模板字符串"><a href="#模板字符串" class="headerlink" title="模板字符串"></a>模板字符串</h1><p>目的：简化字符串拼接</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">let</span> obj = &#123;</span><br><span class="line">     name : <span class="string">'anverson'</span>,</span><br><span class="line">     age : <span class="number">41</span></span><br><span class="line"> &#125;;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">'我叫:'</span> + obj.name + <span class="string">', 我的年龄是：'</span> + obj.age);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模板字符串必须用 `` 包含</span></span><br><span class="line"><span class="comment">//变化的部分使用$&#123;xxx&#125;定义</span></span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">`我叫:<span class="subst">$&#123;obj.name&#125;</span>, 我的年龄是：<span class="subst">$&#123;obj.age&#125;</span>`</span>);</span><br></pre></td></tr></table></figure><h1 id="简化的对象写法"><a href="#简化的对象写法" class="headerlink" title="简化的对象写法"></a>简化的对象写法</h1><p>省略同名的属性值<br>省略方法的function</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">let</span> x = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">let</span> y = <span class="number">5</span>;</span><br><span class="line">    <span class="comment">//普通额写法</span></span><br><span class="line"><span class="comment">//    let obj = &#123;</span></span><br><span class="line"><span class="comment">//        x : x,</span></span><br><span class="line"><span class="comment">//        y : y,</span></span><br><span class="line"><span class="comment">//        getPoint : function () &#123;</span></span><br><span class="line"><span class="comment">//            return this.x + this.y</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//    &#125;;</span></span><br><span class="line">    <span class="comment">//简化的写法</span></span><br><span class="line">    <span class="keyword">let</span> obj = &#123;</span><br><span class="line">        x,</span><br><span class="line">        y,</span><br><span class="line">        getPoint()&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.x</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">console</span>.log(obj, obj.getPoint());</span><br></pre></td></tr></table></figure><h1 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h1><p>多用来定义回调函数</p><h2 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h2><ul><li>简洁</li><li>箭头函数没有自己的this，箭头函数的this不是调用的时候决定的，而是在定义的时候处在的对象就是它的this</li><li>扩展理解： 箭头函数的this看外层的是否有函数，<br>  如果有，外层函数的this就是内部箭头函数的this，<br>  如果没有，则this是window。<h2 id="语法："><a href="#语法：" class="headerlink" title="语法："></a>语法：</h2></li><li>没有参数: () =&gt; console.log(‘xxxx’)</li><li>一个参数: i =&gt; i+2</li><li>大于一个参数: (i,j) =&gt; i+j</li><li>函数体不用大括号: 默认返回结果</li><li>函数体如果有多个语句, 需要用{}包围，若有需要返回的内容，需要手动返回<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> fun = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">       <span class="built_in">console</span>.log(<span class="string">'fun()'</span>);</span><br><span class="line">&#125;;</span><br><span class="line">fun();</span><br><span class="line"><span class="comment">//形参数量：</span></span><br><span class="line"><span class="comment">//1 没有形参，并且函数体只有一条语句</span></span><br><span class="line"><span class="keyword">let</span> fun1 = <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'fun1()'</span>);</span><br><span class="line">fun1();</span><br><span class="line"><span class="built_in">console</span>.log(fun1());</span><br><span class="line"><span class="comment">//2 一个形参，并且函数体只有一条语句</span></span><br><span class="line"><span class="keyword">let</span> fun2 = <span class="function"><span class="params">x</span> =&gt;</span> x;</span><br><span class="line"><span class="built_in">console</span>.log(fun2(<span class="number">5</span>));</span><br><span class="line"><span class="comment">//3 形参是一个以上</span></span><br><span class="line"><span class="keyword">let</span> fun3 = <span class="function">(<span class="params">x, y</span>) =&gt;</span> x + y;</span><br><span class="line"><span class="built_in">console</span>.log(fun3(<span class="number">25</span>, <span class="number">39</span>));<span class="comment">//64</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//函数语句数量：</span></span><br><span class="line"><span class="comment">//1 函数体有多条语句</span></span><br><span class="line"><span class="keyword">let</span> fun4 = <span class="function">(<span class="params">x, y</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(x, y);</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(fun4(<span class="number">34</span>, <span class="number">48</span>));<span class="comment">//82</span></span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">&#125;,<span class="number">1000</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">'btn'</span>);</span><br><span class="line"><span class="comment">//2 没有箭头函数</span></span><br><span class="line">btn.onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="keyword">this</span>);<span class="comment">//btn</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//3 箭头函数</span></span><br><span class="line"><span class="keyword">let</span> btn2 = <span class="built_in">document</span>.getElementById(<span class="string">'btn2'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    name : <span class="string">'kobe'</span>,</span><br><span class="line">    age : <span class="number">39</span>,</span><br><span class="line">    getName : <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        btn2.onclick = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="keyword">this</span>);<span class="comment">//obj</span></span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">obj.getName();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="keyword">this</span>.obj = &#123;</span><br><span class="line">     showThis : <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">         <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> fun5 = <span class="keyword">new</span> Person();</span><br><span class="line">fun5.obj.showThis();</span><br></pre></td></tr></table></figure></li></ul><h1 id="点点点（…）运算符"><a href="#点点点（…）运算符" class="headerlink" title="点点点（…）运算符"></a>点点点（…）运算符</h1><h2 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h2><ol><li><p>rest(可变)参数</p><ul><li>用来取代arguments</li><li>但比arguments灵活</li><li>只能是最后部分形参参数<br>arguments:函数的形参伪数组，内部存放了函数的形参的值<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun</span>(<span class="params">...values</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">arguments</span>);</span><br><span class="line"><span class="comment">//        arguments.forEach(function (item, index) &#123;</span></span><br><span class="line"><span class="comment">//            console.log(item, index);</span></span><br><span class="line"><span class="comment">//        &#125;);</span></span><br><span class="line">        <span class="built_in">console</span>.log(values);</span><br><span class="line">        values.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">item, index</span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(item, index);</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    fun(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br></pre></td></tr></table></figure></li></ul></li><li><p>扩展运算符</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>];</span><br><span class="line"><span class="keyword">let</span> arr1 = [<span class="string">'abc'</span>,...arr, <span class="string">'fg'</span>];</span><br><span class="line"><span class="built_in">console</span>.log(arr1);<span class="comment">//'abc',2,3,4,5,6, 'fg'</span></span><br></pre></td></tr></table></figure><h1 id="形参默认值"><a href="#形参默认值" class="headerlink" title="形参默认值"></a>形参默认值</h1><p>当不传入参数的时候默认使用形参里的默认值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Point</span>(<span class="params">x = <span class="number">1</span>,y = <span class="number">2</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.x = x;</span><br><span class="line">    <span class="keyword">this</span>.y = y;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ol><h1 id="Promise对象"><a href="#Promise对象" class="headerlink" title="Promise对象"></a>Promise对象</h1><ol><li>理解:<ul><li>Promise对象: 代表了未来某个将要发生的事件(通常是一个异步操作)</li><li>有了promise对象, 可以将异步操作以同步的流程表达出来, 避免了层层嵌套的回调函数(俗称’回调地狱’)</li><li>ES6的Promise是一个构造函数, 用来生成promise实例</li></ul></li><li>使用promise基本步骤(2步):<br>创建promise对象</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">       <span class="comment">//初始化promise状态为 pending</span></span><br><span class="line">     <span class="comment">//执行异步操作</span></span><br><span class="line">     <span class="keyword">if</span>(异步操作成功) &#123;</span><br><span class="line">       resolve(value);<span class="comment">//修改promise的状态为fullfilled</span></span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       reject(errMsg);<span class="comment">//修改promise的状态为rejected</span></span><br><span class="line">     &#125;</span><br><span class="line">   &#125;)</span><br></pre></td></tr></table></figure><p>调用promise的then()</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">promise.then(<span class="function"><span class="keyword">function</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">result =&gt; console.log(result</span>),</span></span><br><span class="line"><span class="function"><span class="title">errorMsg</span> =&gt; <span class="title">alert</span>(<span class="params">errorMsg</span>)</span></span><br><span class="line"><span class="function">))</span></span><br></pre></td></tr></table></figure><ol start="3"><li>promise对象的3个状态<br>pending: 初始化状态<br>fullfilled: 成功状态(也可以称作resolved)<br>rejected: 失败状态</li><li>应用:<br>实现超时处理<br>封装处理ajax请求<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> request = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">  request.onreadystatechange = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  &#125;</span><br><span class="line">  request.responseType = <span class="string">'json'</span>;</span><br><span class="line">  request.open(<span class="string">"GET"</span>, url);</span><br><span class="line">  request.send();</span><br></pre></td></tr></table></figure></li></ol><h1 id="Symbol"><a href="#Symbol" class="headerlink" title="Symbol"></a>Symbol</h1><h2 id="概念："><a href="#概念：" class="headerlink" title="概念："></a>概念：</h2><p>ES6中的添加了一种原始数据类型symbol(已有的原始数据类型：String, Number, boolean, null, undefined, 对象)</p><h2 id="特点：-1"><a href="#特点：-1" class="headerlink" title="特点："></a>特点：</h2><p>1、Symbol属性对应的值是唯一的，解决命名冲突问题<br>2、Symbol值不能与其他数据进行计算，包括同字符串拼串<br>3、for in, for of遍历时不会遍历symbol属性。</p><h2 id="使用："><a href="#使用：" class="headerlink" title="使用："></a>使用：</h2><p>1、调用Symbol函数得到symbol值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> symbol = <span class="built_in">Symbol</span>();</span><br><span class="line"><span class="keyword">let</span> obj = &#123;&#125;;</span><br><span class="line">obj[symbol] = <span class="string">'hello'</span>;</span><br></pre></td></tr></table></figure><p>2、传参标识</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> symbol = <span class="built_in">Symbol</span>(<span class="string">'one'</span>);</span><br><span class="line"><span class="keyword">let</span> symbol2 = <span class="built_in">Symbol</span>(<span class="string">'two'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(symbol);<span class="comment">// Symbol('one')</span></span><br><span class="line"><span class="built_in">console</span>.log(symbol2);<span class="comment">// Symbol('two')</span></span><br></pre></td></tr></table></figure><p>3、内置Symbol值</p><ul><li>除了定义自己使用的Symbol值以外，ES6还提供了11个内置的Symbol值，指向语言内部使用的方法。</li></ul><ul><li>Symbol.iterator</li></ul><ul><li>对象的Symbol.iterator属性，指向该对象的默认遍历器方法(后边讲)</li></ul><h1 id="Iterator遍历器"><a href="#Iterator遍历器" class="headerlink" title="Iterator遍历器"></a>Iterator遍历器</h1><p>iterator是一种接口机制，为各种不同的数据结构提供统一的访问机制</p><h2 id="作用："><a href="#作用：" class="headerlink" title="作用："></a>作用：</h2><p>1、为各种数据结构，提供一个统一的、简便的访问接口；<br>2、使得数据结构的成员能够按某种次序排列<br>3、ES6创造了一种新的遍历命令for…of循环，Iterator接口主要供for…of消费。</p><h2 id="工作原理："><a href="#工作原理：" class="headerlink" title="工作原理："></a>工作原理：</h2><p>1、 创建一个指针对象，指向数据结构的起始位置。<br>2、第一次调用next方法，指针自动指向数据结构的第一个成员<br>3、 接下来不断调用next方法，指针会一直往后移动，直到指向最后一个成员<br>4、 每调用next方法返回的是一个包含value和done的对象，{value: 当前成员的值,done: 布尔值}</p><p>value表示当前成员的值，done对应的布尔值表示当前的数据的结构是否遍历结束。<br>当遍历结束的时候返回的value值是undefined，done值为true。</p><h2 id="原生具备iterator接口的数据-可用for-of遍历"><a href="#原生具备iterator接口的数据-可用for-of遍历" class="headerlink" title="原生具备iterator接口的数据(可用for of遍历)"></a>原生具备iterator接口的数据(可用for of遍历)</h2><p>1、Array<br>2、arguments<br>3、set容器<br>4、map容器<br>5、String</p><h1 id="Generator函数"><a href="#Generator函数" class="headerlink" title="Generator函数"></a>Generator函数</h1><h2 id="概念：-1"><a href="#概念：-1" class="headerlink" title="概念："></a>概念：</h2><p>1、ES6提供的解决异步编程的方案之一<br>2、Generator函数是一个状态机，内部封装了不同状态的数据，<br>3、用来生成遍历器对象<br>4、可暂停函数(惰性求值), yield可暂停，next方法可启动。每次返回的是yield后的表达式结果</p><h2 id="特点：-2"><a href="#特点：-2" class="headerlink" title="特点："></a>特点：</h2><p>1、function 与函数名之间有一个星号<br>2、内部用yield表达式来定义不同的状态<br>3、generator函数返回的是指针对象(接11章节里iterator)，而不会执行函数内部逻辑<br>4、调用next方法函数内部逻辑开始执行，遇到yield表达式停止，返回{value: yield后的表达式结果/undefined, done: false/true}<br>5、再次调用next方法会从上一次停止时的yield处开始，直到最后<br>6、yield语句返回结果通常为undefined， 当调用next方法时传参内容会作为启动时yield语句的返回值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 小试牛刀</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span>* <span class="title">generatorTest</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'函数开始执行'</span>);</span><br><span class="line">      <span class="keyword">yield</span> <span class="string">'hello'</span>;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'函数暂停后再次启动'</span>);</span><br><span class="line">      <span class="keyword">yield</span> <span class="string">'generator'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 生成遍历器对象</span></span><br><span class="line">    <span class="keyword">let</span> Gt = generatorTest();</span><br><span class="line">    <span class="comment">// 执行函数，遇到yield后即暂停</span></span><br><span class="line">    <span class="built_in">console</span>.log(Gt); <span class="comment">// 遍历器对象</span></span><br><span class="line">    <span class="keyword">let</span> result = Gt.next(); <span class="comment">// 函数执行,遇到yield暂停</span></span><br><span class="line">    <span class="built_in">console</span>.log(result); <span class="comment">// &#123;value: "hello", done: false&#125;</span></span><br><span class="line">    result = Gt.next(); <span class="comment">// 函数再次启动</span></span><br><span class="line">    <span class="built_in">console</span>.log(result); <span class="comment">// &#123;value: 'generator', done: false&#125;</span></span><br><span class="line">    result = Gt.next();</span><br><span class="line">    <span class="built_in">console</span>.log(result); <span class="comment">// &#123;value: undefined, done: true&#125;表示函数内部状态已经遍历完毕</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对象的Symbol.iterator属性;</span></span><br><span class="line">    <span class="keyword">let</span> myIterable = &#123;&#125;;</span><br><span class="line">    myIterable[<span class="built_in">Symbol</span>.iterator] = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">      <span class="keyword">yield</span> <span class="number">4</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i <span class="keyword">of</span> myIterable)&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> obj = [...myIterable];</span><br><span class="line">    <span class="built_in">console</span>.log(obj);</span><br></pre></td></tr></table></figure><h1 id="async函数-源自ES2017"><a href="#async函数-源自ES2017" class="headerlink" title="async函数(源自ES2017)"></a>async函数(源自ES2017)</h1><h2 id="概念：-2"><a href="#概念：-2" class="headerlink" title="概念："></a>概念：</h2><p>真正意义上去解决异步回调的问题，同步流程表达异步操作<br>本质： Generator的语法糖</p><h2 id="语法：-1"><a href="#语法：-1" class="headerlink" title="语法："></a>语法：</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">await</span> 异步操作;</span><br><span class="line">    <span class="keyword">await</span> 异步操作；</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="特点：-3"><a href="#特点：-3" class="headerlink" title="特点："></a>特点：</h2><p>1、不需要像Generator去调用next方法，遇到await等待，当前的异步操作完成就往下执行<br>2、返回的总是Promise对象，可以用then方法进行下一步操作<br>3、async取代Generator函数的星号，await取代Generator的yield<br>4、语意上更为明确，使用简单，经临床验证，暂时没有任何副作用</p><h1 id="class-ES6；ES2015"><a href="#class-ES6；ES2015" class="headerlink" title="class(ES6；ES2015)"></a>class(ES6；ES2015)</h1><ol><li>通过class定义类/实现类的继承</li><li>在类中通过constructor定义构造方法</li><li>通过new来创建类的实例</li><li>通过extends来实现类的继承</li><li>通过super调用父类的构造方法</li><li>重写从父类中继承的一般方法<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">        <span class="comment">//调用类的构造方法</span></span><br><span class="line">        <span class="keyword">constructor</span>(name, age)&#123;</span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">            <span class="keyword">this</span>.age = age;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//定义一般的方法</span></span><br><span class="line">        showName()&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="keyword">this</span>.name, <span class="keyword">this</span>.age);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> person = <span class="keyword">new</span> Person(<span class="string">'kobe'</span>, <span class="number">39</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(person, person.showName());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义一个子类</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">StrPerson</span> <span class="keyword">extends</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">        <span class="keyword">constructor</span>(name, age, salary)&#123;</span><br><span class="line">            <span class="keyword">super</span>(name, age);<span class="comment">//调用父类的构造方法</span></span><br><span class="line">            <span class="keyword">this</span>.salary = salary;</span><br><span class="line">        &#125;</span><br><span class="line">        showName()&#123;<span class="comment">//在子类自身定义方法</span></span><br><span class="line">            <span class="built_in">console</span>.log(<span class="keyword">this</span>.name, <span class="keyword">this</span>.age, <span class="keyword">this</span>.salary);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> str = <span class="keyword">new</span> StrPerson(<span class="string">'weide'</span>, <span class="number">38</span>, <span class="number">1000000000</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(str);</span><br><span class="line">    str.showName();</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> ES6 </category>
          
          <category> 常用关键字和方法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ES6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer-03数组中重复的数字</title>
      <link href="/2020/06/14/%E5%89%91%E6%8C%87offer-03%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97/"/>
      <url>/2020/06/14/%E5%89%91%E6%8C%87offer-03%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97/</url>
      
        <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。<br>示例 ：<br>输入：<br>[2, 3, 1, 0, 2, 5, 3]<br>输出：2 或 3 </p><p>leecode网址：<br><a href="https://leetcode-cn.com/" target="_blank" rel="noopener">https://leetcode-cn.com/</a></p><h1 id="算法分析-代码实现"><a href="#算法分析-代码实现" class="headerlink" title="算法分析+代码实现"></a>算法分析+代码实现</h1><p>1 我最开始想到的解法：循环遍历</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> findRepeatNumber = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;nums.length;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i!=j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i]===nums[j])</span><br><span class="line">                    <span class="keyword">return</span> nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>结果如下：时间复杂度O(n2),空间复杂度为0(1)<br>执行用时 :7308 ms, 在所有 JavaScript 提交中击败了5.02%的用户<br>内存消耗 :40 MB, 在所有 JavaScript 提交中击败了100.00%的用户</p><p>2 优化：先给数组排序，再查找，只需看当前元素和下一个元素是否相等就行<br>利用了js数组中的sort( ),该方法是在数组本身上做修改</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> findRepeatNumber = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    nums.sort()</span><br><span class="line">    <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;nums.length<span class="number">-1</span>;j++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[j]===nums[j+<span class="number">1</span>])&#123;</span><br><span class="line">            <span class="keyword">return</span> nums[j]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>结果：时间复杂度O(n);空间复杂度度O(1)<br>执行用时 :112 ms, 在所有 JavaScript 提交中击败了34.21%的用户<br>内存消耗 :41.1 MB, 在所有 JavaScript 提交中击败了100.00%的用户</p><p>3（原书最优解）重新看了一次题目，发现一个新的提示：数组长度为n，且数字范围在0~n-1<br>可以选择利用数组元素下标和元素值是否对应来判断，如果没有重复的数字，则nums[i]=i<br>代码如下:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> findRepeatNumber = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums <span class="keyword">instanceof</span> <span class="built_in">Array</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]!=i)&#123;</span><br><span class="line">                <span class="comment">//判断nums[i]和nums[nums[i]]是否相等</span></span><br><span class="line">                <span class="keyword">if</span>(nums[i]===nums[nums[i]])&#123;</span><br><span class="line">                    <span class="keyword">return</span> nums[i]</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//判断结束，发现不相等，说明该数字还没排序</span></span><br><span class="line">                <span class="keyword">var</span> num=nums[i]</span><br><span class="line">                nums[i]=nums[num]</span><br><span class="line">                nums[num]=num</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;  </span><br><span class="line">    &#125; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>结果：时间复杂度：O(n)，空间复杂度O(1)</p><p>执行用时 :72 ms, 在所有 JavaScript 提交中击败了94.32%的用户<br>内存消耗 :39.8 MB, 在所有 JavaScript 提交中击败了100.00%的用户</p><p>4 可以使用js的set方法<br>从leecode的题解中找到的，只能说用了新的东西，但是效果不怎么样</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> findRepeatNumber = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> num =<span class="keyword">new</span> <span class="built_in">Set</span>()</span><br><span class="line">    <span class="keyword">if</span>(nums <span class="keyword">instanceof</span> <span class="built_in">Array</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i <span class="keyword">in</span> nums)&#123;</span><br><span class="line">            <span class="keyword">let</span> SetLength=num.size</span><br><span class="line">            num.add(nums[i])</span><br><span class="line">            <span class="keyword">if</span>(SetLength===num.size)&#123;</span><br><span class="line">                <span class="keyword">return</span> nums[i]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>结果：时间复杂度O(n),空间复杂度最大为O(n)，因为毕竟重新添加了一个新的set实例对象<br>执行用时 :100 ms, 在所有 JavaScript 提交中击败了40.59%的用户<br>内存消耗 :50.2 MB, 在所有 JavaScript 提交中击败了100.00%的用户</p><p>5 hash方法：利用一个空数组，设置hash[nums[i]]<br>使用ES6新特性 for of</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ar findRepeatNumber = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> hash = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> item <span class="keyword">of</span> nums) &#123;</span><br><span class="line">        <span class="keyword">if</span> (item &gt;= <span class="number">0</span> &amp;&amp; item &lt;= nums.length - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (hash[item]) &#123;</span><br><span class="line">                <span class="keyword">return</span> item</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                hash[item] = <span class="literal">true</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>结果为：时间复杂度O(n),空间复杂度为(n)<br>执行用时 :100 ms, 在所有 JavaScript 提交中击败了40.59%的用户<br>内存消耗 :43.3 MB, 在所有 JavaScript 提交中击败了100.00%的用户</p>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
          <category> 03-数组中重复的数字 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 剑指offer </tag>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HEXO 使用</title>
      <link href="/2020/06/14/hexo%E5%85%A5%E9%97%A8/"/>
      <url>/2020/06/14/hexo%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="网站个性化"><a href="#网站个性化" class="headerlink" title="网站个性化"></a>网站个性化</h1><p>这里产生一个问题 我修改的是本地的 还是github仓库里的</p><h2 id="本地修改"><a href="#本地修改" class="headerlink" title="本地修改"></a>本地修改</h2><p>通过修改pubilc内的index.html修改页面</p><ol><li>hexo g 渲染相关页面</li><li>hexo clean</li><li>hexo deploy提交<h2 id="github修改"><a href="#github修改" class="headerlink" title="github修改"></a>github修改</h2>问题：如果我使用github修改了网站样式 那么我再通过hexo提交样式的时候 是否会把我github上修改的样式给替换掉<br>会 所以直接使用模板 简化操作 </li></ol><h1 id="写文件"><a href="#写文件" class="headerlink" title="写文件"></a>写文件</h1><p>md语法：<br>块级元素</p><ol><li><p>段落和换行</p><ol><li>段落:用空行隔开</li><li>换行:行尾添加两个及以上空格</li></ol></li><li><p>标题</p><ol><li>setext样式：在该行下方使用==表示一级标题 –表示二级标题<br>.</li><li>atx样式：前方使用1-6#号表示1-6级别标题</li></ol></li><li><p>块引用</p><ol><li>使用 email 样式的 &gt; 字符作为块引用 </li><li>使用多个 &gt; 表示多层引用，各层引用间使用&gt;隔开<blockquote><p>一级引用</p><blockquote><p>二级引用</p></blockquote><p>一级引用</p></blockquote></li></ol></li><li><p>列表</p><ol><li><p>有序列表：数字加句号，md文件会自动排序</p><blockquote><p>md文件有序列表数字可以自动排序，只和位置有关</p></blockquote><ol><li>第一项</li><li>第二项</li></ol></li><li><p>无序列表：*  + -三者都可以</p><ul><li>*号</li></ul><ul><li>+号</li></ul><ul><li>-号</li></ul></li><li><p>嵌套：子层列表 要缩进2个空格 或者缩进一个制表符table        </p></li></ol></li><li><p>代码块</p><ol><li><p>使用缩进（相对于上一行非代码块部分）    </p><pre><code>不在列表项中：一层缩进在的话 两层缩进</code></pre></li><li><p>使用三个反引号</p></li></ol></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这是代码块</span><br></pre></td></tr></table></figure><ol start="6"><li>分割线<ol><li>行中只有三个以上的  * * * 或者 — 则会生成分割线</li></ol></li></ol><p>内联元素</p><ol><li>连接<br> 链接格式：<pre><code>[连接名称] (url/&quot;title&quot;)</code></pre><a href="https:/www.baidu.com/" target="_blank" rel="noopener" title="baidu">百度</a></li></ol><ol start="2"><li><p>强调<br> 使用 * 和 -包裹文本</p></li><li><p>图片<br> 语法：</p><pre><code>![Alt text](/path/to/img.jpg)![Alt text](/path/to/img.jpg &quot;Optional title&quot;)</code></pre></li></ol>]]></content>
      
      
      <categories>
          
          <category> HEXO使用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo基本使用 </tag>
            
            <tag> md语法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js高级-线程和事件机制</title>
      <link href="/2020/06/13/js%E9%AB%98%E7%BA%A7-%E7%BA%BF%E7%A8%8B%E5%92%8C%E4%BA%8B%E4%BB%B6%E6%9C%BA%E5%88%B6/"/>
      <url>/2020/06/13/js%E9%AB%98%E7%BA%A7-%E7%BA%BF%E7%A8%8B%E5%92%8C%E4%BA%8B%E4%BB%B6%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="线程和进程"><a href="#线程和进程" class="headerlink" title="线程和进程"></a>线程和进程</h1><ol><li>进程：程序的一次执行, 它占有一片独有的内存空间</li><li>线程： CPU的基本调度单位, 是程序执行的一个完整流程</li><li>进程与线程<ul><li>一个进程中一般至少有一个运行的线程: 主线程</li><li>一个进程中也可以同时运行多个线程, 我们会说程序是多线程运行的</li><li>一个进程内的数据可以供其中的多个线程直接共享</li><li>多个进程之间的数据是不能直接共享的</li></ul></li><li>浏览器运行是单进程还是多进程?<ul><li>有的是单进程<ul><li>firefox</li><li>老版IE</li></ul></li><li>有的是多进程<ul><li>chrome</li><li>新版IE</li></ul></li></ul></li><li>如何查看浏览器是否是多进程运行的呢?<ul><li>任务管理器==&gt;进程</li></ul></li><li>浏览器运行是单线程还是多线程?<ul><li>都是多线程运行的<h1 id="浏览器内核"><a href="#浏览器内核" class="headerlink" title="浏览器内核"></a>浏览器内核</h1></li></ul></li><li>什么是浏览器内核?<ul><li>支持浏览器运行的最核心的程序</li></ul></li><li>不同的浏览器可能不太一样<ul><li>Chrome, Safari: webkit</li><li>firefox: Gecko</li><li>IE: Trident</li><li>360,搜狗等国内浏览器: Trident + webkit</li></ul></li><li>内核由很多模块组成<ul><li>html,css文档解析模块 : 负责页面文本的解析</li><li>dom/css模块 : 负责dom/css在内存中的相关处理</li><li>布局和渲染模块 : 负责页面的布局和效果的绘制</li><li>布局和渲染模块 : 负责页面的布局和效果的绘制</li><li>定时器模块 : 负责定时器的管理</li><li>网络请求模块 : 负责服务器请求(常规/Ajax)</li><li>事件响应模块 : 负责事件的管理</li></ul></li></ol><h1 id="js单线程机制"><a href="#js单线程机制" class="headerlink" title="js单线程机制"></a>js单线程机制</h1><ol><li>如何证明js执行是单线程的?<ul><li>setTimeout()的回调函数是在主线程执行的</li><li>定时器回调函数只有在运行栈中的代码全部执行完后才有可能执行</li></ul></li><li>为什么js要用单线程模式, 而不用多线程模式?<ul><li>JavaScript的单线程，与它的用途有关。</li><li>作为浏览器脚本语言，JavaScript的主要用途是与用户互动，以及操作DOM。</li><li>这决定了它只能是单线程，否则会带来很复杂的同步问题</li></ul></li><li>代码的分类:<ul><li>初始化代码</li><li>回调代码</li></ul></li><li>js引擎执行代码的基本流程<ul><li>先执行初始化代码: 包含一些特别的代码   回调函数(异步执行)<ul><li>设置定时器</li><li>绑定事件监听</li><li>发送ajax请求</li></ul></li><li>后面在某个时刻才会执行回调代码</li></ul></li></ol><h1 id="事件循环模型"><a href="#事件循环模型" class="headerlink" title="事件循环模型"></a>事件循环模型</h1><ol><li>所有代码分类<ul><li>初始化执行代码(同步代码): 包含绑定dom事件监听, 设置定时器, 发送ajax请求的代码</li><li>回调执行代码(异步代码): 处理回调逻辑</li></ul></li><li>js引擎执行代码的基本流程:<ul><li>初始化代码===&gt;回调代码</li></ul></li><li>模型的2个重要组成部分:<ul><li>事件(定时器/DOM事件/Ajax)管理模块</li><li>回调队列</li></ul></li><li>模型的运转流程<ul><li>执行初始化代码, 将事件回调函数交给对应模块管理</li><li>当事件发生时, 管理模块会将回调函数及其数据添加到回调列队中</li><li>只有当初始化代码执行完后(可能要一定时间), 才会遍历读取回调队列中的回调函数执行</li></ul></li></ol><h1 id="Web-Workers分线程"><a href="#Web-Workers分线程" class="headerlink" title="Web Workers分线程"></a>Web Workers分线程</h1><ol><li>H5规范提供了js分线程的实现, 取名为: Web Workers</li><li>相关API<ul><li>Worker: 构造函数, 加载分线程执行的js文件</li><li>Worker.prototype.onmessage: 用于接收另一个线程的回调函数</li><li>Worker.prototype.postMessage: 向另一个线程发送消息</li></ul></li><li>不足<ul><li>worker内代码不能操作DOM(更新UI)</li><li>不能跨域加载JS</li><li>不是每个浏览器都支持这个新特性</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> js高级 </category>
          
          <category> 线程_事件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线程 </tag>
            
            <tag> 事件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js高级-对象-继承模式(劣-&gt;优)</title>
      <link href="/2020/06/13/js%E9%AB%98%E7%BA%A7-%E5%AF%B9%E8%B1%A1-%E7%BB%A7%E6%89%BF%E6%A8%A1%E5%BC%8F/"/>
      <url>/2020/06/13/js%E9%AB%98%E7%BA%A7-%E5%AF%B9%E8%B1%A1-%E7%BB%A7%E6%89%BF%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="原型链继承"><a href="#原型链继承" class="headerlink" title="原型链继承"></a>原型链继承</h1><p>套路</p><ol><li>定义父类型构造函数</li><li>给父类型的原型添加方法</li><li>定义子类型的构造函数</li><li>创建父类型的对象赋值给子类型的原型</li><li>将子类型原型的构造属性设置为子类型</li><li>给子类型原型添加方法</li><li>创建子类型的对象: 可以调用父类型的方法<br>关键：子类型的原型为父类型的一个实例对象<br>问题：由子类型生成的实例对象的，其constructor属性直接指向的是父元素的原型对象，而不是其子类型的原型对象<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//父类型</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Supper</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.supProp = <span class="string">'Supper property'</span></span><br><span class="line">&#125;</span><br><span class="line">Supper.prototype.showSupperProp = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span>.supProp)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//子类型</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Sub</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.subProp = <span class="string">'Sub property'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类型的原型为父类型的一个实例对象</span></span><br><span class="line">Sub.prototype = <span class="keyword">new</span> Supper()</span><br><span class="line"><span class="comment">// 让子类型的原型的constructor指向子类型</span></span><br><span class="line">Sub.prototype.constructor = Sub</span><br><span class="line">Sub.prototype.showSubProp = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span>.subProp)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> sub = <span class="keyword">new</span> Sub()</span><br><span class="line">sub.showSupperProp()</span><br><span class="line"><span class="comment">// sub.toString()</span></span><br><span class="line">sub.showSubProp()</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(sub)  <span class="comment">// Sub</span></span><br></pre></td></tr></table></figure>以上代码在内存中的情况如下：<br><img src="/images/js%E9%AB%98%E7%BA%A7-%E5%AF%B9%E8%B1%A1-%E7%BB%A7%E6%89%BF-%E5%9B%BE%E4%B8%80.png" alt="图一"></li></ol><h1 id="借用构造函数继承（假继承）"><a href="#借用构造函数继承（假继承）" class="headerlink" title="借用构造函数继承（假继承）"></a>借用构造函数继承（假继承）</h1><p>只是利用了call函数调用了父类型的构造函数，并不是真正的继承<br>call()方法：使用一个指定的 this 值和单独给出的一个或多个参数来调用一个函数。</p><p>套路:</p><ol><li>定义父类型构造函数</li><li>定义子类型构造函数</li><li>在子类型构造函数中调用父类型构造<br>关键:</li><li>在子类型构造函数中通用call()调用父类型构造函数</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">    <span class="keyword">this</span>.age = age</span><br><span class="line">  &#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params">name, age, price</span>) </span>&#123;</span><br><span class="line">Person.call(<span class="keyword">this</span>, name, age)  <span class="comment">// 相当于: this.Person(name, age)</span></span><br><span class="line">    <span class="comment">/*this.name = name</span></span><br><span class="line"><span class="comment">    this.age = age*/</span></span><br><span class="line">    <span class="keyword">this</span>.price = price</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> s = <span class="keyword">new</span> Student(<span class="string">'Tom'</span>, <span class="number">20</span>, <span class="number">14000</span>)</span><br><span class="line"><span class="built_in">console</span>.log(s.name, s.age, s.price)</span><br></pre></td></tr></table></figure><h1 id="组合继承（原型链加借用构造函数继承）"><a href="#组合继承（原型链加借用构造函数继承）" class="headerlink" title="组合继承（原型链加借用构造函数继承）"></a>组合继承（原型链加借用构造函数继承）</h1><ol><li>利用原型链实现对父类型对象的方法继承</li><li>利用call()借用父类型构建函数初始化相同属性<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">    <span class="keyword">this</span>.age = age</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.setName = <span class="function"><span class="keyword">function</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params">name, age, price</span>) </span>&#123;</span><br><span class="line">    Person.call(<span class="keyword">this</span>, name, age)  <span class="comment">// 为了得到属性</span></span><br><span class="line">    <span class="keyword">this</span>.price = price</span><br><span class="line">&#125;</span><br><span class="line">Student.prototype = <span class="keyword">new</span> Person() <span class="comment">// 为了能看到父类型的方法</span></span><br><span class="line">    Student.prototype.constructor = Student <span class="comment">//修正constructor属性</span></span><br><span class="line">    Student.prototype.setPrice = <span class="function"><span class="keyword">function</span> (<span class="params">price</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.price = price</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> s = <span class="keyword">new</span> Student(<span class="string">'Tom'</span>, <span class="number">24</span>, <span class="number">15000</span>)</span><br><span class="line">s.setName(<span class="string">'Bob'</span>)</span><br><span class="line">s.setPrice(<span class="number">16000</span>)</span><br><span class="line"><span class="built_in">console</span>.log(s.name, s.age, s.price)</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> js高级 </category>
          
          <category> 对象 </category>
          
          <category> 继承模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js高级 </tag>
            
            <tag> js对象 </tag>
            
            <tag> 对象继承 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js高级-对象-几种创建模式及优缺点（劣-&gt;优）</title>
      <link href="/2020/06/13/js%E9%AB%98%E7%BA%A7-%E5%AF%B9%E8%B1%A1-%E5%88%9B%E5%BB%BA%E6%A8%A1%E5%BC%8F/"/>
      <url>/2020/06/13/js%E9%AB%98%E7%BA%A7-%E5%AF%B9%E8%B1%A1-%E5%88%9B%E5%BB%BA%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="Object构造函数模式"><a href="#Object构造函数模式" class="headerlink" title="Object构造函数模式"></a>Object构造函数模式</h1><p>套路: 先创建空Object对象, 再动态添加属性/方法<br>适用场景: 起始时不确定对象内部数据<br>问题: 语句太多</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 先创建空Object对象</span></span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="built_in">Object</span>()</span><br><span class="line">p = &#123;&#125; <span class="comment">//此时内部数据是不确定的</span></span><br><span class="line"><span class="comment">// 再动态添加属性/方法</span></span><br><span class="line">p.name = <span class="string">'Tom'</span></span><br><span class="line">p.age = <span class="number">12</span></span><br><span class="line">p.setName = <span class="function"><span class="keyword">function</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试</span></span><br><span class="line"><span class="built_in">console</span>.log(p.name, p.age)</span><br><span class="line">p.setName(<span class="string">'Bob'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(p.name, p.age)</span><br></pre></td></tr></table></figure><h1 id="对象字面量模式"><a href="#对象字面量模式" class="headerlink" title="对象字面量模式"></a>对象字面量模式</h1><p>套路: 使用{}创建对象, 同时指定属性/方法<br>适用场景: 起始时对象内部数据是确定的<br>问题: 如果创建多个对象, 有重复代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p = &#123;</span><br><span class="line">   name: <span class="string">'Tom'</span>,</span><br><span class="line">   age: <span class="number">12</span>,</span><br><span class="line">   setName: <span class="function"><span class="keyword">function</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">     <span class="keyword">this</span>.name = name</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//测试</span></span><br><span class="line"> <span class="built_in">console</span>.log(p.name, p.age)</span><br><span class="line"> p.setName(<span class="string">'JACK'</span>)</span><br><span class="line"> <span class="built_in">console</span>.log(p.name, p.age)</span><br><span class="line"></span><br><span class="line"> <span class="keyword">var</span> p2 = &#123;  <span class="comment">//如果创建多个对象代码很重复</span></span><br><span class="line">   name: <span class="string">'Bob'</span>,</span><br><span class="line">   age: <span class="number">13</span>,</span><br><span class="line">   setName: <span class="function"><span class="keyword">function</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">     <span class="keyword">this</span>.name = name</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h1 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h1><p>套路: 通过工厂函数动态创建对象并返回<br>适用场景: 需要创建多个对象<br>问题: 对象没有一个具体的类型, 都是Object类型</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createPerson</span>(<span class="params">name, age</span>) </span>&#123; <span class="comment">//返回一个对象的函数===&gt;工厂函数</span></span><br><span class="line">   <span class="keyword">var</span> obj = &#123;</span><br><span class="line">     name: name,</span><br><span class="line">     age: age,</span><br><span class="line">     setName: <span class="function"><span class="keyword">function</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>.name = name</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> obj</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 创建2个人</span></span><br><span class="line"> <span class="keyword">var</span> p1 = createPerson(<span class="string">'Tom'</span>, <span class="number">12</span>)</span><br><span class="line"> <span class="keyword">var</span> p2 = createPerson(<span class="string">'Bob'</span>, <span class="number">13</span>)</span><br><span class="line"></span><br><span class="line"> <span class="comment">// p1/p2是Object类型</span></span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">createStudent</span>(<span class="params">name, price</span>) </span>&#123;</span><br><span class="line">   <span class="keyword">var</span> obj = &#123;</span><br><span class="line">     name: name,</span><br><span class="line">     price: price</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> obj</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">var</span> s = createStudent(<span class="string">'张三'</span>, <span class="number">12000</span>)</span><br><span class="line"> <span class="comment">// s也是Object</span></span><br></pre></td></tr></table></figure><p>很明显，无法区分学生张三和非学生p1，p2</p><h1 id="自定义构造函数"><a href="#自定义构造函数" class="headerlink" title="自定义构造函数"></a>自定义构造函数</h1><p>套路: 自定义构造函数, 通过new创建对象<br>适用场景: 需要创建多个类型确定的对象<br>问题: 每个对象都有相同的数据, 浪费内存<br>所谓的浪费内存是指，每个对象内部都会有同样的区域，去存放同样的方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义类型</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name</span><br><span class="line">  <span class="keyword">this</span>.age = age</span><br><span class="line">  <span class="keyword">this</span>.setName = <span class="function"><span class="keyword">function</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> Person(<span class="string">'Tom'</span>, <span class="number">12</span>)</span><br><span class="line">p1.setName(<span class="string">'Jack'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(p1.name, p1.age)</span><br><span class="line"><span class="built_in">console</span>.log(p1 <span class="keyword">instanceof</span> Person)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student</span> (<span class="params">name, price</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name</span><br><span class="line">  <span class="keyword">this</span>.price = price</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> s = <span class="keyword">new</span> Student(<span class="string">'Bob'</span>, <span class="number">13000</span>)</span><br><span class="line"><span class="built_in">console</span>.log(s <span class="keyword">instanceof</span> Student)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> Person(<span class="string">'JACK'</span>, <span class="number">23</span>)</span><br><span class="line"><span class="built_in">console</span>.log(p1, p2)</span><br></pre></td></tr></table></figure><h1 id="构造函数-原型的组合模式"><a href="#构造函数-原型的组合模式" class="headerlink" title="构造函数+原型的组合模式"></a>构造函数+原型的组合模式</h1><p>套路: 自定义构造函数, 属性在函数中初始化, 方法添加到原型上<br>适用场景: 需要创建多个类型确定的对象<br>最常用的一种,解决了以上出现的问题</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age</span>) </span>&#123; <span class="comment">//在构造函数中只初始化一般函数</span></span><br><span class="line">  <span class="keyword">this</span>.name = name</span><br><span class="line">  <span class="keyword">this</span>.age = age</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.setName = <span class="function"><span class="keyword">function</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> Person(<span class="string">'Tom'</span>, <span class="number">23</span>)</span><br><span class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> Person(<span class="string">'Jack'</span>, <span class="number">24</span>)</span><br><span class="line"><span class="built_in">console</span>.log(p1, p2)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> js高级 </category>
          
          <category> 对象 </category>
          
          <category> 创建 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js对象 </tag>
            
            <tag> 对象创建 </tag>
            
            <tag> 创建模式比较 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js高级-面试题-闭包</title>
      <link href="/2020/06/12/js%E9%AB%98%E7%BA%A7-%E9%9D%A2%E8%AF%95%E9%A2%98-%E9%97%AD%E5%8C%85/"/>
      <url>/2020/06/12/js%E9%AB%98%E7%BA%A7-%E9%9D%A2%E8%AF%95%E9%A2%98-%E9%97%AD%E5%8C%85/</url>
      
        <content type="html"><![CDATA[<h1 id="第一题-输出是什么？"><a href="#第一题-输出是什么？" class="headerlink" title="第一题: 输出是什么？"></a>第一题: 输出是什么？</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">"The Window"</span>;</span><br><span class="line">  <span class="keyword">var</span> object = &#123;</span><br><span class="line">    name : <span class="string">"My Object"</span>,</span><br><span class="line">    getNameFunc : <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  alert(object.getNameFunc()());  <span class="comment">//?  the window</span></span><br></pre></td></tr></table></figure><p>片段一是作用域的问题</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码片段二</span></span><br><span class="line"><span class="keyword">var</span> name2 = <span class="string">"The Window"</span>;</span><br><span class="line"><span class="keyword">var</span> object2 = &#123;</span><br><span class="line">  name2 : <span class="string">"My Object"</span>,</span><br><span class="line">  getNameFunc : <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> that = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> that.name2;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">alert(object2.getNameFunc()()); <span class="comment">//?  my object</span></span><br></pre></td></tr></table></figure><p>片段二，由于返回函数使用了外层函数的变量that，<br>在其内部产生了闭包，闭包内that属性指向了object2<br>故输出为object2内部的name2属性</p><h1 id="面试题2"><a href="#面试题2" class="headerlink" title="面试题2"></a>面试题2</h1><p>代码如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun</span>(<span class="params">n,o</span>) </span>&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(o)</span><br><span class="line">   <span class="keyword">return</span> &#123;</span><br><span class="line">     fun:<span class="function"><span class="keyword">function</span>(<span class="params">m</span>)</span>&#123;</span><br><span class="line">       <span class="keyword">return</span> fun(m,n)</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">var</span> a = fun(<span class="number">0</span>)</span><br><span class="line"> a.fun(<span class="number">1</span>)</span><br><span class="line"> a.fun(<span class="number">2</span>)</span><br><span class="line"> a.fun(<span class="number">3</span>)<span class="comment">//undefined,0,0,0</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">var</span> b = fun(<span class="number">0</span>).fun(<span class="number">1</span>).fun(<span class="number">2</span>).fun(<span class="number">3</span>)<span class="comment">//undefined,0,1,2</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">var</span> c = fun(<span class="number">0</span>).fun(<span class="number">1</span>)<span class="comment">//undefine 0</span></span><br><span class="line"> c.fun(<span class="number">2</span>)<span class="comment">//1</span></span><br><span class="line"> c.fun(<span class="number">3</span>)<span class="comment">//1</span></span><br></pre></td></tr></table></figure><p>总结来说，每一次调用fun函数，都会更新返回函数的闭包内的属性n</p>]]></content>
      
      
      <categories>
          
          <category> js高级 </category>
          
          <category> 面试题 </category>
          
          <category> 闭包 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js高级 </tag>
            
            <tag> 闭包 </tag>
            
            <tag> 面试题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js高级-函数-闭包</title>
      <link href="/2020/06/12/js%E9%AB%98%E7%BA%A7-%E5%87%BD%E6%95%B0-%E9%97%AD%E5%8C%85/"/>
      <url>/2020/06/12/js%E9%AB%98%E7%BA%A7-%E5%87%BD%E6%95%B0-%E9%97%AD%E5%8C%85/</url>
      
        <content type="html"><![CDATA[<h1 id="如何产生闭包"><a href="#如何产生闭包" class="headerlink" title="如何产生闭包"></a>如何产生闭包</h1><p>两个条件缺一不可<br>条件一： 函数嵌套<br>条件二：内部函数引用了外部函数的数据(变量/函数)</p><h1 id="闭包到底是什么"><a href="#闭包到底是什么" class="headerlink" title="闭包到底是什么"></a>闭包到底是什么</h1><blockquote><p>使用chrome调试查看<br>注意: 闭包存在于嵌套的内部函数中</p></blockquote><p>理解一: 闭包是嵌套的内部函数(绝大部分人)<br>理解二: 包含被引用变量(函数)的对象(极少数人)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn1</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">2</span></span><br><span class="line"><span class="keyword">var</span> b = <span class="string">'abc'</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn2</span> (<span class="params"></span>) </span>&#123; <span class="comment">//执行函数定义就会产生闭包(不用调用内部函数)</span></span><br><span class="line">  <span class="built_in">console</span>.log(a)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// fn2()</span></span><br><span class="line">&#125;</span><br><span class="line">fn1()</span><br></pre></td></tr></table></figure><p>就以上述代码而言，只有当fn1执行时，才会在fn2内部产生闭包，一个包含着引用对象（或者函数）的对象</p><h1 id="闭包作用"><a href="#闭包作用" class="headerlink" title="闭包作用"></a>闭包作用</h1><p>作用一：使用函数内部的变量在函数执行完后, 仍然存活在内存中(延长了局部变量的生命周期)<br>作用二：让函数外部可以操作(读写)到函数内部的数据(变量/函数)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">2</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  a++</span><br><span class="line">  <span class="built_in">console</span>.log(a)</span><br><span class="line">  <span class="comment">// return a</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> fn2</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> f = fn1()</span><br><span class="line">f() <span class="comment">// 3</span></span><br><span class="line">f() <span class="comment">// 4</span></span><br></pre></td></tr></table></figure><p>问题:<br>函数执行完后, 函数内部声明的局部变量是否还存在?<br>答：一般是不存在, 存在于闭中的变量才可能存在</p><p>在函数外部能直接访问函数内部的局部变量吗?<br>答：不能, 但我们可以通过闭包让外部操作它</p><h1 id="闭包的生命周期"><a href="#闭包的生命周期" class="headerlink" title="闭包的生命周期"></a>闭包的生命周期</h1><p>产生: 在嵌套内部函数定义执行完时就产生了(不是在调用)<br>死亡: 在嵌套的内部函数成为垃圾对象时</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//此时闭包就已经产生了(函数提升, 内部函数对象已经创建了)</span></span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">2</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">fn2</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      a++</span><br><span class="line">      <span class="built_in">console</span>.log(a)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fn2</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> f = fn1()</span><br><span class="line">  f() <span class="comment">// 3</span></span><br><span class="line">  f() <span class="comment">// 4</span></span><br><span class="line">  f = <span class="literal">null</span> <span class="comment">//闭包死亡(包含闭包的函数对象成为垃圾对象)</span></span><br></pre></td></tr></table></figure><h1 id="闭包应用"><a href="#闭包应用" class="headerlink" title="闭包应用"></a>闭包应用</h1><p>定义JS模块</p><ul><li>具有特定功能的js文件</li><li>将所有的数据和功能都封装在一个函数内部(私有的)</li><li>只向外暴露一个包信n个方法的对象或函数</li><li>模块的使用者, 只需要通过模块暴露的对象调用方法来实现对应的功能  </li></ul><p>js文件内容：<br>一般情况</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myModule</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">//私有数据</span></span><br><span class="line">  <span class="keyword">var</span> msg = <span class="string">'My atguigu'</span></span><br><span class="line">  <span class="comment">//操作数据的函数</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'doSomething() '</span>+msg.toUpperCase())</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">doOtherthing</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'doOtherthing() '</span>+msg.toLowerCase())</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//向外暴露对象(给外部使用的方法)</span></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    doSomething: doSomething,</span><br><span class="line">    doOtherthing: doOtherthing</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用时，需要先生成一个函数对象，才能调用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="built_in">module</span> = myModule()</span><br><span class="line"> <span class="built_in">module</span>.doSomething()</span><br><span class="line"> <span class="built_in">module</span>.doOtherthing()</span><br></pre></td></tr></table></figure><p>匿名函数自调用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">//私有数据</span></span><br><span class="line">  <span class="keyword">var</span> msg = <span class="string">'My atguigu'</span></span><br><span class="line">  <span class="comment">//操作数据的函数</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'doSomething() '</span>+msg.toUpperCase())</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">doOtherthing</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'doOtherthing() '</span>+msg.toLowerCase())</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//向外暴露对象(给外部使用的方法)</span></span><br><span class="line">  <span class="built_in">window</span>.myModule2 = &#123;</span><br><span class="line">    doSomething: doSomething,</span><br><span class="line">    doOtherthing: doOtherthing</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure><p>该方式可以直接调用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">myModule2.doSomething()</span><br><span class="line">myModule2.doOtherthing()</span><br></pre></td></tr></table></figure><p>后者容易压缩，工作时会常用</p><h1 id="缺点及解决方法"><a href="#缺点及解决方法" class="headerlink" title="缺点及解决方法"></a>缺点及解决方法</h1><p>缺点</p><ul><li>函数执行完后, 函数内的局部变量没有释放, 占用内存时间会变长</li><li>容易造成内存泄露</li></ul><p>解决</p><ul><li>能不用闭包就不用</li><li>及时释放</li></ul>]]></content>
      
      
      <categories>
          
          <category> js高级 </category>
          
          <category> 函数 </category>
          
          <category> 闭包 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 闭包 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js高级-面试题-作用域_作用域链</title>
      <link href="/2020/06/12/js%E9%AB%98%E7%BA%A7-%E9%9D%A2%E8%AF%95%E9%A2%98-%E4%BD%9C%E7%94%A8%E5%9F%9F-%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE/"/>
      <url>/2020/06/12/js%E9%AB%98%E7%BA%A7-%E9%9D%A2%E8%AF%95%E9%A2%98-%E4%BD%9C%E7%94%A8%E5%9F%9F-%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE/</url>
      
        <content type="html"><![CDATA[<h1 id="第一题-输出什么"><a href="#第一题-输出什么" class="headerlink" title="第一题 输出什么"></a>第一题 输出什么</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">show</span>(<span class="params">f</span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> x = <span class="number">20</span>;</span><br><span class="line">f();</span><br><span class="line">&#125;</span><br><span class="line">show(fn);<span class="comment">//10</span></span><br></pre></td></tr></table></figure><p>js中的作用域是静态作用域，在代码执行前就已经划分好了<br>当执行show（fn）时，fn内部没有定义x，故fn向外层，对于上述函数，就是全局作用域中找，故输出为：10</p><h1 id="第二题-输出什么？"><a href="#第二题-输出什么？" class="headerlink" title="第二题 :输出什么？"></a>第二题 :输出什么？</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fn = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(fn)</span><br><span class="line">&#125;</span><br><span class="line">fn()</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">fn2: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="built_in">console</span>.log(fn2)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.fn2()</span><br></pre></td></tr></table></figure><p>显然<br>fn（）会输出自身<br>而obj.fn（2） 则会报错，因为其输出的变量fn2在obj中，而全局作用域中也只有obj，没有fn2</p><h2 id="要想输出fn2，怎么办呢？"><a href="#要想输出fn2，怎么办呢？" class="headerlink" title="要想输出fn2，怎么办呢？"></a>要想输出fn2，怎么办呢？</h2><p>很简单，只需要把输出语句</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(fn2)</span><br></pre></td></tr></table></figure><p>改为</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span>.fn2)</span><br></pre></td></tr></table></figure><p>利用this指向引用对象本身，则该函数就会从引用对象中找匹配的变量</p>]]></content>
      
      
      <categories>
          
          <category> js高级 </category>
          
          <category> 面试题 </category>
          
          <category> 作用域 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 作用域 </tag>
            
            <tag> 面试题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js高级-函数-作用域_作用域链</title>
      <link href="/2020/06/11/js%E9%AB%98%E7%BA%A7-%E5%87%BD%E6%95%B0-%E4%BD%9C%E7%94%A8%E5%9F%9F-%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE/"/>
      <url>/2020/06/11/js%E9%AB%98%E7%BA%A7-%E5%87%BD%E6%95%B0-%E4%BD%9C%E7%94%A8%E5%9F%9F-%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE/</url>
      
        <content type="html"><![CDATA[<h1 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h1><h2 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h2><ul><li>就是一块”地盘”, 一个代码段所在的区域</li><li>它是静态的(相对于上下文对象), 在编写代码时就确定<h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2></li><li>全局作用域</li><li>函数作用域</li><li>块级作用域（ES6）<h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2></li><li>隔离变量，不同作用域下同名变量不会有冲突</li></ul><h1 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h1><h2 id="理解-1"><a href="#理解-1" class="headerlink" title="理解"></a>理解</h2><ul><li>多个上下级关系的作用域形成的链, 它的方向是从下向上的(从内到外)</li><li>查找变量时就是沿着作用域链来查找的<h2 id="查找一个变量的查找规则"><a href="#查找一个变量的查找规则" class="headerlink" title="查找一个变量的查找规则"></a>查找一个变量的查找规则</h2></li><li>在当前作用域下的执行上下文中查找对应的属性, 如果有直接返回, 否则进入2</li><li>在上一级作用域的执行上下文中查找对应的属性, 如果有直接返回, 否则进入3</li><li>再次执行2的相同操作, 直到全局作用域, 如果还找不到就抛出找不到的异常</li></ul><h1 id="块级作用域"><a href="#块级作用域" class="headerlink" title="块级作用域"></a>块级作用域</h1><blockquote><p>ES6之前js没有块级作用域，它使用var声明变量，以function来划分作用域，大括号“{}” 却限定不了var的作用域,用var声明的变量具有变量提升（declaration hoisting）的效果。</p></blockquote><p>  ES6新增加了一个let，可以在{}， if， for里声明。用法同var，但作用域限定在块级，let声明的变量不存在变量提升。<br>  ES6规定，如果代码块中存在let，这个区块从一开始就形成了封闭作用域,凡是在声明之前就使用，就会报错。即在代码块内，在let声明之前使用变量都是不可用的。<br>例1: 块级作用域 if</p><p>function test(flag) {<br>    if (flag) {<br>        var a = ‘js’<br>    }<br>    // 这里也可以访问 a<br>}<br>变量a在if块里声明的，但在else块和if外都可以访问到val,把var换成let后：</p><pre><code>function test(flag) {    if (flag) {        let a = &apos;js&apos;    }     // 这里也访问不到 a}</code></pre><p>例２块级作用域 for</p><pre><code>for(var i=0; i&lt;2; i++){    console.log(&apos;outer i: &apos; + i);    for(var i=0; i&lt;2; i++){    console.log(&apos;inner i: &apos;+i);    }}</code></pre><p>执行结果如下：</p><pre><code>outer i: 0test.html:12 inner i: 0test.html:12 inner i: 1</code></pre><p>可以看到，外层循环被打断了，因为ｉ为全局变量所以 i 的值被内层循环修改了，把内层循环的var换成let后：</p><pre><code>for(var i=0; i&lt;2; i++){    console.log(&apos;outer i: &apos; + i);    for(let i=0; i&lt;2; i++){    console.log(&apos;inner i: &apos;+i);    }}</code></pre><p>执行结果如下：</p><pre><code>outer i: 0test.html:12 inner i: 0test.html:12 inner i: 1test.html:10 outer i: 1test.html:12 inner i: 0test.html:12 inner i: 1</code></pre><p>示例3: 变量提升</p><p>先使用后声明</p><pre><code>console.log(a) // undefinedvar a;</code></pre><p>变量val先使用后声明，输出undefined，也不报错。把var换成let，就报错了</p><pre><code>console.log(a) // Uncaught ReferenceError: a is not definedvar a;</code></pre><p>先判断后声明</p><pre><code>if (typeof a == &apos;undefined&apos;) {    // ...}var a = &apos;&apos;</code></pre><p>把var换成let，if处报语法错 Uncaught ReferenceError: a is not defined</p><pre><code>if (typeof a == &apos;undefined&apos;) {    // ...}var a = &apos;&apos;</code></pre>]]></content>
      
      
      <categories>
          
          <category> js高级 </category>
          
          <category> 函数 </category>
          
          <category> 作用域和作用域链 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 作用域 </tag>
            
            <tag> 作用域链 </tag>
            
            <tag> 块级作用域 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js高级-面试题-上下文与上下文栈</title>
      <link href="/2020/06/11/js%E9%AB%98%E7%BA%A7-%E9%9D%A2%E8%AF%95%E9%A2%98-%E4%B8%8A%E4%B8%8B%E6%96%87%E4%B8%8E%E4%B8%8A%E4%B8%8B%E6%96%87%E6%A0%88/"/>
      <url>/2020/06/11/js%E9%AB%98%E7%BA%A7-%E9%9D%A2%E8%AF%95%E9%A2%98-%E4%B8%8A%E4%B8%8B%E6%96%87%E4%B8%8E%E4%B8%8A%E4%B8%8B%E6%96%87%E6%A0%88/</url>
      
        <content type="html"><![CDATA[<h1 id="1-代码执行时控制台输出什么？整个过程产生了几个执行上下文？"><a href="#1-代码执行时控制台输出什么？整个过程产生了几个执行上下文？" class="headerlink" title="1 代码执行时控制台输出什么？整个过程产生了几个执行上下文？"></a>1 代码执行时控制台输出什么？整个过程产生了几个执行上下文？</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'gb: '</span>+ i)</span><br><span class="line"><span class="keyword">var</span> i = <span class="number">1</span></span><br><span class="line">foo(<span class="number">1</span>)</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">i</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (i == <span class="number">4</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'fb:'</span> + i)</span><br><span class="line">  foo(i + <span class="number">1</span>) <span class="comment">//递归调用: 在函数内部调用自己</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'fe:'</span> + i)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'ge: '</span> + i)</span><br></pre></td></tr></table></figure><p>先改写代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">i</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (i == <span class="number">4</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'fb:'</span> + i)</span><br><span class="line">  foo(i + <span class="number">1</span>) <span class="comment">//递归调用: 在函数内部调用自己</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'fe:'</span> + i)</span><br><span class="line">&#125;</span><br><span class="line">i = <span class="number">1</span></span><br><span class="line">foo(<span class="number">1</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'ge: '</span> + i)</span><br></pre></td></tr></table></figure><p>首先来回答第一个问题：代码输出什么？<br>第一个控制台输出语句，考察的是变量提升，那么输出define<br>接下来就是函数模块很明显，这是一个简单的递归函数问题，i&lt;3时，foo函数会先输出fb，再调用自身，调用结束后，才会输出fe，<br>故针对于函数模块来说，输出如下：<br><img src="/images/js%E9%AB%98%E7%BA%A7_%E9%9D%A2%E8%AF%95_%E4%B8%8A%E4%B8%8B%E6%96%87_1_1.png" alt="函数部分结果"><br>最后一个输出语句考察的就是引用变量赋值问题，由于函数内部数据随着函数上下文的清除而清楚，最终输出的还是其外部定义的值，即：1<br>最终结果如下<br><img src="/images/js%E9%AB%98%E7%BA%A7_%E9%9D%A2%E8%AF%95_%E4%B8%8A%E4%B8%8B%E6%96%87_1_2.png" alt="函数部分结果"></p><h1 id="2-先执行变量提升，再执行函数"><a href="#2-先执行变量提升，再执行函数" class="headerlink" title="2 先执行变量提升，再执行函数"></a>2 先执行变量提升，再执行函数</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> a</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> a) <span class="comment">// 'function'</span></span><br></pre></td></tr></table></figure><p>以上代码根据js语法，改写为：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> a) <span class="comment">// 'function'</span></span><br></pre></td></tr></table></figure><blockquote><p>第二句把第一句的a的数据类型给覆盖了，输出：function<br>题目简单，只是别突然忘记了就行</p></blockquote><h1 id="3"><a href="#3" class="headerlink" title="3"></a>3</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!(b <span class="keyword">in</span> <span class="built_in">window</span>)) &#123;</span><br><span class="line">    <span class="keyword">var</span> b = <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(b) <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>以上代码改写为：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> b</span><br><span class="line"><span class="keyword">if</span> (!(b <span class="keyword">in</span> <span class="built_in">window</span>)) &#123;</span><br><span class="line">b = <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(b) <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>因为if语句只做判断，并非函数模块，内部不会产生新的上下文<br>所以结果很明显，就是undefined</p><h1 id="4"><a href="#4" class="headerlink" title="4"></a>4</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> c = <span class="number">1</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">c</span>(<span class="params">c</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(c)</span><br><span class="line">  <span class="keyword">var</span> c = <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line">c(<span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>上边的代码，一开始看起来很懵，这啥啊？<br>但是，别急，先改写</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> c = <span class="number">1</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">c</span>(<span class="params">c</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> c</span><br><span class="line">  <span class="built_in">console</span>.log(c)</span><br><span class="line">  c = <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line">c = <span class="number">1</span></span><br><span class="line">c(<span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>改写过后，结果显而易见的，浏览器直接报错，c根本就不是一个函数嘛</p><h1 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h1><p>凡是出现和上下文有关的面试题，第一步永远先改写代码，反映出其真正的处理过程，再进行判断</p>]]></content>
      
      
      <categories>
          
          <category> js高级 </category>
          
          <category> 面试题 </category>
          
          <category> 上下文栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js面试 </tag>
            
            <tag> 上下文面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js高级-执行上下文与执行上下文栈</title>
      <link href="/2020/06/10/js%E9%AB%98%E7%BA%A7-%E5%87%BD%E6%95%B0-%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E4%B8%8E%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E6%A0%88/"/>
      <url>/2020/06/10/js%E9%AB%98%E7%BA%A7-%E5%87%BD%E6%95%B0-%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E4%B8%8E%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E6%A0%88/</url>
      
        <content type="html"><![CDATA[<h1 id="变量，函数提升"><a href="#变量，函数提升" class="headerlink" title="变量，函数提升"></a>变量，函数提升</h1><p>说白了就是写代码的时候先引用后声明<br>对于同名的情况 先执行变量提升，再执行函数提升</p><p>变量声明提升<br>通过var定义(声明)的变量, 在定义语句之前就可以访问到<br>值: undefined</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">3</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(a)</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">4</span></span><br><span class="line">&#125;</span><br><span class="line">fn()       <span class="comment">//输出 undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(b) <span class="comment">//undefined  变量提升</span></span><br><span class="line"><span class="keyword">var</span> b = <span class="number">3</span></span><br></pre></td></tr></table></figure><p>函数声明提升：<br>通过function声明的函数, 在之前就可以直接调用<br>值: 函数定义(对象)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">fn2() <span class="comment">//可调用  函数提升</span></span><br><span class="line"><span class="comment">// fn3() //不能  变量提升</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'fn2()'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fn3 = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'fn3()'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="执行上下文"><a href="#执行上下文" class="headerlink" title="执行上下文"></a>执行上下文</h1><p>执行代码时才产生上下文</p><p>全局执行上下文：</p><ul><li>在执行全局代码前将window确定为全局执行上下文</li><li>对全局数据进行预处理<ul><li>var定义的全局变量==&gt;undefined, 添加为window的属性</li><li>function声明的全局函数==&gt;赋值(fun), 添加为window的方法</li><li>this==&gt;赋值(window)</li></ul></li><li>开始执行全局代码</li></ul><p>函数（局部）执行上下文</p><ul><li>在调用函数, 准备执行函数体之前, 创建对应的函数执行上下文对象(虚拟的, 存在于栈中)</li><li>对局部数据进行预处理<ul><li>形参变量==&gt;赋值(实参)==&gt;添加为执行上下文的属性</li><li>arguments==&gt;赋值(实参列表), 添加为执行上下文的属性  </li><li>var定义的局部变量==&gt;undefined, 添加为执行上下文的属性 </li><li>function声明的函数 ==&gt;赋值(fun), 添加为执行上下文的方法</li><li>this==&gt;赋值(调用函数的对象)</li></ul></li><li>开始执行函数体代码</li></ul><h1 id="执行上下文栈"><a href="#执行上下文栈" class="headerlink" title="执行上下文栈"></a>执行上下文栈</h1><p>首先看看以下代码：会产生多少个上下文对象？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> bar = <span class="function"><span class="keyword">function</span> (<span class="params">x</span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> b = <span class="number">5</span></span><br><span class="line">foo(x + b)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span> (<span class="params">y</span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> c = <span class="number">5</span></span><br><span class="line"><span class="built_in">console</span>.log(c + y)</span><br><span class="line">&#125;</span><br><span class="line">bar(<span class="number">10</span>)</span><br><span class="line">bar(<span class="number">10</span>)</span><br></pre></td></tr></table></figure><p>3个？5个？6个？都有可能啊，别急，我们先来看看js存储上下文的机制：</p><ol><li><p>在全局代码执行前, JS引擎就会创建一个栈来存储管理所有的执行上下文对象</p></li><li><p>在全局执行上下文(window)确定后, 将其添加到栈中(压栈)</p></li><li><p>在函数执行上下文创建后, 将其添加到栈中(压栈)</p></li><li><p>在当前函数执行完后,将栈顶的对象移除(出栈)</p></li><li><p>当所有的代码执行完后, 栈中只剩下window</p><p><em>函数执行结束后，其对应的上下文对象就立刻从上下文栈中释放</em><br><img src="/images/js%E9%AB%98%E7%BA%A7-%E4%B8%8A%E4%B8%8B%E6%96%87%E6%A0%88.png" alt="上下文栈"></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> js高级 </category>
          
          <category> 函数 </category>
          
          <category> 执行上下文与执行上下文栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 执行上下文 </tag>
            
            <tag> 执行上下文栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js高级-面试题-原型_原型链</title>
      <link href="/2020/06/10/js%E9%AB%98%E7%BA%A7-%E9%9D%A2%E8%AF%95%E9%A2%98-%E5%8E%9F%E5%9E%8B%E9%93%BE/"/>
      <url>/2020/06/10/js%E9%AB%98%E7%BA%A7-%E9%9D%A2%E8%AF%95%E9%A2%98-%E5%8E%9F%E5%9E%8B%E9%93%BE/</url>
      
        <content type="html"><![CDATA[<h1 id="1-以下代码输出的值是多少"><a href="#1-以下代码输出的值是多少" class="headerlink" title="1 以下代码输出的值是多少"></a>1 以下代码输出的值是多少</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"> A.prototype.n = <span class="number">1</span> </span><br><span class="line"></span><br><span class="line"> <span class="keyword">var</span> b = <span class="keyword">new</span> A()</span><br><span class="line"></span><br><span class="line"> A.prototype = &#123;</span><br><span class="line">   n: <span class="number">2</span>,</span><br><span class="line">   m: <span class="number">3</span></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">var</span> c = <span class="keyword">new</span> A()</span><br><span class="line"> <span class="built_in">console</span>.log(b.n, b.m, c.n, c.m) <span class="comment">// 1 define 2 3</span></span><br></pre></td></tr></table></figure><p>解答：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A.prototype.n = <span class="number">1</span></span><br></pre></td></tr></table></figure><p>这一步 是在A的原型对象内部新增了一个属性 n ，其值为1<br>之后由此时的A创建的实例对象b的隐式原型指向的，也是有该属性的A的原型对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A.prototype = &#123;</span><br><span class="line">    n: <span class="number">2</span>,</span><br><span class="line">    m: <span class="number">3</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>这一操作，是直接在堆内存中重新开辟了一段具有n m两个属性的空间<br>同时A的实例对象地址也从新改变，指向了新开辟的地方<br>即 上述语句与下列语句等价</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A.prototype =<span class="keyword">new</span> <span class="built_in">Object</span> (&#123;</span><br><span class="line">n:<span class="number">2</span>,</span><br><span class="line">m:<span class="number">3</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>以A为构造函数新产生的实例c的 _ _ proto _ _ 的值会继承构造函数的prototype<br>故此时c继承的就是A的现有的prototype的值<br>故c可以通过原型链找到n,m两个属性</p><h1 id="2"><a href="#2" class="headerlink" title="2"></a>2</h1><p>f中有（可以使用）a，b方法吗？Foo中呢？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span> (<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">  <span class="built_in">Object</span>.prototype.a = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'a()'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">Function</span>.prototype.b = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'b()'</span>)oo</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> f = <span class="keyword">new</span> Foo()</span><br></pre></td></tr></table></figure><p>首先来探讨f：<br>所有对象的prototype属性默认指向一个空的Object实例对象，此Object为该对象的原型对象（当然 Object（）除外）<br>实例对象的 _ _ proto  _ _ 指向构造函数的原型对象<br>所以， f的 _ _ proto  _ _ 指向的，也就是Foo函数的Object实例<br>而Object.prototype.a 是给Object的原型对象里面加的方法<br>所以，可以通过f来调用a方法<br>寻找过程：<br>f = &gt; f. _ _ proto  _ _ (Foo.prototype)=&gt;Foo.prototype.   _ _ proto  _ _  = &gt; Object.prototype 找到了<br>同理， f . b找到Object.prototype 也没找到<br>如下图所示：</p><p><img src="/images/%E5%8E%9F%E5%9E%8B%E9%93%BE%E5%87%BD%E6%95%B0%E9%9D%A2%E8%AF%95%E9%A2%981.png" alt="f的原型链"></p><p>接着来讨论Foo函数<br>首先，Foo作为一个函数，其可以理解为这样：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Foo = <span class="keyword">new</span> <span class="built_in">Function</span>()</span><br></pre></td></tr></table></figure><p>我理解为：Function是一切函数的源头，当然Function也是其自己的源头<br>所以，Foo函数可以使用构造函数函数的原型对象内部的b方法<br>同时，由于Function也有自己的原型对象也是一个空的Object实例对象<br>所以Function.prototype.b添加的方法，Foo也可以调用<br>同时Function指向了Object实例对象，所以Foo也可以调用a方法</p><p><img src="/images/%E5%8E%9F%E5%9E%8B%E9%93%BE%E5%87%BD%E6%95%B0%E9%9D%A2%E8%AF%95%E9%A2%982.png" alt="F的原型链"></p><p>F.a() F没有a属性，往原型上找<br>F.<em>proto</em> = Function.prototype 没找到a<br>Function.prototype.<em>proto</em> = Object.prototype  找到了<br>同理F.b找到Function.prototype时找到了</p><blockquote><p><a href="https://juejin.im/post/5c72a1766fb9a049ea3993e6" target="_blank" rel="noopener">还是理解不了的话，可以看一下这里的内容</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> js高级 </category>
          
          <category> 面试题 </category>
          
          <category> 原型链 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 原型链面试 </tag>
            
            <tag> js面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js高级-原型_原型链</title>
      <link href="/2020/06/09/js%E9%AB%98%E7%BA%A7-%E5%87%BD%E6%95%B0-%E5%8E%9F%E5%9E%8B_%E5%8E%9F%E5%9E%8B%E9%93%BE/"/>
      <url>/2020/06/09/js%E9%AB%98%E7%BA%A7-%E5%87%BD%E6%95%B0-%E5%8E%9F%E5%9E%8B_%E5%8E%9F%E5%9E%8B%E9%93%BE/</url>
      
        <content type="html"><![CDATA[<h1 id="原型（prototype）"><a href="#原型（prototype）" class="headerlink" title="原型（prototype）"></a>原型（prototype）</h1><p>函数的prototype属性(图)<br>1 每个函数都有一个prototype属性, 它默认指向一个Object空对象(即称为: 原型对象)<br>2 原型对象中有一个属性constructor, 它指向函数对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 每个函数都有一个prototype属性, 它默认指向一个Object空对象(即称为: 原型对象)</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Date</span>.prototype, <span class="keyword">typeof</span> <span class="built_in">Date</span>.prototype)</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fun</span> (<span class="params"></span>) </span>&#123;<span class="comment">//alt + shift +r(重命名rename)</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(Fun.prototype)  <span class="comment">// 默认指向一个Object空对象(没有我们的属性)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 原型对象中有一个属性constructor, 它指向函数对象</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Date</span>.prototype.constructor===<span class="built_in">Date</span>)</span><br><span class="line"><span class="built_in">console</span>.log(Fun.prototype.constructor===Fun)</span><br></pre></td></tr></table></figure><p>给原型对象添加属性(一般都是方法)<br>作用: 函数的所有实例对象自动拥有原型中的属性(方法)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//给原型对象添加属性(一般是方法) ===&gt;实例对象可以访问</span></span><br><span class="line">Fun.prototype.test = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'test()'</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> fun = <span class="keyword">new</span> Fun()</span><br><span class="line">fun.test()</span><br></pre></td></tr></table></figure><h1 id="显示原型（属性）和隐式原型（属性）"><a href="#显示原型（属性）和隐式原型（属性）" class="headerlink" title="显示原型（属性）和隐式原型（属性）"></a>显示原型（属性）和隐式原型（属性）</h1><ol><li>每个函数function都有一个prototype，即显式原型(属性)</li><li>每个实例对象都有一个<strong>proto</strong>，可称为隐式原型(属性)</li><li>对象的隐式原型的值为其对应构造函数的显式原型的值</li><li>内存结构(图)</li><li>总结:</li></ol><ul><li>函数的prototype属性: 在定义函数时自动添加的, 默认值是一个空Object对象</li><li>对象的<strong>proto</strong>属性: 创建对象时自动添加的, 默认值为构造函数的prototype属性值</li><li>程序员能直接操作显式原型, 但不能直接操作隐式原型(ES6之前)</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.__proto__)</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.test1 = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'test1()'</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(Fn.prototype)</span><br><span class="line">Fn.prototype.test2 = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'test2()'</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> fn = <span class="keyword">new</span> Fn()</span><br><span class="line">fn.test1()</span><br><span class="line">fn.test2()</span><br><span class="line"><span class="built_in">console</span>.log(fn.toString())</span><br><span class="line"><span class="built_in">console</span>.log(fn.test3)</span><br><span class="line"><span class="comment">// fn.test3()</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1. 函数的显示原型指向的对象默认是空Object实例对象(但Object不满足)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="built_in">console</span>.log(Fn.prototype <span class="keyword">instanceof</span> <span class="built_in">Object</span>) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype <span class="keyword">instanceof</span> <span class="built_in">Object</span>) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Function</span>.prototype <span class="keyword">instanceof</span> <span class="built_in">Object</span>) <span class="comment">// true</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">2. 所有函数都是Function的实例(包含Function)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Function</span>.__proto__===<span class="built_in">Function</span>.prototype)</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">3. Object的原型对象是原型链尽头</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.__proto__) <span class="comment">// null</span></span><br></pre></td></tr></table></figure><p><img src="/images/%E6%98%BE%E5%BC%8F%E5%8E%9F%E5%9E%8B%E4%B8%8E%E9%9A%90%E5%BC%8F%E5%8E%9F%E5%9E%8B.png" alt="显式原型与隐式原型"></p><h1 id="原型链-隐式原型链"><a href="#原型链-隐式原型链" class="headerlink" title="原型链(隐式原型链)"></a>原型链(隐式原型链)</h1><p>作用: 查找对象的属性(方法)</p><p>访问一个对象的属性时的查找顺序:</p><ul><li>先在自身属性中查找，找到返回</li><li>如果没有, 再沿着<strong>proto</strong>这条链向上查找, 找到返回</li><li>如果最终没找到, 返回undefined</li></ul><p><img src="/images/%E5%8E%9F%E5%9E%8B%E9%93%BE%E5%88%86%E6%9E%90.png" alt="原型链分析"></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.__proto__)</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.test1 = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'test1()'</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(Fn.prototype)</span><br><span class="line">Fn.prototype.test2 = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'test2()'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fn = <span class="keyword">new</span> Fn()</span><br><span class="line"></span><br><span class="line">fn.test1()</span><br><span class="line">fn.test2()</span><br><span class="line"><span class="built_in">console</span>.log(fn.toString())</span><br><span class="line"><span class="built_in">console</span>.log(fn.test3)</span><br><span class="line"><span class="comment">// fn.test3()console.log(Object.prototype)</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.__proto__)</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.test1 = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'test1()'</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(Fn.prototype)</span><br><span class="line">Fn.prototype.test2 = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'test2()'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fn = <span class="keyword">new</span> Fn()</span><br><span class="line"></span><br><span class="line">fn.test1()</span><br><span class="line">fn.test2()</span><br><span class="line"><span class="built_in">console</span>.log(fn.toString())</span><br><span class="line"><span class="built_in">console</span>.log(fn.test3)</span><br></pre></td></tr></table></figure><p>注意几种特殊情况</p><ol><li>函数的显示原型指向的对象默认是空Object实例对象(但Object不满足)</li><li>所有函数都是Function的实例(包含Function)</li><li>Object的原型对象是原型链尽头<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1. 函数的显示原型指向的对象默认是空Object实例对象(但Object不满足)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="built_in">console</span>.log(Fn.prototype <span class="keyword">instanceof</span> <span class="built_in">Object</span>) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype <span class="keyword">instanceof</span> <span class="built_in">Object</span>) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Function</span>.prototype <span class="keyword">instanceof</span> <span class="built_in">Object</span>) <span class="comment">// true</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">2. 所有函数都是Function的实例(包含Function)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Function</span>.__proto__===<span class="built_in">Function</span>.prototype)</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">3. Object的原型对象是原型链尽头</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.__proto__) <span class="comment">// null</span></span><br></pre></td></tr></table></figure><h1 id="原型链-属性读取"><a href="#原型链-属性读取" class="headerlink" title="原型链_属性读取"></a>原型链_属性读取</h1></li><li>读取对象的属性值时: 会自动到原型链中查找</li><li>设置对象的属性值时: 不会查找原型链, 如果当前对象中没有此属性, 直接添加此属性并设置其值</li><li>方法一般定义在原型中, 属性一般通过构造函数定义在对象本身上</li></ol><h1 id="探索instanceof"><a href="#探索instanceof" class="headerlink" title="探索instanceof"></a>探索instanceof</h1><ol><li>instanceof是如何判断的?<ul><li>表达式: A instanceof B</li><li>如果B函数的显式原型对象在A对象的原型链上, 返回true, 否则返回false</li></ul></li><li>Function是通过new自己产生的实例<br>即：function name（）&lt;===&gt; name = new Function （）{}</li></ol>]]></content>
      
      
      <categories>
          
          <category> js高级 </category>
          
          <category> 函数 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> prototype </tag>
            
            <tag> 原型 </tag>
            
            <tag> 原型链 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js高级-IEFE+this</title>
      <link href="/2020/06/09/js%E9%AB%98%E7%BA%A7-%E5%9F%BA%E7%A1%80-IEFE/"/>
      <url>/2020/06/09/js%E9%AB%98%E7%BA%A7-%E5%9F%BA%E7%A1%80-IEFE/</url>
      
        <content type="html"><![CDATA[<h1 id="IEFE"><a href="#IEFE" class="headerlink" title="IEFE"></a>IEFE</h1><blockquote><p>Immediately-Invoked Function Expression（立即执行函数表达式）<br>匿名函数自调用</p></blockquote><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><ul><li>隐藏实现</li><li>不会污染外部（全局）命名空间</li><li>用它来编码js模块<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="comment">//匿名函数自调用</span></span><br><span class="line">        <span class="keyword">var</span> a = <span class="number">3</span></span><br><span class="line">        <span class="built_in">console</span>.log(a + <span class="number">3</span>)</span><br><span class="line">        &#125;)()</span><br><span class="line">        <span class="keyword">var</span> a = <span class="number">4</span></span><br><span class="line">        <span class="built_in">console</span>.log(a)<span class="comment">// 4</span></span><br></pre></td></tr></table></figure><h1 id="THIS"><a href="#THIS" class="headerlink" title="THIS"></a>THIS</h1><blockquote><p>主要研究函数中的this</p></blockquote></li></ul><h2 id="this是什么"><a href="#this是什么" class="headerlink" title="this是什么"></a>this是什么</h2><ul><li>任何函数本质上都是通过某个对象来调用的,如果没有直接指定就是window</li><li>所有函数内部都有一个变量this</li><li>它的值是调用函数的当前对象</li></ul><h2 id="确定this的值"><a href="#确定this的值" class="headerlink" title="确定this的值"></a>确定this的值</h2><ul><li>test(): window</li><li>p.test(): p</li><li>new test(): 新创建的对象</li><li>p.call(obj): obj</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">color</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>)</span><br><span class="line">    <span class="keyword">this</span>.color = color;</span><br><span class="line">    <span class="keyword">this</span>.getColor = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="keyword">this</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.color;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">this</span>.setColor = <span class="function"><span class="keyword">function</span> (<span class="params">color</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="keyword">this</span>)</span><br><span class="line">      <span class="keyword">this</span>.color = color;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person(<span class="string">"red"</span>); <span class="comment">//this是谁? window</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Person(<span class="string">"yello"</span>); <span class="comment">//this是谁? p</span></span><br><span class="line"></span><br><span class="line">p.getColor(); <span class="comment">//this是谁? p</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line">p.setColor.call(obj, <span class="string">"black"</span>); <span class="comment">//this是谁? obj</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> test = p.setColor;</span><br><span class="line">test(); <span class="comment">//this是谁? window</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">fun1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">fun2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">    fun2(); <span class="comment">//this是谁? window</span></span><br><span class="line">  &#125;</span><br><span class="line">  fun1();</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> js高级 </category>
          
          <category> js基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IEFE </tag>
            
            <tag> this </tag>
            
            <tag> js高级 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js高级-函数</title>
      <link href="/2020/06/09/js%E9%AB%98%E7%BA%A7-%E5%9F%BA%E7%A1%80-%E5%87%BD%E6%95%B0/"/>
      <url>/2020/06/09/js%E9%AB%98%E7%BA%A7-%E5%9F%BA%E7%A1%80-%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是函数"><a href="#什么是函数" class="headerlink" title="什么是函数"></a>什么是函数</h1><ul><li><p>实现特定功能的多条语句的封装体</p></li><li><p>只有函数可以执行 其他类型数据无法执行</p><h1 id="为什么要用函数"><a href="#为什么要用函数" class="headerlink" title="为什么要用函数"></a>为什么要用函数</h1></li><li><p>提高代码复用</p></li><li><p>便于阅读和交流</p><h1 id="如何定义"><a href="#如何定义" class="headerlink" title="如何定义"></a>如何定义</h1><p>两种方式</p></li><li><p>函数声明</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn1</span> (<span class="params"></span>) </span>&#123; <span class="comment">//函数声明</span></span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'fn1()'</span>)</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></li><li><p>表达式</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">var</span> fn2 = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="comment">//表达式</span></span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'fn2()'</span>)</span><br><span class="line">        &#125;</span><br><span class="line"><span class="string">``</span><span class="string">`  </span></span><br><span class="line"><span class="string"># 如何调用</span></span><br><span class="line"><span class="string">* test(): 直接调用</span></span><br><span class="line"><span class="string">* obj.test(): 通过对象调用</span></span><br><span class="line"><span class="string">* new test(): new调用</span></span><br><span class="line"><span class="string">* test.call/apply(obj): 临时让test成为obj的方法进行调用</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># 回调函数</span></span><br><span class="line"><span class="string">* 特殊的函数（三个特点）</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">用户或者系统内部定义的</span></span><br><span class="line"><span class="string">没有调用</span></span><br><span class="line"><span class="string">最终函数执行了</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">* 常见的回调函数</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">dom事件回调函数</span></span><br><span class="line"><span class="string">`</span><span class="string">``</span>js</span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">'btn'</span>).onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="comment">// dom事件回调函数</span></span><br><span class="line">alert(<span class="keyword">this</span>.innerHTML)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>定时器回调函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="comment">// 定时器回调函数</span></span><br><span class="line">alert(<span class="string">'到点了'</span>+<span class="keyword">this</span>)</span><br><span class="line">&#125;, <span class="number">2000</span>)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> js高级 </category>
          
          <category> js基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js函数 </tag>
            
            <tag> 函数调用 </tag>
            
            <tag> 回调函数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js高级-对象基础</title>
      <link href="/2020/06/09/js%E9%AB%98%E7%BA%A7-%E5%9F%BA%E7%A1%80-%E5%AF%B9%E8%B1%A1/"/>
      <url>/2020/06/09/js%E9%AB%98%E7%BA%A7-%E5%9F%BA%E7%A1%80-%E5%AF%B9%E8%B1%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是对象"><a href="#什么是对象" class="headerlink" title="什么是对象"></a>什么是对象</h1><p>多个数据的分装体<br>用来保存多个数据的容器<br>可以类比现实中的具有多个属性的事物</p><h1 id="为什么要用对象"><a href="#为什么要用对象" class="headerlink" title="为什么要用对象"></a>为什么要用对象</h1><p>统一管理多个数据</p><h1 id="对象的组成"><a href="#对象的组成" class="headerlink" title="对象的组成"></a>对象的组成</h1><p>属性：属性名(字符串)和属性值(任意)组成<br>方法：一种特别的属性(属性值是函数)</p><h1 id="如何访问对象内部数据"><a href="#如何访问对象内部数据" class="headerlink" title="如何访问对象内部数据"></a>如何访问对象内部数据</h1><p>. + 属性名: 编码简单, 有时不能用<br>[ ‘属性’ ]: 编码麻烦, 能通用</p><h1 id="何时使用-属性名"><a href="#何时使用-属性名" class="headerlink" title="何时使用[属性名]"></a>何时使用[属性名]</h1><p>属性名中含有特殊字符： “ - ” ，空格等</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p = &#123;&#125;</span><br><span class="line">        <span class="comment">// p.content-type = 'text/json' //不能用</span></span><br><span class="line">        p[<span class="string">'content-type'</span>] = <span class="string">'text/json'</span></span><br><span class="line">        <span class="built_in">console</span>.log(p[<span class="string">'content-type'</span>])<span class="comment">//text/json</span></span><br><span class="line">        <span class="built_in">console</span>.log(p.content-type)<span class="comment">//报错</span></span><br></pre></td></tr></table></figure><p>属性名为变量时</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> propName = <span class="string">'myAge'</span></span><br><span class="line">        <span class="keyword">var</span> value = <span class="number">18</span></span><br><span class="line">        <span class="comment">// p.propName = value //不能用</span></span><br><span class="line">        p[propName] = value</span><br><span class="line">        <span class="built_in">console</span>.log(p[propName])</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> js高级 </category>
          
          <category> js基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js对象 </tag>
            
            <tag> 对象基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js高级-数据，变量，内存</title>
      <link href="/2020/06/08/js%E9%AB%98%E7%BA%A7-%E5%9F%BA%E7%A1%80-%E6%95%B0%E6%8D%AE_%E5%8F%98%E9%87%8F_%E5%86%85%E5%AD%98/"/>
      <url>/2020/06/08/js%E9%AB%98%E7%BA%A7-%E5%9F%BA%E7%A1%80-%E6%95%B0%E6%8D%AE_%E5%8F%98%E9%87%8F_%E5%86%85%E5%AD%98/</url>
      
        <content type="html"><![CDATA[<p>内存,数据, 变量三者之间的关系:<br>1 内存用来存储数据的空间<br>2 变量是内存的标识</p><h1 id="什么是数据"><a href="#什么是数据" class="headerlink" title="什么是数据?"></a>什么是数据?</h1><ul><li>存储在内存中代表特定信息的’东东’, 本质上是0101…</li><li>数据的特点: 可传递, 可运算</li><li>一切皆数据</li><li>内存中所有操作的目标: 数据<ul><li>算术运算 逻辑运算 赋值 运行函数<h1 id="什么是内存"><a href="#什么是内存" class="headerlink" title="什么是内存?"></a>什么是内存?</h1></li></ul></li><li>内存条通电后产生的可储存数据的空间(临时的)</li><li>内存产生和死亡: 内存条(电路版)==&gt;通电==&gt;产生内存空间==&gt;存储数据==&gt;处理数据==&gt;断电==&gt;内存空间和数据都消失</li><li>一块小内存的2个数据<ul><li>内部存储的数据</li><li>地址值</li></ul></li><li>内存分类<ul><li>栈: 全局变量/局部变量</li><li>堆: 对象<h1 id="什么是变量"><a href="#什么是变量" class="headerlink" title="什么是变量?"></a>什么是变量?</h1></li></ul></li><li>可变化的量, 由变量名和变量值组成</li><li>每个变量都对应的一块小内存, 变量名用来查找对应的内存, 变量值就是内存中保存的数据</li></ul><h1 id="问题："><a href="#问题：" class="headerlink" title="问题："></a>问题：</h1><ol><li><p>赋值和内存: var a = xxx, a内存中到底保存的是什么?</p><ul><li>xxx 是基本数据, 保存的就是这个数据</li><li>xxx 是对象, 保存的是对象的地址值</li><li>xxx 是一个变量, 保存的xxx的内存内容(可能是基本数据, 也可能是地址值</li></ul></li><li><p>引用变量赋值问题<br>问题1：2个引用变量指向同一个对象, 通过一个变量修改对象内部数据, 另一个变量看到的是修改之后的数据</p></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj1 = &#123;<span class="attr">name</span>: <span class="string">'Tom'</span>&#125;</span><br><span class="line"><span class="keyword">var</span> obj2 = obj1</span><br><span class="line">obj2.age = <span class="number">12</span></span><br><span class="line"><span class="built_in">console</span>.log(obj1.age)  <span class="comment">// 12</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span> (<span class="params">obj</span>) </span>&#123;</span><br><span class="line">obj.name = <span class="string">'A'</span></span><br><span class="line">&#125;</span><br><span class="line">fn(obj1)</span><br><span class="line"><span class="built_in">console</span>.log(obj2.name) <span class="comment">//A</span></span><br></pre></td></tr></table></figure><p>问题2：2个引用变量指向同一个对象, 让其中一个引用变量指向另一个对象, 另一引用变量依然指向前一个对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123;<span class="attr">age</span>: <span class="number">12</span>&#125;</span><br><span class="line"><span class="keyword">var</span> b = a</span><br><span class="line">a = &#123;<span class="attr">name</span>: <span class="string">'BOB'</span>, <span class="attr">age</span>: <span class="number">13</span>&#125;</span><br><span class="line">b.age = <span class="number">14</span></span><br><span class="line"><span class="built_in">console</span>.log(b.age, a.name, a.age) <span class="comment">// 14 Bob 13</span></span><br></pre></td></tr></table></figure><ol start="3"><li>函数参数传递问题：在js调用函数时传递变量参数时, 是值传递还是引用传递（地址值）<br>理解1: 都是值(基本/地址值)传递<br>理解2: 可能是值传递, 也可能是引用传递(地址值)</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">3</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span> (<span class="params">a</span>) </span>&#123;</span><br><span class="line">a = a +<span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">fn(a)</span><br><span class="line"><span class="built_in">console</span>.log(a)<span class="comment">//a=3</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn2</span> (<span class="params">obj</span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(obj.name)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;<span class="attr">name</span>: <span class="string">'Tom'</span>&#125;</span><br><span class="line">fn2(obj)</span><br></pre></td></tr></table></figure><ol start="4"><li>通过函数修改变量值问题：<br>基本变量 ：无法修改<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">x = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">foo(a);</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// 仍为1, 未受x = 2赋值所影响</span></span><br></pre></td></tr></table></figure>引用变量 ：修改形参来修改原变量 ❌<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;<span class="attr">x</span> : <span class="number">1</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">o = <span class="number">100</span>;</span><br><span class="line">&#125;</span><br><span class="line">foo(obj);</span><br><span class="line"><span class="built_in">console</span>.log(obj.x); <span class="comment">// 仍然是1, obj并未被修改为100.</span></span><br></pre></td></tr></table></figure>修改形参的属性值来修改原变量的对应属性值<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;<span class="attr">x</span> : <span class="number">1</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">o.x = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line">foo(obj);</span><br><span class="line"><span class="built_in">console</span>.log(obj.x); <span class="comment">// 3, 被修改了!</span></span><br></pre></td></tr></table></figure></li><li>内存管理：JS引擎如何管理内存?<br>内存生命周期<br>1 分配小内存空间, 得到它的使用权<br>2 存储数据, 可以反复进行操作<br>3 释放小内存空间<br>释放内存<br>1 局部变量: 函数执行完自动释放<br>2 对象: 成为垃圾对象==&gt;垃圾回收器回收<br>垃圾对象：我理解为不被引用的对象</li></ol>]]></content>
      
      
      <categories>
          
          <category> js高级 </category>
          
          <category> js基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 变量赋值 </tag>
            
            <tag> 函数参数传递 </tag>
            
            <tag> 内存管理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据类型</title>
      <link href="/2020/06/08/js%E9%AB%98%E7%BA%A7-%E5%87%BD%E6%95%B0-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
      <url>/2020/06/08/js%E9%AB%98%E7%BA%A7-%E5%87%BD%E6%95%B0-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h1><ul><li>基本类型<ul><li>string：任意字符串</li><li>number：任意数字</li><li>Boolean：true/false</li><li>undefined：undefined，未赋值的var变量</li><li>null：null</li></ul></li><li>对象（引用）类型<ul><li>object：任意对象</li><li>function：特别的对象（可以执行）</li><li>array：特别的对象（数值下标，内部数据有序）</li></ul></li></ul><h1 id="类型判断"><a href="#类型判断" class="headerlink" title="类型判断"></a>类型判断</h1><ul><li>typeof:<ul><li>可以判断: undefined/ 数值 / 字符串 / 布尔值 / function</li><li>不能判断: null与object  object与array</li></ul></li><li>instanceof：<ul><li>可以判断对象类型 </li></ul></li><li>===:<ul><li>可以判断undefined和null</li></ul></li></ul><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><ul><li>undefined 和null的区别<ul><li>undefine:代表变量定义未赋值</li><li>null：变量的一种特殊的值</li></ul></li><li>何时使用null？<ul><li>初始赋值为null，在开始对象内容不明确时，表明将来赋值为对象</li><li>结束时赋值为null，内存回收，被垃圾回收器回收</li></ul></li><li>严格区分变量类型和数据类型<ul><li>数据的类型<ul><li>基本类型</li><li>对象类型</li></ul></li><li>变量的类型(变量内存值的类型)<ul><li>基本类型: 保存就是基本类型的数据</li><li>引用类型: 保存的是地址值</li></ul></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> js高级 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js数据类型 </tag>
            
            <tag> typeof </tag>
            
            <tag> instanceof </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
