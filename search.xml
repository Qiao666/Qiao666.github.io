<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>剑指offer-29顺时针打印矩阵</title>
      <link href="/2020/07/13/%E5%89%91%E6%8C%87offer-29%E9%A1%BA%E6%97%B6%E9%92%88%E6%89%93%E5%8D%B0%E7%9F%A9%E9%98%B5/"/>
      <url>/2020/07/13/%E5%89%91%E6%8C%87offer-29%E9%A1%BA%E6%97%B6%E9%92%88%E6%89%93%E5%8D%B0%E7%9F%A9%E9%98%B5/</url>
      
        <content type="html"><![CDATA[<h1 id="29顺时针打印矩阵"><a href="#29顺时针打印矩阵" class="headerlink" title="29顺时针打印矩阵"></a>29顺时针打印矩阵</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。</p><blockquote><p>示例 1：<br>输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]<br>输出：[1,2,3,6,9,8,7,4,5]<br>示例 2：<br>输入：matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]<br>输出：[1,2,3,4,8,12,11,10,9,5,6,7]<br>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/shun-shi-zhen-da-yin-ju-zhen-lcof" target="_blank" rel="noopener">https://leetcode-cn.com/problems/shun-shi-zhen-da-yin-ju-zhen-lcof</a></p></blockquote><h2 id="算法分析-代码实现"><a href="#算法分析-代码实现" class="headerlink" title="算法分析+代码实现"></a>算法分析+代码实现</h2><p>1 一层一层循环，直到最后一层，通过添加判定条件来确定什么时候跳出循环</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> spiralOrder = <span class="function"><span class="keyword">function</span>(<span class="params">matrix</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!matrix.length)&#123;</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> res = [];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> right = matrix[<span class="number">0</span>].length<span class="number">-1</span></span><br><span class="line">    <span class="keyword">let</span> down=matrix.length<span class="number">-1</span></span><br><span class="line">    <span class="keyword">let</span> left = <span class="number">0</span></span><br><span class="line">    <span class="keyword">let</span> up = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span>(left&lt;=right&amp;&amp;up&lt;=down)&#123;</span><br><span class="line">        <span class="comment">//最上边从左到右</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> r=left;r&lt;=right;r++)&#123;</span><br><span class="line">            res.push(matrix[up][r])</span><br><span class="line">        &#125;       </span><br><span class="line">            up++;</span><br><span class="line">        <span class="comment">//最右边从上到下</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> d=up;d&lt;=down;d++)&#123;</span><br><span class="line">            res.push(matrix[d][right])</span><br><span class="line">        &#125;       </span><br><span class="line">            right--;</span><br><span class="line">        <span class="comment">//确定循环结束条件，保证不会多次递归</span></span><br><span class="line">        <span class="keyword">if</span>(up&gt;down||right&lt;left) <span class="keyword">break</span>;      </span><br><span class="line">        </span><br><span class="line">        <span class="comment">//最下边从右到左</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> l =right;l&gt;=left;l--)&#123;</span><br><span class="line">            res.push(matrix[down][l])</span><br><span class="line">        &#125;</span><br><span class="line">            down--;</span><br><span class="line">        <span class="comment">//最左边从下到上</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> u = down;u&gt;=up;u--)&#123;</span><br><span class="line">            res.push(matrix[u][left])</span><br><span class="line">        &#125;</span><br><span class="line">            left++   </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>结果：<br>执行用时：96 ms, 在所有 JavaScript 提交中击败了77.67%的用户<br>内存消耗：39.1 MB, 在所有 JavaScript 提交中击败了100.00%的用户<br>2 思路大致一样，但是只遍历环，最后一行或者最后一列在循环外输出</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> spiralOrder = <span class="function"><span class="keyword">function</span>(<span class="params">matrix</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!matrix.length)&#123;</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> res = [];</span><br><span class="line">    <span class="keyword">let</span> right = matrix[<span class="number">0</span>].length<span class="number">-1</span></span><br><span class="line">    <span class="keyword">let</span> down=matrix.length<span class="number">-1</span></span><br><span class="line">    <span class="keyword">let</span> left = <span class="number">0</span></span><br><span class="line">    <span class="keyword">let</span> up = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span>(left&lt;right&amp;&amp;up&lt;down)&#123;</span><br><span class="line">        <span class="comment">//最上边从左到右</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> r=left;r&lt;right;r++)&#123;</span><br><span class="line">            res.push(matrix[up][r])</span><br><span class="line">        &#125;       </span><br><span class="line">            </span><br><span class="line">        <span class="comment">//最右边从上到下</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> d=up;d&lt;down;d++)&#123;</span><br><span class="line">            res.push(matrix[d][right])</span><br><span class="line">        &#125;       </span><br><span class="line">            </span><br><span class="line">        </span><br><span class="line">        <span class="comment">//最下边从右到左</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> l =right;l&gt;left;l--)&#123;</span><br><span class="line">            res.push(matrix[down][l])</span><br><span class="line">        &#125;</span><br><span class="line">            </span><br><span class="line">        <span class="comment">//最左边从下到上</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> u = down;u&gt;up;u--)&#123;</span><br><span class="line">            res.push(matrix[u][left])</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//循环结束以后，环向内收缩</span></span><br><span class="line">            up++;</span><br><span class="line">            right--;   </span><br><span class="line">            down--; </span><br><span class="line">            left++;  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//注意跳出循环后，判断条件包括了等于号</span></span><br><span class="line">    <span class="comment">//上下相等，只剩中间一行</span></span><br><span class="line">    <span class="keyword">if</span>(up===down)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> r=left;r&lt;=right;r++)&#123;</span><br><span class="line">            res.push(matrix[up][r])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//左右相等，只剩最后一列</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(left===right)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> d=up;d&lt;=down;d++)&#123;</span><br><span class="line">            res.push(matrix[d][right])</span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>结果：<br>执行用时：104 ms, 在所有 JavaScript 提交中击败了45.70%的用户<br>内存消耗：39.6 MB, 在所有 JavaScript 提交中击败了100.00%的用户</p><p>链接：<a href="https://leetcode-cn.com/problems/shun-shi-zhen-da-yin-ju-zhen-lcof/solution/shou-hui-tu-jie-liang-chong-bian-li-de-ce-lue-na-c/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/shun-shi-zhen-da-yin-ju-zhen-lcof/solution/shou-hui-tu-jie-liang-chong-bian-li-de-ce-lue-na-c/</a></p><h2 id="总结反思"><a href="#总结反思" class="headerlink" title="总结反思"></a>总结反思</h2><p>多列举一些特殊情况来总结循环终止条件<br>同时注意排除特殊情况<br>在js中 []!=null 最好通过array.length来判断该数组是否为空</p>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
          <category> 29顺时针打印矩阵 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 矩阵 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer-28对称的二叉树</title>
      <link href="/2020/07/13/%E5%89%91%E6%8C%87offer-28%E5%AF%B9%E7%A7%B0%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
      <url>/2020/07/13/%E5%89%91%E6%8C%87offer-28%E5%AF%B9%E7%A7%B0%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h1 id="28对称的二叉树"><a href="#28对称的二叉树" class="headerlink" title="28对称的二叉树"></a>28对称的二叉树</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>请实现一个函数，用来判断一棵二叉树是不是对称的。如果一棵二叉树和它的镜像一样，那么它是对称的。<br>例如，二叉树 [1,2,2,3,4,4,3] 是对称的。<br>    1<br>   / <br>  2   2<br> / \ / <br>3  4 4  3<br>但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的:<br>    1<br>   / <br>  2   2<br>   \   <br>   3    3</p><blockquote><p>示例 1：<br>输入：root = [1,2,2,3,4,4,3]<br>输出：true<br>示例 2：<br>输入：root = [1,2,2,null,3,null,3]<br>输出：false<br>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/dui-cheng-de-er-cha-shu-lcof" target="_blank" rel="noopener">https://leetcode-cn.com/problems/dui-cheng-de-er-cha-shu-lcof</a></p></blockquote><h2 id="算法分析-代码实现"><a href="#算法分析-代码实现" class="headerlink" title="算法分析+代码实现"></a>算法分析+代码实现</h2><p>1 递归算法解决</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> isSymmetric = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> isEquir = <span class="function"><span class="keyword">function</span>(<span class="params">root1,  root2</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//两个节点都是空，则二者相等</span></span><br><span class="line">    <span class="keyword">if</span>(!root1&amp;&amp;!root2)&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">true</span> </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//有一个不为空</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(!root1||!root2)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回比较值：当前节点给相等，比较左子树的左节点和右子树的右节点；左子树的右节点和右子树的左节点</span></span><br><span class="line">    <span class="keyword">return</span> root1.val==root2.val &amp;&amp; isEquir(root1.left,root2.right) &amp;&amp; isEquir(root1.right,root2.left)</span><br><span class="line">&#125;   </span><br><span class="line">    <span class="comment">//直接从根节点开始比较，不需要考虑空树</span></span><br><span class="line">    <span class="keyword">return</span> isEquir(root,root)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>结果：<br>执行用时：84 ms, 在所有 JavaScript 提交中击败了43.39%的用户<br>内存消耗：36.7 MB, 在所有 JavaScript 提交中击败了100.00%的用户</p><h2 id="总结反思"><a href="#总结反思" class="headerlink" title="总结反思"></a>总结反思</h2><p>双参数，需要再写一个递归函数<br>递归函数还是要多看，多理解多掌握</p>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
          <category> 28对称的二叉树 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树 </tag>
            
            <tag> 递归 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer-27二叉树的镜像</title>
      <link href="/2020/07/13/%E5%89%91%E6%8C%87offer-27%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%95%9C%E5%83%8F/"/>
      <url>/2020/07/13/%E5%89%91%E6%8C%87offer-27%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%95%9C%E5%83%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="27二叉树的镜像"><a href="#27二叉树的镜像" class="headerlink" title="27二叉树的镜像"></a>27二叉树的镜像</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>请完成一个函数，输入一个二叉树，该函数输出它的镜像。</p><blockquote><p>例如输入：<br>     4<br>   /   <br>  2     7<br> / \   / <br>1   3 6   9<br>镜像输出：<br>     4<br>   /   <br>  7     2<br> / \   / <br>9   6 3   1<br>示例 1：<br>输入：root = [4,2,7,1,3,6,9]<br>输出：[4,7,2,9,6,3,1]<br>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/er-cha-shu-de-jing-xiang-lcof" target="_blank" rel="noopener">https://leetcode-cn.com/problems/er-cha-shu-de-jing-xiang-lcof</a></p></blockquote><h2 id="算法分析-代码实现"><a href="#算法分析-代码实现" class="headerlink" title="算法分析+代码实现"></a>算法分析+代码实现</h2><p>递归算法，先上后下直接递归就好</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mirrorTree = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root)&#123;</span><br><span class="line">        <span class="keyword">return</span> root</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(root.left||root.right)&#123;</span><br><span class="line">        <span class="keyword">let</span> test = root.left;</span><br><span class="line">        root.left = root.right;</span><br><span class="line">        root.right = test;</span><br><span class="line">    &#125;</span><br><span class="line">    mirrorTree(root.left)</span><br><span class="line">    mirrorTree(root.right)</span><br><span class="line">    <span class="keyword">return</span> root</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>结果：<br>执行用时：88 ms, 在所有 JavaScript 提交中击败了7.32%的用户<br>内存消耗：33.1 MB, 在所有 JavaScript 提交中击败了100.00%的用户</p><h2 id="总结反思"><a href="#总结反思" class="headerlink" title="总结反思"></a>总结反思</h2><p>一定要先理解函数过程，再设计递归函数，这样才能又快又好地写出递归算法</p>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
          <category> 27二叉树的镜像 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树 </tag>
            
            <tag> 递归 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer-26树的子结构</title>
      <link href="/2020/07/12/%E5%89%91%E6%8C%87offer-26%E6%A0%91%E7%9A%84%E5%AD%90%E7%BB%93%E6%9E%84/"/>
      <url>/2020/07/12/%E5%89%91%E6%8C%87offer-26%E6%A0%91%E7%9A%84%E5%AD%90%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h1 id="26树的子结构"><a href="#26树的子结构" class="headerlink" title="26树的子结构"></a>26树的子结构</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入两棵二叉树A和B，判断B是不是A的子结构。(约定空树不是任意一个树的子结构)<br>B是A的子结构， 即 A中有出现和B相同的结构和节点值。<br>例如:<br>给定的树 A:</p><pre><code> 3/ \</code></pre><p>   4   5<br>  / <br> 1   2<br>给定的树 B：<br>   4<br>  /<br> 1<br>返回 true，因为 B 与 A 的一个子树拥有相同的结构和节点值。</p><blockquote><p>示例 1：<br>输入：A = [1,2,3], B = [3,1]<br>输出：false<br>示例 2：<br>输入：A = [3,4,5,1,2], B = [4,1]<br>输出：true</p></blockquote><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/shu-de-zi-jie-gou-lcof" target="_blank" rel="noopener">https://leetcode-cn.com/problems/shu-de-zi-jie-gou-lcof</a></p><h2 id="算法分析-代码实现"><a href="#算法分析-代码实现" class="headerlink" title="算法分析+代码实现"></a>算法分析+代码实现</h2><p>递归算法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> isSubStructure = <span class="function"><span class="keyword">function</span>(<span class="params">A, B</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//空树不是任意一个树的子结构</span></span><br><span class="line">    <span class="keyword">if</span>(!A||!B)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断A当前节点，或者A左子节点，或者右子节点和B</span></span><br><span class="line">    <span class="keyword">return</span> isEqual(A,B)||isSubStructure(A.left,B)||isSubStructure(A.right,B)     </span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> isEqual = <span class="function"><span class="keyword">function</span>(<span class="params">A,B</span>)</span>&#123;</span><br><span class="line">        <span class="comment">//B遍历结束，说明匹配成功</span></span><br><span class="line">        <span class="keyword">if</span>(!B)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//A遍历结束，B还没结束，肯定不匹配</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(!A)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//A,B值不相等，返回false</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(A.val!=B.val)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(A.val===B.val)&#123;</span><br><span class="line">            <span class="comment">//当前节点相等的话，判断左子节点和右子节点</span></span><br><span class="line">            <span class="keyword">return</span> isEqual(A.left,B.left)&amp;&amp;isEqual(A.right,B.right)</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：<br>执行用时：116 ms, 在所有 JavaScript 提交中击败了46.50%的用户<br>内存消耗：56.9 MB, 在所有 JavaScript 提交中击败了100.00%的用户</p><h2 id="总结反思"><a href="#总结反思" class="headerlink" title="总结反思"></a>总结反思</h2><p>总的来说，该问题还是一个递归问题，一开始想着使用原来的函数，但是写到后面发现无法区分A的当前节点和B的匹配进度，A的子节点和B的匹配进度<br>故重新写了一个函数，瞬间简单了<br>所以，递归时直接写子函数，总是没错的</p>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
          <category> 26树的子结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树 </tag>
            
            <tag> 递归 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer-25合并两个排序链表</title>
      <link href="/2020/07/12/%E5%89%91%E6%8C%87offer-25%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8/"/>
      <url>/2020/07/12/%E5%89%91%E6%8C%87offer-25%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="25合并两个链表"><a href="#25合并两个链表" class="headerlink" title="25合并两个链表"></a>25合并两个链表</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入两个递增排序的链表，合并这两个链表并使新链表中的节点仍然是递增排序的。</p><blockquote><p>示例1：<br>输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4<br>输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4<br>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/he-bing-liang-ge-pai-xu-de-lian-biao-lcof" target="_blank" rel="noopener">https://leetcode-cn.com/problems/he-bing-liang-ge-pai-xu-de-lian-biao-lcof</a></p></blockquote><h2 id="算法分析-代码实现"><a href="#算法分析-代码实现" class="headerlink" title="算法分析+代码实现"></a>算法分析+代码实现</h2><p>1 双指针</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mergeTwoLists = <span class="function"><span class="keyword">function</span>(<span class="params">l1, l2</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//空链表</span></span><br><span class="line">    <span class="comment">//l1空 返回l2</span></span><br><span class="line">    <span class="keyword">if</span>(!l1)&#123;</span><br><span class="line">        <span class="keyword">return</span> l2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//l2空 返回l1</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(!l2)&#123;</span><br><span class="line">        <span class="keyword">return</span> l1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//定义头节点</span></span><br><span class="line">    <span class="keyword">if</span>(l1.val&lt;l2.val)&#123;</span><br><span class="line">        head = l1</span><br><span class="line">        l1 = l1.next</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        head = l2</span><br><span class="line">        l2 = l2.next</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> test=head;</span><br><span class="line">    <span class="keyword">while</span>(l1&amp;&amp;l2)&#123;</span><br><span class="line">        <span class="keyword">if</span>(l1.val&lt;l2.val)&#123;</span><br><span class="line">            test.next =<span class="keyword">new</span> ListNode(l1.val);</span><br><span class="line">            l1=l1.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            test.next =<span class="keyword">new</span> ListNode(l2.val);</span><br><span class="line">            l2=l2.next</span><br><span class="line">        &#125;</span><br><span class="line">        test = test.next</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!l1)&#123;</span><br><span class="line">        test.next=l2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!l2)&#123;</span><br><span class="line">        test.next =l1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>结果:<br>执行用时：100 ms, 在所有 JavaScript 提交中击败了56.76%的用户<br>内存消耗：40.3 MB, 在所有 JavaScript 提交中击败了100.00%的用户</p><p>2  递归写法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mergeTwoLists = <span class="function"><span class="keyword">function</span>(<span class="params">l1, l2</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//空链表</span></span><br><span class="line">    <span class="comment">//l1空 返回l2</span></span><br><span class="line">    <span class="keyword">if</span>(!l1)&#123;</span><br><span class="line">        <span class="keyword">return</span> l2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//l2空 返回l1</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(!l2)&#123;</span><br><span class="line">        <span class="keyword">return</span> l1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(l1&amp;&amp;l2)&#123;</span><br><span class="line">        <span class="keyword">if</span>(l1.val&lt;l2.val)&#123;</span><br><span class="line">           l1.next = mergeTwoLists(l1.next,l2)</span><br><span class="line">           <span class="keyword">return</span> l1</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">          l2.next = mergeTwoLists(l1,l2.next)</span><br><span class="line">          <span class="keyword">return</span> l2</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>结果:<br>执行用时：80 ms, 在所有 JavaScript 提交中击败了98.99%的用户<br>内存消耗：39.5 MB, 在所有 JavaScript 提交中击败了100.00%的用户</p><h2 id="总结反思"><a href="#总结反思" class="headerlink" title="总结反思"></a>总结反思</h2><p>双指针的写法一定要掌握<br>递归算法的话,也要了解,最好是自己可以写出来</p>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
          <category> 25合并两个链表 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表 </tag>
            
            <tag> 递归 </tag>
            
            <tag> 双指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer-24反转链表</title>
      <link href="/2020/07/12/%E5%89%91%E6%8C%87offer-24%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/"/>
      <url>/2020/07/12/%E5%89%91%E6%8C%87offer-24%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="24反转链表"><a href="#24反转链表" class="headerlink" title="24反转链表"></a>24反转链表</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>定义函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点。</p><blockquote><p>示例:<br>输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL<br>输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL<br>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/fan-zhuan-lian-biao-lcof" target="_blank" rel="noopener">https://leetcode-cn.com/problems/fan-zhuan-lian-biao-lcof</a></p></blockquote><h2 id="算法分析-代码实现"><a href="#算法分析-代码实现" class="headerlink" title="算法分析+代码实现"></a>算法分析+代码实现</h2><p>1 用栈存储，然后依次出栈生成节点</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> reverseList = <span class="function"><span class="keyword">function</span>(<span class="params">head</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> stack = []<span class="comment">//用栈存储节点值</span></span><br><span class="line">    <span class="comment">//数组为空时，直接返回空</span></span><br><span class="line">    <span class="keyword">if</span>(!head)&#123;</span><br><span class="line">        <span class="keyword">return</span> head</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(head)&#123;</span><br><span class="line">        stack.push(head.val)</span><br><span class="line">        head = head.next</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> res= <span class="keyword">new</span> ListNode(stack.pop())<span class="comment">//定义头节点</span></span><br><span class="line">    <span class="keyword">let</span> test =res<span class="comment">//标记反转后链表的头指针  </span></span><br><span class="line">    <span class="keyword">while</span>(stack.length)&#123;</span><br><span class="line">        res.next = <span class="keyword">new</span> ListNode(stack.pop())</span><br><span class="line">        res = res.next</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> test;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>结果：（多次实验，这是最好的一次）<br>执行用时：72 ms, 在所有 JavaScript 提交中击败了74.50%的用户<br>内存消耗：36.3 MB, 在所有 JavaScript 提交中击败了100.00%的用户</p><p>2 三指针，遍历第一次的同时完成反转</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> reverseList = <span class="function"><span class="keyword">function</span>(<span class="params">head</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//当前顺序链表的当前的节点的前一个值，也是反转链表的下一个值</span></span><br><span class="line">    <span class="keyword">let</span> prev = <span class="literal">null</span></span><br><span class="line">    <span class="comment">//顺序链表和反转链表的当前节点</span></span><br><span class="line">    <span class="keyword">let</span> cur = head</span><br><span class="line">    <span class="keyword">while</span>(cur)&#123;</span><br><span class="line">        <span class="comment">//1 保存顺序链表后一个节点</span></span><br><span class="line">        <span class="keyword">let</span> next = cur.next</span><br><span class="line">        <span class="comment">//2 改变当前指针的next值,指向顺序链表的当前值的前一个</span></span><br><span class="line">        cur.next = prev</span><br><span class="line">        <span class="comment">//3 更新prev节点，指向当前节点</span></span><br><span class="line">        prev = cur</span><br><span class="line">        <span class="comment">//4 更新cur的值，指向顺序链表的下一个节点</span></span><br><span class="line">        cur = next</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//cur最终会成为null，故返回的应该是cur的前一个节点prev</span></span><br><span class="line">    <span class="keyword">return</span> prev</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>结果：<br>执行用时：72 ms, 在所有 JavaScript 提交中击败了74.50%的用户<br>内存消耗：35.6 MB, 在所有 JavaScript 提交中击败了100.00%的用户</p><h2 id="总结反思"><a href="#总结反思" class="headerlink" title="总结反思"></a>总结反思</h2><p>最主要的是要理解和掌握三指针的使用，不懂的时候就多画图，有助于理解</p>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
          <category> 24反转链表 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表 </tag>
            
            <tag> 栈 </tag>
            
            <tag> 反转链表 </tag>
            
            <tag> 三指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer-22链表中倒数第k个节点</title>
      <link href="/2020/07/12/%E5%89%91%E6%8C%87offer-22%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E8%8A%82%E7%82%B9/"/>
      <url>/2020/07/12/%E5%89%91%E6%8C%87offer-22%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E8%8A%82%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<h1 id="22链表中倒数第k个节点"><a href="#22链表中倒数第k个节点" class="headerlink" title="22链表中倒数第k个节点"></a>22链表中倒数第k个节点</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。例如，一个链表有6个节点，从头节点开始，它们的值依次是1、2、3、4、5、6。这个链表的倒数第3个节点是值为4的节点。</p><blockquote><p>示例：<br>给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 k = 2.<br>返回链表 4-&gt;5.<br>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof" target="_blank" rel="noopener">https://leetcode-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof</a></p></blockquote><h2 id="算法分析-代码实现"><a href="#算法分析-代码实现" class="headerlink" title="算法分析+代码实现"></a>算法分析+代码实现</h2><p>1 两次遍历，一次确定长度，一次寻找合适对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> getKthFromEnd = <span class="function"><span class="keyword">function</span>(<span class="params">head, k</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> test =head;</span><br><span class="line">    <span class="keyword">let</span> num = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//此处的num指的是链表长度，从1开始，便于思考和计算</span></span><br><span class="line">    <span class="keyword">while</span>(head.next)&#123;</span><br><span class="line">        num++;</span><br><span class="line">        head = head.next</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//此处num指的是</span></span><br><span class="line">    num = num-k;</span><br><span class="line">    <span class="keyword">while</span>(num)&#123;</span><br><span class="line">        num--;</span><br><span class="line">        test = test.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> test</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>结果：<br>执行用时：72 ms, 在所有 JavaScript 提交中击败了71.96%的用户<br>内存消耗：33.1 MB, 在所有 JavaScript 提交中击败了100.00%的用户</p><p>2 一次遍历：利用双指针，卡好间隔，当后一个指针指向结尾时，前一个指针刚好指向第k个</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> getKthFromEnd = <span class="function"><span class="keyword">function</span>(<span class="params">head, k</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> test =head;</span><br><span class="line">    <span class="keyword">let</span> num = k<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(num)&#123;</span><br><span class="line">        num--;</span><br><span class="line">        test = test.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(test.next)&#123;</span><br><span class="line">        head=head.next;</span><br><span class="line">        test=test.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>结果：<br>执行用时：72 ms, 在所有 JavaScript 提交中击败了71.96%的用户<br>内存消耗：33.3 MB, 在所有 JavaScript 提交中击败了100.00%的用户</p><h2 id="总结反思"><a href="#总结反思" class="headerlink" title="总结反思"></a>总结反思</h2><p>其实该问题主要考察的就是双指针的问题 ，以及对链表结构的理解<br>和上一题基本差不多</p>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
          <category> 22链表中倒数第k个节点 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表 </tag>
            
            <tag> 双指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer-21调整数组顺序使奇数位于偶数前</title>
      <link href="/2020/07/11/%E5%89%91%E6%8C%87offer-21%E8%B0%83%E6%95%B4%E6%95%B0%E7%BB%84%E9%A1%BA%E5%BA%8F%E4%BD%BF%E5%A5%87%E6%95%B0%E4%BD%8D%E4%BA%8E%E5%81%B6%E6%95%B0%E5%89%8D/"/>
      <url>/2020/07/11/%E5%89%91%E6%8C%87offer-21%E8%B0%83%E6%95%B4%E6%95%B0%E7%BB%84%E9%A1%BA%E5%BA%8F%E4%BD%BF%E5%A5%87%E6%95%B0%E4%BD%8D%E4%BA%8E%E5%81%B6%E6%95%B0%E5%89%8D/</url>
      
        <content type="html"><![CDATA[<h1 id="21调整数组顺序使奇数位于偶数前"><a href="#21调整数组顺序使奇数位于偶数前" class="headerlink" title="21调整数组顺序使奇数位于偶数前"></a>21调整数组顺序使奇数位于偶数前</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有奇数位于数组的前半部分，所有偶数位于数组的后半部分。 </p><blockquote><p>示例：<br>输入：nums = [1,2,3,4]<br>输出：[1,3,2,4]<br>注：[3,1,2,4] 也是正确的答案之一。<br>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/diao-zheng-shu-zu-shun-xu-shi-qi-shu-wei-yu-ou-shu-qian-mian-lcof" target="_blank" rel="noopener">https://leetcode-cn.com/problems/diao-zheng-shu-zu-shun-xu-shi-qi-shu-wei-yu-ou-shu-qian-mian-lcof</a></p></blockquote><h2 id="算法分析-代码实现"><a href="#算法分析-代码实现" class="headerlink" title="算法分析+代码实现"></a>算法分析+代码实现</h2><p>1 冒泡排序</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> exchange = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> max = nums.length</span><br><span class="line">    <span class="keyword">let</span> flag = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(max)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i= <span class="number">0</span>;i&lt;max<span class="number">-1</span>;i++)&#123;</span><br><span class="line">        <span class="comment">//nums[i]是偶数，nums[i+1]是奇数</span></span><br><span class="line">        <span class="keyword">if</span>(!(nums[i]%<span class="number">2</span>)&amp;&amp;nums[i+<span class="number">1</span>]%<span class="number">2</span>)&#123;</span><br><span class="line">            flag = nums[i];</span><br><span class="line">            nums[i]=nums[i+<span class="number">1</span>];</span><br><span class="line">            nums[i+<span class="number">1</span>]=flag;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    max--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>结果：时间花销太大</p><p>执行用时：6740 ms, 在所有 JavaScript 提交中击败了5.05%的用户<br>内存消耗：43.5 MB, 在所有 JavaScript 提交中击败了100.00%的用户<br>2 分组讨论，用空间换时间，时间复杂度为O(n),空间复杂度为O(n)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> exchange = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!nums.length)&#123;</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> odd=[]<span class="comment">//存放奇数</span></span><br><span class="line">    <span class="keyword">let</span> oven=[]<span class="comment">//存放偶数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i= <span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">        <span class="comment">//nums[i]是奇数</span></span><br><span class="line">        <span class="keyword">if</span>(nums[i]%<span class="number">2</span>)&#123;</span><br><span class="line">            odd.push(nums[i])</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//偶数</span></span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            oven.push(nums[i])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//利用es6的...运算符</span></span><br><span class="line">    odd.push(...oven)</span><br><span class="line">    <span class="keyword">return</span> odd</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>结果：时间大幅降低，但是是以空间换取时间的做法<br>执行用时：112 ms, 在所有 JavaScript 提交中击败了75.53%的用户<br>内存消耗：46.3 MB, 在所有 JavaScript 提交中击败了100.00%的用户</p><p>3 利用双指针，符合条件，两个指针的内容换过来</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//未优化版</span></span><br><span class="line"><span class="keyword">var</span> exchange = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> i=<span class="number">0</span>,j=nums.length<span class="number">-1</span></span><br><span class="line">    <span class="keyword">while</span>(i&lt;j)&#123;</span><br><span class="line">        <span class="comment">//nums[i]是偶数</span></span><br><span class="line">        <span class="keyword">if</span>(!(nums[i]%<span class="number">2</span>))&#123;</span><br><span class="line">            <span class="comment">//nums[j]是奇数</span></span><br><span class="line">            <span class="keyword">if</span>(nums[j]%<span class="number">2</span>)&#123;</span><br><span class="line">                <span class="comment">//二者呼唤</span></span><br><span class="line">                <span class="keyword">let</span> flag = nums[i];</span><br><span class="line">                nums[i]=nums[j];</span><br><span class="line">                nums[j]=flag;</span><br><span class="line">                i++;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                j--</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//优化版</span></span><br><span class="line"><span class="keyword">var</span> exchange = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> i = <span class="number">0</span>, j = nums.length <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">        <span class="keyword">while</span> (nums[i] &amp; <span class="number">1</span> &amp;&amp; i &lt; j) &#123;</span><br><span class="line">            i += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!(nums[j] &amp; <span class="number">1</span>) &amp;&amp; i &lt; j) &#123;</span><br><span class="line">            j -= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        [nums[i], nums[j]] = [nums[j], nums[i]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>结果: 时间空间复杂度都是最低的<br>执行用时：108 ms, 在所有 JavaScript 提交中击败了85.42%的用户<br>内存消耗：43.6 MB, 在所有 JavaScript 提交中击败了100.00%的用户</p><h2 id="总结反思"><a href="#总结反思" class="headerlink" title="总结反思"></a>总结反思</h2><p>1 冒泡排序要熟练掌握，但是时间开销较大，使用时注意<br>2 优化时可以选择以时间换空间做法<br>3 双指针也是一种方法，记得使用</p>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
          <category> 21调整数组顺序使奇数位于偶数前 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 冒泡排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer-20表示数值的字符串</title>
      <link href="/2020/07/11/%E5%89%91%E6%8C%87offer-20%E8%A1%A8%E7%A4%BA%E6%95%B0%E5%80%BC%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
      <url>/2020/07/11/%E5%89%91%E6%8C%87offer-20%E8%A1%A8%E7%A4%BA%E6%95%B0%E5%80%BC%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<h1 id="20表示数值的字符串"><a href="#20表示数值的字符串" class="headerlink" title="20表示数值的字符串"></a>20表示数值的字符串</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。例如，字符串”+100”、”5e2”、”-123”、”3.1416”、”0123”都表示数值，但”12e”、”1a3.14”、”1.2.3”、”+-5”、”-1E-16”及”12e+5.4”都不是。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/biao-shi-shu-zhi-de-zi-fu-chuan-lcof" target="_blank" rel="noopener">https://leetcode-cn.com/problems/biao-shi-shu-zhi-de-zi-fu-chuan-lcof</a></p><h2 id="算法分析-代码实现"><a href="#算法分析-代码实现" class="headerlink" title="算法分析+代码实现"></a>算法分析+代码实现</h2><p>1 正则</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//string.trim()表示把字符串前后的空格去掉</span></span><br><span class="line"><span class="keyword">var</span> isNumber = <span class="function"><span class="keyword">function</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="regexp">/^[+-]?(\d+(\.\d*)?|(\.\d+))(e[+-]?\d+)?$/</span>.test(s.trim());</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>结果：正则是真的香<br>执行用时：88 ms, 在所有 JavaScript 提交中击败了96.06%的用户<br>内存消耗：37.2 MB, 在所有 JavaScript 提交中击败了100.00%的用户<br>2 利用js自带的number方法<br>Number.isNaN() 方法确定传递的值是否为 NaN<br>Number 对象主要用于：<br>如果参数无法被转换为数字，则返回 NaN。<br>在非构造器上下文中 (如：没有 new 操作符)，Number 能被用来执行类型转换。<br>Number(s)如果将数组</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> isNumber = <span class="function"><span class="keyword">function</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line">  s = s.trim()</span><br><span class="line">  <span class="keyword">if</span> (s == <span class="string">''</span>) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  <span class="keyword">return</span> !<span class="built_in">Number</span>.isNaN(<span class="built_in">Number</span>(s))</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>结果：想法不错，但是结果不太好<br>执行用时：116 ms, 在所有 JavaScript 提交中击败了16.20%的用户<br>内存消耗：37.3 MB, 在所有 JavaScript 提交中击败了100.00%的用户</p><h2 id="总结反思"><a href="#总结反思" class="headerlink" title="总结反思"></a>总结反思</h2><p>判断字符串时，首先就要想到正则表达式<br>然后再想其他的一般方法，譬如转换类型啊，使用自带函数什么的<br>最后再想：自己实现该方法，因为自己不能保证所有情况都考虑到。</p>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
          <category> 20表示数值的字符串 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 表示数值的字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer-19正则表达式的匹配</title>
      <link href="/2020/07/10/%E5%89%91%E6%8C%87offer-19%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E5%8C%B9%E9%85%8D/"/>
      <url>/2020/07/10/%E5%89%91%E6%8C%87offer-19%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E5%8C%B9%E9%85%8D/</url>
      
        <content type="html"><![CDATA[<h1 id="19正则表达式的匹配"><a href="#19正则表达式的匹配" class="headerlink" title="19正则表达式的匹配"></a>19正则表达式的匹配</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>请实现一个函数用来匹配包含’. ‘和’ * ‘的正则表达式。模式中的字符’.’表示任意一个字符，而’ * ‘表示它前面的字符可以出现任意次（含0次）。在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串”aaa”与模式”a.a”和”ab * ac * a”匹配，但与”aa.a”和”ab * a”均不匹配。</p><blockquote><p>示例 1:<br>输入:s = “aa”,,p  = “a”<br>输出: false<br>解释: “a” 无法匹配 “aa” 整个字符串。<br>示例 2:<br>输入:s = “aa”,p  = “a * “<br>输出: true<br>解释: 因为 ‘ * ‘ 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 ‘a’。因此，字符串 “aa” 可被视为 ‘a’ 重复了一次。<br>示例 3:<br>输入:s = “ab”,p  = “. * “<br>输出: true<br>解释: “. * “ 表示可匹配零个或多个（’ * ‘）任意字符（’.’）。<br>示例 4:<br>输入:s = “aab”,p  = “c * a * b”<br>输出: true<br>解释: 因为 ‘ * ‘ 表示零个或多个，这里 ‘c’ 为 0 个, ‘a’ 被重复一次。因此可以匹配字符串 “aab”。<br>示例 5:<br>输入:s = “mississippi”,p  = “mis * is * p  * .”<br>输出: false<br>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/zheng-ze-biao-da-shi-pi-pei-lcof" target="_blank" rel="noopener">https://leetcode-cn.com/problems/zheng-ze-biao-da-shi-pi-pei-lcof</a></p></blockquote><h2 id="算法分析-代码实现"><a href="#算法分析-代码实现" class="headerlink" title="算法分析+代码实现"></a>算法分析+代码实现</h2><p>题解：<br><a href="https://leetcode-cn.com/problems/regular-expression-matching/solution/shou-hui-tu-jie-wo-tai-nan-liao-by-hyj8/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/regular-expression-matching/solution/shou-hui-tu-jie-wo-tai-nan-liao-by-hyj8/</a></p><h2 id="反思总结"><a href="#反思总结" class="headerlink" title="反思总结"></a>反思总结</h2><p>力扣上面的难题，考察对正则表达式和对字符串的理解，以及特殊情况的处理<br>赌一手面试不出，明白思路即可</p>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
          <category> 19正则表达式的匹配 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 剑指offer </tag>
            
            <tag> 正则表达式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer-18删除链表的节点</title>
      <link href="/2020/07/10/%E5%89%91%E6%8C%87offer-18%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E8%8A%82%E7%82%B9/"/>
      <url>/2020/07/10/%E5%89%91%E6%8C%87offer-18%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E8%8A%82%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<h1 id="18删除链表的节点"><a href="#18删除链表的节点" class="headerlink" title="18删除链表的节点"></a>18删除链表的节点</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定单向链表的头指针和一个要删除的节点的值，定义一个函数删除该节点。<br>返回删除后的链表的头节点。（此题对比原题有改动）</p><blockquote><p>示例 1:<br>输入: head = [4,5,1,9], val = 5<br>输出: [4,1,9]<br>解释: 给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 1 -&gt; 9.<br>示例 2:<br>输入: head = [4,5,1,9], val = 1<br>输出: [4,5,9]<br>解释: 给定你链表中值为 1 的第三个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 5 -&gt; 9.</p></blockquote><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/shan-chu-lian-biao-de-jie-dian-lcof" target="_blank" rel="noopener">https://leetcode-cn.com/problems/shan-chu-lian-biao-de-jie-dian-lcof</a></p><h2 id="算法分析-代码实现"><a href="#算法分析-代码实现" class="headerlink" title="算法分析+代码实现"></a>算法分析+代码实现</h2><p>1 利用哨兵节点，存储当前节点和上一节点或者，当前节点和下一节点<br>哨兵节点的用法灵活，一般是不保存任何数据的节点。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第一种：</span></span><br><span class="line"><span class="keyword">var</span> deleteNode = <span class="function"><span class="keyword">function</span>(<span class="params">head, val</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> pre = <span class="keyword">new</span> ListNode(<span class="number">-1</span>); <span class="comment">// 哨兵节点</span></span><br><span class="line">    pre.next = head;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> node = pre;</span><br><span class="line">    <span class="keyword">while</span> (node.next) &#123;</span><br><span class="line">        <span class="keyword">if</span> (node.next.val === val) &#123;</span><br><span class="line">            node.next = node.next.next;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        node = node.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pre.next;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//第二种 哨兵节点 存储当前节点和下一节点，通过判断下一节点来选择是否跳过下一节点</span></span><br><span class="line"><span class="keyword">var</span> deleteNode = <span class="function"><span class="keyword">function</span> (<span class="params">head, val</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> pre = head</span><br><span class="line">    <span class="keyword">let</span> node = pre.next</span><br><span class="line">    <span class="keyword">if</span> (pre.val === val) &#123;</span><br><span class="line">        <span class="keyword">return</span> head.next</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (node) &#123;</span><br><span class="line">        <span class="keyword">if</span> (node.val === val) &#123;</span><br><span class="line">            pre.next = node.next</span><br><span class="line">        &#125;</span><br><span class="line">        pre = node</span><br><span class="line">        node = node.next</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>结果：时间复杂度O（n），空间复杂度O（1）<br>执行用时：80 ms, 在所有 JavaScript 提交中击败了65.60%的用户<br>内存消耗：36.9 MB, 在所有 JavaScript 提交中击败了100.00%的用户</p><p>2 递归： 利用递归思想，来删除节点</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> deleteNode = <span class="function"><span class="keyword">function</span>(<span class="params">head, val</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head.val === val)&#123;</span><br><span class="line">        <span class="keyword">return</span> head.next</span><br><span class="line">    &#125;</span><br><span class="line">    head.next = deleteNode(head.next,val)</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>结果：使用递归后，节省了代码量，但是增加了系统内存消耗，不推荐使用<br>执行用时：80 ms, 在所有 JavaScript 提交中击败了65.60%的用户<br>内存消耗：37 MB, 在所有 JavaScript 提交中击败了100.00%的用户</p><h2 id="总结反思"><a href="#总结反思" class="headerlink" title="总结反思"></a>总结反思</h2><p>该题目主要考查的是哨兵节点的使用，要注意理解并掌握该方法</p>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
          <category> 18删除链表的节点 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表删除节点 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer-17打印从1到最大的n位十进制数</title>
      <link href="/2020/07/09/%E5%89%91%E6%8C%87offer-17%E6%89%93%E5%8D%B0%E4%BB%8E1%E5%88%B0%E6%9C%80%E5%A4%A7%E7%9A%84n%E4%BD%8D%E5%8D%81%E8%BF%9B%E5%88%B6%E6%95%B0/"/>
      <url>/2020/07/09/%E5%89%91%E6%8C%87offer-17%E6%89%93%E5%8D%B0%E4%BB%8E1%E5%88%B0%E6%9C%80%E5%A4%A7%E7%9A%84n%E4%BD%8D%E5%8D%81%E8%BF%9B%E5%88%B6%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="17-打印从1到最大n位的十进制数"><a href="#17-打印从1到最大n位的十进制数" class="headerlink" title="17 打印从1到最大n位的十进制数"></a>17 打印从1到最大n位的十进制数</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入数字 n，按顺序打印出从 1 到最大的 n 位十进制数。比如输入 3，则打印出 1、2、3 一直到最大的 3 位数 999。</p><blockquote><p>示例 1:<br>输入: n = 1<br>输出: [1,2,3,4,5,6,7,8,9]</p></blockquote><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/da-yin-cong-1dao-zui-da-de-nwei-shu-lcof" target="_blank" rel="noopener">https://leetcode-cn.com/problems/da-yin-cong-1dao-zui-da-de-nwei-shu-lcof</a></p><h2 id="算法分析-代码优化"><a href="#算法分析-代码优化" class="headerlink" title="算法分析+代码优化"></a>算法分析+代码优化</h2><p>1 我一开始想的就是：一位一位的算，然后慢慢扩大数组中的数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> printNumbers = <span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line"><span class="comment">//n&lt;0;</span></span><br><span class="line"><span class="keyword">if</span>(n&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> base = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> res = [];</span><br><span class="line"><span class="keyword">while</span>(n)&#123;</span><br><span class="line">    n--;</span><br><span class="line">    <span class="keyword">let</span> i=base;</span><br><span class="line">    base=base*<span class="number">10</span>;</span><br><span class="line">    <span class="keyword">for</span>(;i&lt;base;i++)&#123;</span><br><span class="line">        res.push(i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>结果：<br>执行用时：116 ms, 在所有 JavaScript 提交中击败了84.86%的用户<br>内存消耗：45.4 MB, 在所有 JavaScript 提交中击败了100.00%的用户<br>代码有些过长<br>2 直接算出最大值，然后一个循环递归</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> printNumbers = <span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line"><span class="comment">//n&lt;0;</span></span><br><span class="line"><span class="keyword">if</span>(n&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> max = <span class="number">10</span>**n;</span><br><span class="line"><span class="keyword">let</span> res = []</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">1</span>;i&lt;max;i++)&#123;</span><br><span class="line">    res.push(i)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>执行用时：124 ms, 在所有 JavaScript 提交中击败了70.86%的用户<br>内存消耗：45.4 MB, 在所有 JavaScript 提交中击败了100.00%的用户</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本题在原书上是考察大数的存储，而js的number型为双精度，32位，故不存在这个问题；<br>考点也就剩下了一个：快速求幂<br>可以使用：</p><ol><li>math.pow()方法</li><li><ul><li><ul><li>运算符</li></ul></li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
          <category> 17打印从1到最大n位的十进制数 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 剑指offer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer-16数值的整数次方</title>
      <link href="/2020/07/09/%E5%89%91%E6%8C%87offer-16%E6%95%B0%E5%80%BC%E7%9A%84%E6%95%B4%E6%95%B0%E6%AC%A1%E6%96%B9/"/>
      <url>/2020/07/09/%E5%89%91%E6%8C%87offer-16%E6%95%B0%E5%80%BC%E7%9A%84%E6%95%B4%E6%95%B0%E6%AC%A1%E6%96%B9/</url>
      
        <content type="html"><![CDATA[<h1 id="16数值的整数次方"><a href="#16数值的整数次方" class="headerlink" title="16数值的整数次方"></a>16数值的整数次方</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>实现函数double Power(double base, int exponent)，求base的exponent次方。不得使用库函数，同时不需要考虑大数问题。</p><blockquote><p>示例 1:<br>输入: 2.00000, 10<br>输出: 1024.00000<br>示例 2:<br>输入: 2.10000, 3<br>输出: 9.26100<br>示例 3:<br>输入: 2.00000, -2<br>输出: 0.25000<br>解释: 2-2 = 1/22 = 1/4 = 0.25<br>说明:<br>-100.0 &lt; x &lt; 100.0<br>n 是 32 位有符号整数，其数值范围是 [−231, 231 − 1] 。<br>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/shu-zhi-de-zheng-shu-ci-fang-lcof" target="_blank" rel="noopener">https://leetcode-cn.com/problems/shu-zhi-de-zheng-shu-ci-fang-lcof</a></p></blockquote><h2 id="知识回顾"><a href="#知识回顾" class="headerlink" title="知识回顾"></a>知识回顾</h2><ol><li>js中的Math.pow(a,b)方法，求a的b次方</li><li>Javascript完全套用了Java的位运算符，包括按位与&amp;、按位或|、按位异或^、按位非~、左移&lt;&lt;、带符号的右移&gt;&gt;和用0补足的右移&gt;&gt;&gt;。<h2 id="算法分析-代码实现"><a href="#算法分析-代码实现" class="headerlink" title="算法分析+代码实现"></a>算法分析+代码实现</h2>1 简单解法：分情况讨论，然后按次数累乘<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myPow = <span class="function"><span class="keyword">function</span>(<span class="params">x, n</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//底数为0；</span></span><br><span class="line">    <span class="keyword">if</span>(x === <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//指数为零</span></span><br><span class="line">    <span class="keyword">if</span>(n === <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//正常情况</span></span><br><span class="line">    base = x;</span><br><span class="line">    <span class="comment">//求幂</span></span><br><span class="line">    <span class="keyword">if</span>(n&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">while</span>(n&gt;<span class="number">1</span>)&#123;</span><br><span class="line">            n--;</span><br><span class="line">            x*=base;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//求导</span></span><br><span class="line">    <span class="keyword">if</span>(n&lt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">while</span>(n&lt;<span class="number">-1</span>)&#123;</span><br><span class="line">            n++;</span><br><span class="line">            x*=base;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>/x</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>结果：超时<br>2 换思路：递减太费时，可以考虑乘方，这样一次可以降多个幂<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myPow = <span class="function"><span class="keyword">function</span>(<span class="params">x, n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n === <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (n === <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> isNegative = n &lt; <span class="number">0</span>; <span class="comment">// 是否是负指数</span></span><br><span class="line">    <span class="keyword">let</span> absn = <span class="built_in">Math</span>.abs(n);</span><br><span class="line">    <span class="keyword">let</span> result = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (absn) &#123;</span><br><span class="line">        <span class="comment">// 如果n最右位是1，将当前x累乘到result</span></span><br><span class="line">        <span class="keyword">if</span> (absn &amp; <span class="number">1</span>) &#123;</span><br><span class="line">            result = result * x;</span><br><span class="line">        &#125;</span><br><span class="line">        x = x * x; <span class="comment">// x自乘法</span></span><br><span class="line">        absn = <span class="built_in">Math</span>.floor(absn / <span class="number">2</span>); </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> isNegative ? <span class="number">1</span> / result : result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>结果：<br>执行用时：72 ms, 在所有 JavaScript 提交中击败了70.49%的用户<br>内存消耗：33.2 MB, 在所有 JavaScript 提交中击败了100.00%的用户</li></ol><h2 id="反思总结"><a href="#反思总结" class="headerlink" title="反思总结"></a>反思总结</h2><p>使用&gt;&gt;时总是报超时？<br>在网上终于找到了答案：</p><blockquote><p>Javascript完全套用了Java的位运算符，包括按位与&amp;、按位或|、按位异或^、按位非~、左移&lt;&lt;、带符号的右移&gt;&gt;和用0补足的右移&gt;&gt;&gt;。<br>这套运算符针对的是整数，所以对Javascript完全无用，因为Javascript内部，所有数字都保存为双精度浮点数。如果使用它们的话，Javascript不得不将运算数先转为整数，然后再进行运算，这样就降低了速度。而且”按位与运算符”&amp;同”逻辑与运算符”&amp;&amp;，很容易混淆。</p></blockquote><p>——《12种不宜使用的JavaScript语法》<br><a href="http://www.ruanyifeng.com/blog/2010/01/12_javascript_syntax_structures_you_should_not_use.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2010/01/12_javascript_syntax_structures_you_should_not_use.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
          <category> 16数值的整数次方 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 剑指offer </tag>
            
            <tag> js </tag>
            
            <tag> 数值的整数次方 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer-15二进制中1的个数</title>
      <link href="/2020/07/08/%E5%89%91%E6%8C%87offer-15%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%AD1%E7%9A%84%E4%B8%AA%E6%95%B0/"/>
      <url>/2020/07/08/%E5%89%91%E6%8C%87offer-15%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%AD1%E7%9A%84%E4%B8%AA%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="15二进制中1的个数"><a href="#15二进制中1的个数" class="headerlink" title="15二进制中1的个数"></a>15二进制中1的个数</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>请实现一个函数，输入一个整数，输出该数二进制表示中 1 的个数。例如，把 9 表示成二进制是 1001，有 2 位是 1。因此，如果输入 9，则该函数输出 2。</p><blockquote><p>示例 1：<br>输入：00000000000000000000000000001011<br>输出：3<br>解释：输入的二进制串 00000000000000000000000000001011 中，共有三位为 ‘1’。<br>示例 2：<br>输入：00000000000000000000000010000000<br>输出：1<br>解释：输入的二进制串 00000000000000000000000010000000 中，共有一位为 ‘1’。<br>示例 3：<br>输入：11111111111111111111111111111101<br>输出：31<br>解释：输入的二进制串 11111111111111111111111111111101 中，共有 31 位为 ‘1’。<br>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/er-jin-zhi-zhong-1de-ge-shu-lcof" target="_blank" rel="noopener">https://leetcode-cn.com/problems/er-jin-zhi-zhong-1de-ge-shu-lcof</a></p></blockquote><h2 id="知识回顾"><a href="#知识回顾" class="headerlink" title="知识回顾"></a>知识回顾</h2><ol><li><p>移位运算:<br>“&lt;&lt;”运算符<br>“&lt;&lt;”运算符执行左移位运算。在移位运算过程中，符号位始终保持不变。如果右侧空出位置，则自动填充为 0；超出 32 位的值，则自动丢弃。<br>“&gt;&gt;”运算符<br>“&gt;&gt;”运算符执行有符号右移位运算。与左移运算操作相反，它把 32 位数字中的所有有效位整体右移，再使用符号位的值填充空位。移动过程中超出的值将被丢弃。<br>“&gt;&gt;&gt;”运算符<br>“&gt;&gt;&gt;”运算符执行五符号右移位运算。它把无符号的 32 位整数所有数位整体右移。对于无符号数或正数右移运算，无符号右移与有符号右移运算的结果是相同的。</p></li><li><p>toString():<br>toString(num),这个把num传入一个number类型的数值，会直接转换成num进制的数 </p><h2 id="算法分析-代码实现"><a href="#算法分析-代码实现" class="headerlink" title="算法分析+代码实现"></a>算法分析+代码实现</h2></li><li><p>一般思路:先和1与,看最低位是否为0;然后和10与,看第二位是否为0…依次类推,直到最高位</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> hammingWeight = <span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> nums=<span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> flag=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(flag)&#123;</span><br><span class="line">        <span class="keyword">if</span>(n&amp;flag)&#123;</span><br><span class="line">            nums++</span><br><span class="line">        &#125;</span><br><span class="line">        flag = flag&lt;&lt;<span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>结果:<br>执行用时：68 ms, 在所有 JavaScript 提交中击败了97.77%的用户<br>内存消耗：35.3 MB, 在所有 JavaScript 提交中击败了100.00%的用户</p></li><li><p>优化思路:判断次数过多,尽可能优化判断次数<br>举个例子： 7的二进制位00111, 6的二进制位00110 ,那么00111&amp;00110=00110,我们发现n&amp;(n-1)每次可以消掉1个1,每次消掉一个1记录一下就可以统计出二进制中1的个数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> hammingWeight = <span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(n)&#123;</span><br><span class="line">        n=n&amp;(n<span class="number">-1</span>);</span><br><span class="line">        res++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>结果:<br>执行用时：84 ms, 在所有 JavaScript 提交中击败了50.70%的用户<br>内存消耗：35.4 MB, 在所有 JavaScript 提交中击败了100.00%的用户</p></li><li><p>新思路:利用toString()方法,将数转化为字符串,然后判断字符串中的数字</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> hammingWeight = <span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> str = n.toString(<span class="number">2</span>).toString()</span><br><span class="line">    <span class="keyword">let</span> nums = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; str.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">parseInt</span>(str[i]) === <span class="number">1</span>) &#123;</span><br><span class="line">            nums ++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>正则,正就完了</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> hammingWeight = <span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">   <span class="keyword">const</span> r =  n.toString(<span class="number">2</span>).match(<span class="regexp">/1/g</span>);</span><br><span class="line">    <span class="keyword">return</span> r ? r.length : <span class="number">0</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>结果:<br>执行用时：84 ms, 在所有 JavaScript 提交中击败了50.70%的用户<br>内存消耗：36 MB, 在所有 JavaScript 提交中击败了100.00%的用户</p></li></ol><h2 id="反思"><a href="#反思" class="headerlink" title="反思"></a>反思</h2><p>题目很简单,难在思考的角度</p><p>方法1和2 是基本方法,或者说没有用到语言特性的方法<br>方法3,4利用了js语言自带的函数,特性等</p><p>当面试手写代码时,可以主动去问一下面试官,需要哪种方法,常用的?还是说使用函数,但是使用函数的时候,要注意,自己是真的了解了函数的用法,要不然容易自己把自己带进沟里去.</p>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
          <category> 15二进制中1的个数 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 剑指offer </tag>
            
            <tag> 位运算 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer-14剪绳子</title>
      <link href="/2020/07/07/%E5%89%91%E6%8C%87offer-14%E5%89%AA%E7%BB%B3%E5%AD%90/"/>
      <url>/2020/07/07/%E5%89%91%E6%8C%87offer-14%E5%89%AA%E7%BB%B3%E5%AD%90/</url>
      
        <content type="html"><![CDATA[<h1 id="14剪绳子"><a href="#14剪绳子" class="headerlink" title="14剪绳子"></a>14剪绳子</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n&gt;1并且m&gt;1），每段绳子的长度记为 k[0],k[1]…k[m-1] 。请问 k[0] * k[1]<em>…</em>k[m-1] 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。</p><blockquote><p>示例 1：<br>输入: 2<br>输出: 1<br>解释: 2 = 1 + 1, 1 × 1 = 1<br>示例 2:<br>输入: 10<br>输出: 36<br>解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36<br>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/jian-sheng-zi-lcof" target="_blank" rel="noopener">https://leetcode-cn.com/problems/jian-sheng-zi-lcof</a></p></blockquote><h2 id="知识回顾"><a href="#知识回顾" class="headerlink" title="知识回顾"></a>知识回顾</h2><p>1 动态规划：<br>如果面试题是求一个问题的<br>最优解(通常是求最大值或者最小值),而且该问题能够分解成若干个子问<br>题，并且子问题之间还有重叠的更小的子问题，就可以考虑用动态规划来<br>解决这个问题。</p><ul><li>求一个问题的最优解</li><li>整体问题的最优解是依赖各个子问题的最优解</li><li>大问题分解成若干个小问题，这些小问题之间还有相互重叠的更小的子问题</li><li>从上往下分析问题，从下往上求解问题<br>2 贪心算法：每一步都做最优解</li><li>需要通过数学方式来证明贪婪选择是正确的</li></ul><h2 id="算法分析-代码实现"><a href="#算法分析-代码实现" class="headerlink" title="算法分析+代码实现"></a>算法分析+代码实现</h2><p>1 动态规划：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> cuttingRope = <span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(n ==<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">3</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    max=[];</span><br><span class="line">    max[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    max[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    max[<span class="number">2</span>]=<span class="number">2</span>;</span><br><span class="line">    max[<span class="number">3</span>]=<span class="number">3</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i =<span class="number">4</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        max[i]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> j=<span class="number">0</span>;j&lt;=<span class="built_in">Math</span>.floor(i/<span class="number">2</span>);j++)&#123;</span><br><span class="line">           bestRes = max[j]*max[i-j];</span><br><span class="line">           bestRes&gt;max[i]?max[i]= bestRes:<span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max[n]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>结果：时间复杂度为：O(n2);空间复杂度为O（n）,因为要存储子问题的最优解</p><p>执行用时：72 ms, 在所有 JavaScript 提交中击败了51.73%的用户</p><p>内存消耗：35.6 MB, 在所有 JavaScript 提交中击败了100.00%的用户</p><p>2 贪心算法：</p><p>原理：多分析，多总结<br>n&gt;=5时，3（n-3）&gt;=2(n-2)，即尽可能分多个三。当最后剩下1时，此时要把剩下的1和之前的3合并成4并分成2 * 2，因为2 * 2 &gt;3 * 1</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> cuttingRope = <span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(n ==<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">3</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//记录有几个三</span></span><br><span class="line">    <span class="keyword">let</span> m=<span class="built_in">Math</span>.floor(n/<span class="number">3</span>);</span><br><span class="line">    rest=n-m*<span class="number">3</span></span><br><span class="line">    <span class="keyword">if</span>(rest == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Math</span>.pow(<span class="number">3</span>,m)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(rest == <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Math</span>.pow(<span class="number">3</span>,m<span class="number">-1</span>)*<span class="number">4</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(rest == <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Math</span>.pow(<span class="number">3</span>,m)*<span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>结果：时间复杂度O（1）<br>执行用时：60 ms, 在所有 JavaScript 提交中击败了94.12%的用户<br>内存消耗：32.2 MB, 在所有 JavaScript 提交中击败了100.00%的用户</p><h2 id="总结反思"><a href="#总结反思" class="headerlink" title="总结反思"></a>总结反思</h2>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
          <category> 14剪绳子 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 剑指offer </tag>
            
            <tag> 动态规划 </tag>
            
            <tag> 贪心算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer-13机器人运动范围</title>
      <link href="/2020/07/07/%E5%89%91%E6%8C%87offer-13%E6%9C%BA%E5%99%A8%E4%BA%BA%E8%BF%90%E5%8A%A8%E8%8C%83%E5%9B%B4/"/>
      <url>/2020/07/07/%E5%89%91%E6%8C%87offer-13%E6%9C%BA%E5%99%A8%E4%BA%BA%E8%BF%90%E5%8A%A8%E8%8C%83%E5%9B%B4/</url>
      
        <content type="html"><![CDATA[<h1 id="13机器人运动范围"><a href="#13机器人运动范围" class="headerlink" title="13机器人运动范围"></a>13机器人运动范围</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>地上有一个m行n列的方格，从坐标 [0,0] 到坐标 [m-1,n-1] 。一个机器人从坐标 [0, 0] 的格子开始移动，它每次可以向左、右、上、下移动一格（不能移动到方格外），也不能进入行坐标和列坐标的数位之和大于k的格子。例如，当k为18时，机器人能够进入方格 [35, 37] ，因为3+5+3+7=18。但它不能进入方格 [35, 38]，因为3+5+3+8=19。请问该机器人能够到达多少个格子？</p><blockquote><p>示例 1：<br>输入：m = 2, n = 3, k = 1<br>输出：3<br>示例 2：<br>输入：m = 3, n = 1, k = 0<br>输出：1<br>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof" target="_blank" rel="noopener">https://leetcode-cn.com/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof</a></p></blockquote><h2 id="算法解析-代码"><a href="#算法解析-代码" class="headerlink" title="算法解析+代码"></a>算法解析+代码</h2><blockquote><p>该题目可以看作是上一题的一个变型，算法思路就是回溯，走一步看四步</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> movingCount = <span class="function"><span class="keyword">function</span>(<span class="params">m, n, k</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//判断特殊值</span></span><br><span class="line">    <span class="comment">//长宽有问题，返回null</span></span><br><span class="line">    <span class="keyword">if</span>(m&lt;=<span class="number">0</span>||n&lt;=<span class="number">0</span>||k&lt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//k为0,则不动</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(k === <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//设置计数数组</span></span><br><span class="line">    <span class="keyword">let</span> nums =[];</span><br><span class="line">    <span class="comment">//初始化方格</span></span><br><span class="line">    <span class="keyword">let</span> board = [];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">        board[i]=[]</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">            board[i][j]=<span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> fsp = <span class="function"><span class="keyword">function</span>(<span class="params">board,i,j,k</span>)</span>&#123;</span><br><span class="line">        sum = i%<span class="number">10</span>+<span class="built_in">Math</span>.floor(i/<span class="number">10</span>)+j%<span class="number">10</span>+<span class="built_in">Math</span>.floor(j/<span class="number">10</span>)</span><br><span class="line">        <span class="comment">//条件不符合，返回上一步</span></span><br><span class="line">        <span class="keyword">if</span>(i&lt;<span class="number">0</span>||i&gt;=m||j&lt;<span class="number">0</span>||j&gt;=n||board[i][j]==<span class="number">1</span>||sum&gt;k)&#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//没计数过</span></span><br><span class="line">        <span class="keyword">if</span>(board[i][j]==<span class="number">0</span>)&#123;   </span><br><span class="line">            board[i][j]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(sum&lt;=k)&#123;    </span><br><span class="line">                nums.push(i+<span class="string">''</span>+j)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//上下左右各走一次的</span></span><br><span class="line">        fsp(board,i<span class="number">-1</span>,j,k)</span><br><span class="line">        fsp(board,i+<span class="number">1</span>,j,k)</span><br><span class="line">        fsp(board,i,j<span class="number">-1</span>,k)</span><br><span class="line">        fsp(board,i,j+<span class="number">1</span>,k)</span><br><span class="line">    &#125;</span><br><span class="line">    fsp(board,<span class="number">0</span>,<span class="number">0</span>,k)</span><br><span class="line">    <span class="keyword">return</span> nums.length;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>结果：<br>执行用时：76 ms, 在所有 JavaScript 提交中击败了81.98%的用户<br>内存消耗：38.4 MB, 在所有 JavaScript 提交中击败了100.00%的用户</p><h2 id="反思"><a href="#反思" class="headerlink" title="反思"></a>反思</h2><p>1：提问：nums在哪？<br>在函数的闭包里<br>2: 写递归函数时一定要搞清楚判断条件，多想一想再写代码</p>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
          <category> 13机器人运动范围 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 剑指offer </tag>
            
            <tag> 回溯 </tag>
            
            <tag> 八皇后问题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer-12矩阵中的路径</title>
      <link href="/2020/07/06/%E5%89%91%E6%8C%87offer-12%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E8%B7%AF%E5%BE%84/"/>
      <url>/2020/07/06/%E5%89%91%E6%8C%87offer-12%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E8%B7%AF%E5%BE%84/</url>
      
        <content type="html"><![CDATA[<h1 id="12矩阵中的路径"><a href="#12矩阵中的路径" class="headerlink" title="12矩阵中的路径"></a>12矩阵中的路径</h1><h2 id="题目要求"><a href="#题目要求" class="headerlink" title="题目要求"></a>题目要求</h2><blockquote><p>请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一格开始，每一步可以在矩阵中向左、右、上、下移动一格。如果一条路径经过了矩阵的某一格，那么该路径不能再次进入该格子。例如，在下面的3×4的矩阵中包含一条字符串“bfce”的路径（路径中的字母用加粗标出）。<br>[[“a”,”b”,”c”,”e”],<br>[“s”,”f”,”c”,”s”],<br>[“a”,”d”,”e”,”e”]]<br>但矩阵中不包含字符串“abfb”的路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入这个格子。<br>示例 1：<br>输入：board = [[“A”,”B”,”C”,”E”],[“S”,”F”,”C”,”S”],[“A”,”D”,”E”,”E”]], word = “ABCCED”<br>输出：true<br>示例 2：<br>输入：board = [[“a”,”b”],[“c”,”d”]], word = “abcd”<br>输出：false<br>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/ju-zhen-zhong-de-lu-jing-lcof" target="_blank" rel="noopener">https://leetcode-cn.com/problems/ju-zhen-zhong-de-lu-jing-lcof</a></p></blockquote><h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><p>回溯法：当我们到达某一个节点时，尝试所有可能的选项，并在满足条件的前提下递归地抵达下一个节点</p><h2 id="算法分析-代码实现"><a href="#算法分析-代码实现" class="headerlink" title="算法分析+代码实现"></a>算法分析+代码实现</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> exist = <span class="function"><span class="keyword">function</span>(<span class="params">board, word</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> row = board.length;</span><br><span class="line">    <span class="keyword">var</span> col = board[<span class="number">0</span>].length;</span><br><span class="line">    <span class="comment">//board[i][j],index表示当前字符串匹配元素</span></span><br><span class="line">    <span class="keyword">var</span> dfs = <span class="function"><span class="keyword">function</span>(<span class="params">i,j,board,word,index</span>)</span>&#123;</span><br><span class="line">        <span class="comment">//条件不符合，返回false</span></span><br><span class="line">        <span class="keyword">if</span>(i&lt;<span class="number">0</span> || i&gt;=row || j&lt;<span class="number">0</span> || j&gt;=col || board[i][j]!== word[index])<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">//字符串匹配结束</span></span><br><span class="line">       <span class="keyword">if</span>(word.length<span class="number">-1</span> === index)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">//条件符合，将当前元素修改/锁住</span></span><br><span class="line">        <span class="keyword">var</span> tmp=board[i][j]</span><br><span class="line">        board[i][j]=<span class="string">'-'</span>;</span><br><span class="line">        <span class="comment">//上下左右递归执行一次算法，有可能上下左右越界，也可能字符串长度越界，所以最开始条件要加上</span></span><br><span class="line">        <span class="keyword">var</span> res = dfs(i<span class="number">-1</span>,j,board,word,index+<span class="number">1</span>) || dfs(i+<span class="number">1</span>,j,board,word,index+<span class="number">1</span>) || dfs(i,j<span class="number">-1</span>,board,word,index+<span class="number">1</span>)||dfs(i,j+<span class="number">1</span>,board,word,index+<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//将原矩阵还原</span></span><br><span class="line">        board[i][j]=tmp</span><br><span class="line">        <span class="comment">//返回递归结果</span></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历整个board，找到初始位置点</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>;i &lt; row; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; col; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(dfs(i,j,board,word,<span class="number">0</span>)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 没找到</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>结果：<br>执行用时：84 ms, 在所有 JavaScript 提交中击败了97.61%的用户<br>内存消耗：37.7 MB, 在所有 JavaScript 提交中击败了100.00%的用户</p>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
          <category> 12矩阵中的路径 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 剑指offer </tag>
            
            <tag> 回溯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer-11旋转数组的最小数字</title>
      <link href="/2020/07/06/%E5%89%91%E6%8C%87offer-11%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97/"/>
      <url>/2020/07/06/%E5%89%91%E6%8C%87offer-11%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97/</url>
      
        <content type="html"><![CDATA[<h1 id="11旋转数组的最小数字"><a href="#11旋转数组的最小数字" class="headerlink" title="11旋转数组的最小数字"></a>11旋转数组的最小数字</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><blockquote><p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。例如，数组 [3,4,5,1,2] 为 [1,2,3,4,5] 的一个旋转，该数组的最小值为1。<br>示例 1：<br>输入：[3,4,5,1,2]<br>输出：1<br>示例 2：<br>输入：[2,2,2,0,1]<br>输出：0<br>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof" target="_blank" rel="noopener">https://leetcode-cn.com/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof</a></p></blockquote><h2 id="知识补充"><a href="#知识补充" class="headerlink" title="知识补充"></a>知识补充</h2><p>查找:<br>顺序查找(最普通)<br>二分查找(本题目考察)<br>哈希查找<br>二叉排序树查找<br>排序:<br>插入排序<br>冒泡排序<br>归并排序<br>快速排序</p><h2 id="算法思路-代码"><a href="#算法思路-代码" class="headerlink" title="算法思路+代码"></a>算法思路+代码</h2><p>1 利用顺序查找,遍历最小的值,然后返回</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> minArray = <span class="function"><span class="keyword">function</span>(<span class="params">numbers</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 直接返回空</span></span><br><span class="line">    <span class="keyword">if</span>(!numbers.length)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//长度为1</span></span><br><span class="line">    <span class="keyword">if</span>(numbers.length==<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> numbers[<span class="number">0</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 长度为2</span></span><br><span class="line">    <span class="keyword">if</span>(numbers.length==<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> numbers[<span class="number">0</span>]&gt;numbers[<span class="number">1</span>]?numbers[<span class="number">1</span>]:numbers[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 长度大于等于三</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">1</span>;i&lt;numbers.length;i++)&#123;</span><br><span class="line">        <span class="comment">// 直接比较到最后一个都没找出来，就比较第一个和最后一个</span></span><br><span class="line">        <span class="keyword">if</span>(i==(numbers.length<span class="number">-1</span>))&#123;</span><br><span class="line">        <span class="keyword">return</span> numbers[<span class="number">0</span>]&gt;numbers[i]?numbers[i]:numbers[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 找出该数，该数字满足大于前一个，小于或者等于后一个</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(numbers[i<span class="number">-1</span>]&gt;numbers[i]&amp;&amp;numbers[i]&lt;=numbers[i+<span class="number">1</span>])&#123;</span><br><span class="line">            <span class="keyword">return</span> numbers[i]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>结果:平均时间复杂度为O(n/2),最差时间复杂度为O(n)<br>执行用时：80 ms, 在所有 JavaScript 提交中击败了32.19%的用户<br>内存消耗：35.4 MB, 在所有 JavaScript 提交中击败了100.00%的用户</p><p>2 二分查找</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> minArray = <span class="function"><span class="keyword">function</span>(<span class="params">numbers</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//空数组，直接返回null</span></span><br><span class="line">    <span class="keyword">if</span>(!numbers.length)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> index1 = <span class="number">0</span>;<span class="comment">//第一个指针</span></span><br><span class="line">    <span class="keyword">let</span> index2 = numbers.length<span class="number">-1</span><span class="comment">//第二个指针</span></span><br><span class="line">    <span class="keyword">let</span> indexMid = index1;<span class="comment">//中间指针</span></span><br><span class="line">    <span class="comment">// 指针未重合</span></span><br><span class="line">    <span class="keyword">while</span>(index1 != index2)&#123;</span><br><span class="line">        <span class="comment">//更新中间值</span></span><br><span class="line">        indexMid = <span class="built_in">Math</span>.floor((index1+index2)/<span class="number">2</span>)</span><br><span class="line">        <span class="comment">//如果中间值处在index1的递增部分时，跟新index1的值为indexmid</span></span><br><span class="line">        <span class="keyword">if</span>(numbers[index1]&gt;numbers[indexMid])&#123;</span><br><span class="line">            index2=indexMid</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果中间值处在index2的递增部分时，更新index2的值为indexmid</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(numbers[index2]&lt;numbers[indexMid])&#123;</span><br><span class="line">            index1=indexMid+<span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果出现相等情况时，将index2向左移动一位，再进行判断，</span></span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            index2--</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> numbers[index2]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>结果:<br>执行用时：64 ms, 在所有 JavaScript 提交中击败了92.32%的用户<br>内存消耗：33.4 MB, 在所有 JavaScript 提交中击败了100.00%的用户</p>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
          <category> 11旋转数组最小数字 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 剑指offer </tag>
            
            <tag> 查找和排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer-10斐波那契数列</title>
      <link href="/2020/07/05/%E5%89%91%E6%8C%87offer-10%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/"/>
      <url>/2020/07/05/%E5%89%91%E6%8C%87offer-10%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h1 id="10斐波那契数列数列"><a href="#10斐波那契数列数列" class="headerlink" title="10斐波那契数列数列"></a>10斐波那契数列数列</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>写一个函数，输入 n ，求斐波那契（Fibonacci）数列的第 n 项。斐波那契数列的定义如下：</p><p>F(0) = 0,   F(1) = 1<br>F(N) = F(N - 1) + F(N - 2), 其中 N &gt; 1.<br>斐波那契数列由 0 和 1 开始，之后的斐波那契数就是由之前的两数相加而得出。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/fei-bo-na-qi-shu-lie-lcof" target="_blank" rel="noopener">https://leetcode-cn.com/problems/fei-bo-na-qi-shu-lie-lcof</a></p><h2 id="题解算法"><a href="#题解算法" class="headerlink" title="题解算法"></a>题解算法</h2><p>1 暴力算法（直接超时）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fib = <span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(n==<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> fib(n<span class="number">-1</span>)+fib(n<span class="number">-2</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>分析：为什么会超时：对于同一数字，会重复递归，增加时间和空间的开销<br>2 从头开始算,每个值只算一次这样就避免了重复递归<br>解法1：使用数组，但是增加了开销</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fib = <span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> i=[<span class="number">0</span>,<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">if</span>(n&lt;<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> i[n]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(i.length&lt;n+<span class="number">1</span>)&#123;</span><br><span class="line">        i.push((i[i.length<span class="number">-1</span>]+i[i.length<span class="number">-2</span>])%(<span class="number">1e9</span>+<span class="number">7</span>))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i.pop();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>结果：<br>执行用时：84 ms, 在所有 JavaScript 提交中击败了10.18%的用户<br>内存消耗：32.2 MB, 在所有 JavaScript 提交中击败了100.00%的用户<br>解法2：不使用数组</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fib = <span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> i=[<span class="number">0</span>,<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">if</span>(n&lt;<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> i[n]</span><br><span class="line">    &#125;</span><br><span class="line">    fibone = i[<span class="number">0</span>];</span><br><span class="line">    fibtwo = i[<span class="number">1</span>];</span><br><span class="line">    fibn = <span class="number">0</span>; </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> j=<span class="number">2</span>;j&lt;=n;++j)&#123;</span><br><span class="line">        fibn = (fibone +fibtwo)%(<span class="number">1e9</span>+<span class="number">7</span>);</span><br><span class="line">        fibone = fibtwo</span><br><span class="line">        fibtwo = fibn</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> fibn;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>结果：</p><p>执行用时：72 ms, 在所有 JavaScript 提交中击败了38.25%的用户<br>内存消耗：31.9 MB, 在所有 JavaScript 提交中击败了100.00%的用户</p><h1 id="青蛙跳台阶问题："><a href="#青蛙跳台阶问题：" class="headerlink" title="青蛙跳台阶问题："></a>青蛙跳台阶问题：</h1><blockquote><p>经分析后，我们可以得知：该问题是斐波那契数列的一个变种问题</p></blockquote><h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h2><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。<br>答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。<br>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/qing-wa-tiao-tai-jie-wen-ti-lcof" target="_blank" rel="noopener">https://leetcode-cn.com/problems/qing-wa-tiao-tai-jie-wen-ti-lcof</a></p>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
          <category> 斐波那契数列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 剑指offer </tag>
            
            <tag> 斐波那契数列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer-09用两个栈实现队列</title>
      <link href="/2020/07/05/%E5%89%91%E6%8C%87offer-09%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/"/>
      <url>/2020/07/05/%E5%89%91%E6%8C%87offer-09%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h1 id="09用两个栈实现队列"><a href="#09用两个栈实现队列" class="headerlink" title="09用两个栈实现队列"></a>09用两个栈实现队列</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>   用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，deleteHead 操作返回 -1 )</p><blockquote><p>示例1：<br>输入：<br>[“CQueue”,”appendTail”,”deleteHead”,”deleteHead”]<br>[[],[3],[],[]]<br>输出：[null,null,3,-1]<br>示例2：<br>输入：<br>[“CQueue”,”deleteHead”,”appendTail”,”appendTail”,”deleteHead”,”deleteHead”]<br>[[],[],[5],[2],[],[]]<br>输出：[null,-1,null,null,5,2]</p></blockquote><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof" target="_blank" rel="noopener">https://leetcode-cn.com/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof</a></p><h2 id="知识回顾"><a href="#知识回顾" class="headerlink" title="知识回顾"></a>知识回顾</h2><p>栈：先进后出<br>队列：后进先出</p><h2 id="算法思路及代码"><a href="#算法思路及代码" class="headerlink" title="算法思路及代码"></a>算法思路及代码</h2><p>1 js思路，js里面可以使用数组的reserve（）方法直接实现队列功能</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> CQueue = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//定义两个个数组</span></span><br><span class="line">    <span class="keyword">this</span>.stack=[]</span><br><span class="line">    <span class="keyword">this</span>.queue=[]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">value</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;void&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">CQueue.prototype.appendTail = <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//将入队值放入栈中</span></span><br><span class="line">    <span class="keyword">this</span>.stack.push(value)</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">CQueue.prototype.deleteHead = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果队列不为空</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>.queue.length)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.queue.pop()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果队列为空，则需要将栈中元素入队</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(<span class="keyword">this</span>.stack.length&amp;&amp; !<span class="keyword">this</span>.queue.length)&#123;</span><br><span class="line">        <span class="comment">// 栈元素倒序入队</span></span><br><span class="line">        <span class="keyword">this</span>.queue = <span class="keyword">this</span>.stack</span><br><span class="line">        <span class="keyword">this</span>.queue.reverse()</span><br><span class="line">        <span class="keyword">this</span>.stack=[]</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.queue.pop()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果栈和队都为空，则返回-1</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(!<span class="keyword">this</span>.stack.length&amp;&amp;!<span class="keyword">this</span>.queue.length)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>结果：</p><p>执行用时：488 ms, 在所有 JavaScript 提交中击败了71.96%的用户<br>内存消耗：47.5 MB, 在所有 JavaScript 提交中击败了100.00%的用户</p>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
          <category> 09用两个栈实现队列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 剑指offer </tag>
            
            <tag> 栈 </tag>
            
            <tag> 队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer-08二叉树的下一个节点</title>
      <link href="/2020/07/04/%E5%89%91%E6%8C%87offer-08%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E8%8A%82%E7%82%B9/"/>
      <url>/2020/07/04/%E5%89%91%E6%8C%87offer-08%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E8%8A%82%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<h1 id="08二叉树的下一个节点"><a href="#08二叉树的下一个节点" class="headerlink" title="08二叉树的下一个节点"></a>08二叉树的下一个节点</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一棵二叉树和其中的一个节点，如何找出中序遍历的下一个节点？树中的节点除了有两个分别指向左右子节点的指针，还有一个指向父节点的指针</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">GetNext</span>(<span class="params">pNode</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//如果该节点为空</span></span><br><span class="line">    <span class="keyword">if</span>（pNode===<span class="literal">null</span>）&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果该节点存在右子树，则下一节点是其右子树的最左子节点</span></span><br><span class="line">    <span class="keyword">if</span>（pNode.right!= <span class="literal">null</span>）&#123;</span><br><span class="line">        pNode=pNode.right;</span><br><span class="line">        <span class="keyword">while</span>(pNode.left!=<span class="literal">null</span>)&#123;</span><br><span class="line">          pNode = pNode.left</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pNode;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果该节点没有右子树，且是该父节点的左子节点，则下一节点是其父节点</span></span><br><span class="line">    <span class="keyword">if</span>（pNode.next.left ===pNode&amp;&amp;pNode.right==<span class="literal">null</span>）&#123;</span><br><span class="line">        <span class="keyword">return</span> pNode.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果该节点没有右子节点，且是该父节点的右子节点</span></span><br><span class="line">    <span class="comment">//则需要从上遍历，直到找到一个是其父节点的左子节点的节点</span></span><br><span class="line">    <span class="comment">//则所找到的节点的父节点是该节点的下一节点，找不到就说明没有下一节点</span></span><br><span class="line">     <span class="keyword">if</span>（pNode.next.right ===pNode&amp;&amp;pNode.right==<span class="literal">null</span>）&#123;</span><br><span class="line">        pNode = pNode.next;</span><br><span class="line">         <span class="comment">//不是根节点</span></span><br><span class="line">         <span class="keyword">while</span>（pNode.next!=<span class="literal">null</span>）&#123;</span><br><span class="line">             <span class="comment">//该节点是其父节点的左子节点</span></span><br><span class="line">             <span class="keyword">if</span>(pNode.next.left==pNode)&#123;</span><br><span class="line">                 <span class="keyword">return</span> pNode</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="keyword">else</span> pNode = pNode.next</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">//已经是根节点。则该节点不存在下一节点</span></span><br><span class="line">         <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
          <category> 08二叉树的下一个节点 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 剑指offer </tag>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>google上不去？</title>
      <link href="/2020/07/04/google%E4%B8%8A%E4%B8%8D%E5%8E%BB%EF%BC%9F/"/>
      <url>/2020/07/04/google%E4%B8%8A%E4%B8%8D%E5%8E%BB%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="Google上不去？"><a href="#Google上不去？" class="headerlink" title="Google上不去？"></a>Google上不去？</h1><blockquote><p>最近在上Google时发现自己上不去Google了，然后就开始了头铁的解决之路</p></blockquote><h2 id="尝试1"><a href="#尝试1" class="headerlink" title="尝试1:"></a>尝试1:</h2><p>以为是vps的节点问题，更换了多次节点，发现还是没用，人都傻了。<br>然后我就想，这个机场出问题了？应该不会吧.。。<br>又顺手尝试了一下YouTube，发现YouTube可以顺利打开，这下人又傻了，那这是什么问题？</p><h2 id="尝试2"><a href="#尝试2" class="headerlink" title="尝试2"></a>尝试2</h2><p>我去电报群里面问了一下，大家说，可能是代理的问题，因为如果不开代理的话，你是无法访问外网的。<br>我说实话一直就不理解代理是什么意思，只是知道从哪里开，哪里关。<br>然后各种开开关关，发现关了代理的话YouTube也上不去了，这肯定不对<br>这就说明了和代理没问题</p><h2 id="尝试3"><a href="#尝试3" class="headerlink" title="尝试3"></a>尝试3</h2><p>大家都沉默了一段时候以后，救星出现了，他说：这是ssr的问题，之前他也出现过这种情况，修改一下系统代理模式，由全局换到自定义就好了。<br>至此，顺利解决</p><h2 id="后记："><a href="#后记：" class="headerlink" title="后记："></a>后记：</h2><p>当救星说出是ssr问题的时候，我立马从Google找到了相关问题以及下方的解决方案。<br>解答链接<a href="https://github.com/shadowsocksrr/shadowsocksr-csharp/issues/119" target="_blank" rel="noopener">https://github.com/shadowsocksrr/shadowsocksr-csharp/issues/119</a></p><p>说起来惭愧，这学期的网络原理就没学多少东西。而在使用vpn的时候，出现的问题绝大部分都是网络问题。只有了解网络知识，才能更好的解决方案。<br>对症下药，总得先明白症状才行。</p><p>不多说了，好好学习网络原理吧。</p>]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vpn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer-07重建二叉树</title>
      <link href="/2020/07/04/%E5%89%91%E6%8C%87offer-07%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
      <url>/2020/07/04/%E5%89%91%E6%8C%87offer-07%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h1 id="07重建二叉树"><a href="#07重建二叉树" class="headerlink" title="07重建二叉树"></a>07重建二叉树</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><blockquote><p>输入某二叉树的前序遍历和中序遍历的结果，请重建该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。<br>例如，给出<br>前序遍历 preorder = [3,9,20,15,7]<br>中序遍历 ignorer = [9,3,15,20,7]<br>返回如下的二叉树：</p></blockquote><blockquote><p>3<br>  /  <br> 9   20<br>  /    <br> 15   7</p></blockquote><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof" target="_blank" rel="noopener">https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof</a></p><h2 id="知识回顾"><a href="#知识回顾" class="headerlink" title="知识回顾"></a>知识回顾</h2><p>二叉树：树的一种特殊形式，每个节点最多只有两个子节点（下图为例）<br>前序遍历：先访问根节点，再访问左子节点，后访问右子节点<br>遍历顺序：10，6，4，8，14，12，16<br>中序遍历：先访问左子节点，再访问根节点，后访问右子节点<br>遍历顺序：4，6，8，10，12，14，16<br>后序遍历：先访问左子节点，再访问右子节点，后访问根节点<br>遍历顺序：4，8，6，12，16，14，10<br>宽度优先遍历：先访问书的第一层节点，再访问树的第二层节点，直到访问树的<br>遍历顺序：10，6，14，4，8，12，16<br>最后一层节点<br>    10<br>   /  <br>  6         14<br> /   \         /     <br>4     8     12     16</p><h2 id="算法思路及代码"><a href="#算法思路及代码" class="headerlink" title="算法思路及代码"></a>算法思路及代码</h2><h2 id="通用递归算法"><a href="#通用递归算法" class="headerlink" title="通用递归算法"></a>通用递归算法</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> buildTree = <span class="function"><span class="keyword">function</span>(<span class="params">preorder, inorder</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果前序遍历数组为零，则返回空</span></span><br><span class="line">    <span class="keyword">if</span>(!preorder.length)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 先构建根节点</span></span><br><span class="line">    <span class="keyword">let</span> rootNode = <span class="keyword">new</span> TreeNode(preorder[<span class="number">0</span>]);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//创建左子树的前序遍历数组</span></span><br><span class="line">    preorderLeft=preorder.slice(<span class="number">1</span>,inorder.indexOf(preorder[<span class="number">0</span>])+<span class="number">1</span>)</span><br><span class="line">    <span class="comment">// 创建左子树的中序遍历数组</span></span><br><span class="line">    inorderLeft = inorder.slice(<span class="number">0</span>,inorder.indexOf(preorder[<span class="number">0</span>]))</span><br><span class="line">    rootNode.left = buildTree(preorderLeft,inorderLeft)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建右子树的前序遍历</span></span><br><span class="line">    preorderRight = preorder.slice(inorder.indexOf(preorder[<span class="number">0</span>])+<span class="number">1</span>)</span><br><span class="line">    <span class="comment">// 创建右子树的中序遍历</span></span><br><span class="line">    inorderRight  = inorder.slice(inorder.indexOf(preorder[<span class="number">0</span>])+<span class="number">1</span>)</span><br><span class="line">    rootNode.right = buildTree(preorderRight,inorderRight)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> rootNode;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>Tips：<br>注意：使用递归时，要给每一个变量定义类型，var，let都行<br>防止其成为全局变量，污染整个环境</p></blockquote><p>结果:<br>执行用时：200 ms, 在所有 JavaScript 提交中击败了11.79%的用户<br>内存消耗：111.4 MB, 在所有 JavaScript 提交中击败了100.00%的用户</p><h2 id="对slice方法优化"><a href="#对slice方法优化" class="headerlink" title="对slice方法优化"></a>对slice方法优化</h2><p>slice方法会增加新的数组，可以记录下开头和结尾，节省时间和空间<br>只改参数，不改数组</p>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
          <category> 07重建二叉树 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 剑指offer </tag>
            
            <tag> 树 </tag>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer-06从尾到头打印链表</title>
      <link href="/2020/07/01/%E5%89%91%E6%8C%87offer-06%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8/"/>
      <url>/2020/07/01/%E5%89%91%E6%8C%87offer-06%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="06-从尾到头打印链表"><a href="#06-从尾到头打印链表" class="headerlink" title="06 从尾到头打印链表"></a>06 从尾到头打印链表</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><blockquote><p>输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。<br>示例 ：<br>输入：head = [1,3,2]<br>输出：[2,3,1]<br><a href="https://leetcode-cn.com/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof/</a></p></blockquote><h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><p>最简单的做法就是调用数组的resver方法，先把链表的所有值从头到尾打印到数组中，然后调用resver方法，将数组中的内容倒序</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> reversePrint = <span class="function"><span class="keyword">function</span>(<span class="params">head</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> num = [],flag = <span class="literal">true</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(flag&amp;&amp;head)&#123;</span><br><span class="line">        <span class="keyword">if</span>(head.next==<span class="literal">null</span>)&#123;</span><br><span class="line">            num.push(head.val)     </span><br><span class="line">            flag =<span class="literal">false</span>;        </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;           </span><br><span class="line">            num.push(head.val)</span><br><span class="line">            head = head.next </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> num.reverse()</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>结果：时间复杂度为O（n），空间复杂度为O(1)<br>执行用时：80 ms, 在所有 JavaScript 提交中击败了65.64%的用户<br>内存消耗：36.9 MB, 在所有 JavaScript 提交中击败了100.00%的用户</p>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
          <category> 06从尾到头打印链表 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 剑指offer </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer-05替换空格</title>
      <link href="/2020/06/30/%E5%89%91%E6%8C%87offer-05%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC/"/>
      <url>/2020/06/30/%E5%89%91%E6%8C%87offer-05%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC/</url>
      
        <content type="html"><![CDATA[<h1 id="5-替换空格"><a href="#5-替换空格" class="headerlink" title="5 替换空格"></a>5 替换空格</h1><h2 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h2><blockquote><p>请实现一个函数，把字符串 s 中的每个空格替换成”%20”。<br>示例：<br>输入：s = “We are happy.”<br>输出：”We%20are%20happy.”</p></blockquote><h2 id="解法："><a href="#解法：" class="headerlink" title="解法："></a>解法：</h2><p>目的：代码量最少</p><h2 id="1-利用字符串的split-和数组的join-方法"><a href="#1-利用字符串的split-和数组的join-方法" class="headerlink" title="1 利用字符串的split()和数组的join()方法"></a>1 利用字符串的split()和数组的join()方法</h2><blockquote><p>Split() 方法使用指定的分隔符字符串将一个String对象分割成子字符串数组，以一个指定的分割字串来决定每个拆分的位置<br>join() 方法将一个数组（或一个类数组对象）的所有元素连接成一个字符串并返回这个字符串。如果数组只有一个项目，那么将返回该项目而不使用分隔符。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> replaceSpace = <span class="function"><span class="keyword">function</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s.split(<span class="string">' '</span>).join(<span class="string">'%20'</span>)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>结果：<br>执行用时：76 ms, 在所有 JavaScript 提交中击败了19.36%的用户<br>内存消耗：32.2 MB, 在所有 JavaScript 提交中击败了100.00%的用户</p><h2 id="2-利用正则表达式"><a href="#2-利用正则表达式" class="headerlink" title="2 利用正则表达式"></a>2 利用正则表达式</h2><p>这是必须想到的方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> replaceSpace = <span class="function"><span class="keyword">function</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s.replace(<span class="regexp">/ /g</span>,<span class="string">'%20'</span>)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>结果：</p><p>执行用时：68 ms, 在所有 JavaScript 提交中击败了56.01%的用户<br>内存消耗：32.2 MB, 在所有 JavaScript 提交中击败了100.00%的用户</p><h2 id="3-利用双指针，也就是想考察的方法"><a href="#3-利用双指针，也就是想考察的方法" class="headerlink" title="3 利用双指针，也就是想考察的方法"></a>3 利用双指针，也就是想考察的方法</h2><p>注意一点：两个指针，分别用来表示原字符串的末尾位置和新字符串的末尾位置</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> replaceSpace = <span class="function"><span class="keyword">function</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> blank=<span class="number">0</span><span class="comment">//记录空格数</span></span><br><span class="line">    <span class="keyword">for</span>(i <span class="keyword">in</span> s)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i]==<span class="string">' '</span>)</span><br><span class="line">        blank++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> index1=s.length<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">let</span> index2=s.length+<span class="number">2</span>*blank<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">let</span> l=[]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(index1&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="keyword">if</span>(s[index1]!=<span class="string">' '</span>)&#123;</span><br><span class="line">            l[index2]=s[index1];</span><br><span class="line">            index2--;</span><br><span class="line">            index1--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            l[index2]=<span class="number">0</span></span><br><span class="line">            index2--</span><br><span class="line">            l[index2]=<span class="number">2</span></span><br><span class="line">            index2--</span><br><span class="line">            l[index2]=<span class="string">'%'</span></span><br><span class="line">            index2--</span><br><span class="line">            index1--</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l.join(<span class="string">''</span>)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>结果：<br>执行用时：64 ms, 在所有 JavaScript 提交中击败了76.80%的用户<br>内存消耗：32.5 MB, 在所有 JavaScript 提交中击败了100.00%的用户</p>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
          <category> 05替换空格 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 剑指offer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer-04二维数组中的查找</title>
      <link href="/2020/06/30/%E5%89%91%E6%8C%87offer-04%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE/"/>
      <url>/2020/06/30/%E5%89%91%E6%8C%87offer-04%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE/</url>
      
        <content type="html"><![CDATA[<h1 id="4-二维数组中的查找"><a href="#4-二维数组中的查找" class="headerlink" title="4 二维数组中的查找"></a>4 二维数组中的查找</h1><p>基本题目</p><blockquote><p>在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p><p>示例:<br>现有矩阵 matrix 如下：<br>[<br> [1,   4,  7, 11, 15],<br> [2,   5,  8, 12, 19],<br> [3,   6,  9, 16, 22],<br> [10, 13, 14, 17, 24],<br> [18, 21, 23, 26, 30]<br>]<br>给定 target = 5，返回 true。<br>给定 target = 20，返回 false。</p><p>链接：<a href="https://leetcode-cn.com/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof" target="_blank" rel="noopener">https://leetcode-cn.com/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof</a></p></blockquote><p>解法：<br>1 我的第一思路，是根据对角线的值来逼近，确定值可能得范围<br>最后确定出其所处位置必定为两个对角线所在线段的夹角区域<br>然后遍历两个区域来寻找</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;matrix.length<span class="number">-1</span>;i++)&#123;</span><br><span class="line">            <span class="comment">// 两个对角线的值，将该函数确定在两个小矩阵范围内</span></span><br><span class="line">            <span class="keyword">if</span>(target&gt;=matrix[i][i]&amp;&amp;target&lt;=matrix[i+<span class="number">1</span>][i+<span class="number">1</span>])&#123;</span><br><span class="line">                <span class="built_in">console</span>.log(matrix.length)</span><br><span class="line">                <span class="comment">// 遍历左下方矩阵：matrix[i+1~length-1][0~i]</span></span><br><span class="line">                <span class="comment">//遍历右上方矩阵matrix[0~i][i+1~length]</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">let</span> k=i+<span class="number">1</span>;k&lt;matrix.length;k++)&#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">let</span> j=<span class="number">0</span>;j&lt;i+<span class="number">1</span>;j++)&#123;</span><br><span class="line">                        <span class="keyword">if</span>(target == matrix[k][j])&#123;</span><br><span class="line">                            <span class="built_in">console</span>.log(<span class="string">"找到："</span>)</span><br><span class="line">                            <span class="built_in">console</span>.log(<span class="string">"matrix["</span>+k+<span class="string">"]["</span>+j+<span class="string">"]:"</span>+matrix[k][j])</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span>(target == matrix[j][k])&#123;</span><br><span class="line">                            <span class="built_in">console</span>.log(<span class="string">"找到："</span>)</span><br><span class="line">                            <span class="built_in">console</span>.log(<span class="string">"matrix["</span>+j+<span class="string">"]["</span>+k+<span class="string">"]:"</span>+matrix[j][k])</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>2 判断右上角或者左下角的值，一次排除一列或者一行</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> findNumberIn2DArray = <span class="function"><span class="keyword">function</span>(<span class="params">matrix, target</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> result = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">if</span>(matrix!= [])&#123;</span><br><span class="line">    <span class="keyword">let</span> j=matrix.length<span class="number">-1</span></span><br><span class="line">    <span class="keyword">while</span>(j&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">//如果比当前行最小值都小，舍弃当前行</span></span><br><span class="line">        <span class="keyword">if</span>(target &lt;matrix[j])&#123;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">let</span> k=j;k&gt;=<span class="number">0</span>;k--)&#123;</span><br><span class="line">                <span class="keyword">if</span>(matrix[k].includes(target))&#123;</span><br><span class="line">                    result = <span class="literal">true</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果不存在，则跳出循环</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;          </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>利用了js数组中的includes（）方法，<br>表面时间复杂度为：O(n)<br>其实时间复杂度为O(n2)<br>Leecode结果如下：</p><blockquote></blockquote><p>执行用时：88 ms, 在所有 JavaScript 提交中击败了26.54%的用户<br>内存消耗：34.9 MB, 在所有 JavaScript 提交中击败了100.00%的用户</p><p>3 暴力降维，由二维转化为一维</p><blockquote><p>利用es6的…运算符+数组的push方法<br>数组的contac方法也可以</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> findNumberIn2DArray = <span class="function"><span class="keyword">function</span>(<span class="params">matrix, target</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> arr=[]</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i =<span class="number">0</span>;i&lt;matrix.length;i++)&#123;</span><br><span class="line">        arr.push(...matrix[i])</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr.includes(target)    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度为：O（n）<br>空间复杂度为：O(n2)</p><p>执行用时：84 ms, 在所有 JavaScript 提交中击败了35.65%的用户<br>内存消耗：38.1 MB, 在所有 JavaScript 提交中击败了100.00%的用户</p>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
          <category> 04-二维数组中的查找 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 剑指offer </tag>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我的云之路-实例创建</title>
      <link href="/2020/06/29/%E6%88%91%E7%9A%84%E4%BA%91%E4%B9%8B%E8%B7%AF-%E5%AE%9E%E4%BE%8B%E5%88%9B%E5%BB%BA/"/>
      <url>/2020/06/29/%E6%88%91%E7%9A%84%E4%BA%91%E4%B9%8B%E8%B7%AF-%E5%AE%9E%E4%BE%8B%E5%88%9B%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>我的云之路-ECS简介</title>
      <link href="/2020/06/29/%E6%88%91%E7%9A%84%E4%BA%91%E4%B9%8B%E8%B7%AF-ECS%E7%AE%80%E4%BB%8B/"/>
      <url>/2020/06/29/%E6%88%91%E7%9A%84%E4%BA%91%E4%B9%8B%E8%B7%AF-ECS%E7%AE%80%E4%BB%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="ECS简介"><a href="#ECS简介" class="headerlink" title="ECS简介"></a>ECS简介</h1><blockquote><p>这个ECS,它到底是什么？我为什么要用？<br>阿里云：七天玩转云服务器</p></blockquote><h2 id="什么是ECS"><a href="#什么是ECS" class="headerlink" title="什么是ECS"></a>什么是ECS</h2><p>云服务器( Elastic Compute Service ,简称ECS )是一种简单高效、处理能力可弹性伸缩的计算服务,帮助您快速构建更稳定、安全的应用,提升运维效率,降低IT成本,使您更专注于核心业务创新。</p><h2 id="产品定位和实现原理"><a href="#产品定位和实现原理" class="headerlink" title="产品定位和实现原理"></a>产品定位和实现原理</h2><p>●ECS (云服务器)是阿里云产品体系中,最基础<br>的计算服务,通常用作应用程序的运行环境,其最<br>重要的特点是弹性。<br>●基于阿里云自主研发的大规模分布式计算系统,<br>通过虚拟化技术整理IT资源,为各行业提供互联网<br>基础设施服务设备。</p><h2 id="应用的基础运行环境"><a href="#应用的基础运行环境" class="headerlink" title="应用的基础运行环境"></a>应用的基础运行环境</h2><p>●应用程序的基础运行环境<br>每个ECS实例上都运行着用户选择的操作系统,-般是某 个Linux或<br>Windows的发行版,<br>用户的应用程序运行在实例的操作系统之上。<br>最简化的弹性架构<br>较好的实践是将ECS和其他云计算产品配合使用,<br>例如,将使用ECS运行webserver ,使用RDS作为数据库, OSS作为<br>文件存储,<br>应避免完全将原有物理服务器.上的应用都照搬跑到云服务器上。</p><h2 id="ECS的弹性伸缩"><a href="#ECS的弹性伸缩" class="headerlink" title="ECS的弹性伸缩"></a>ECS的弹性伸缩</h2><p>ECS的最重要的特点是弹性,支持纵向和横向扩展两种能力。<br>纵向的弹性,即单个服务器的配置变更。传统IDC模式下,很难做到对单个服务器进行变<br>更配置。而对于阿里云,当您购买了云服务器或者存储的容量后,可以根据业务量的增长或者<br>减少自由变更自己的配置。<br>横向的弹性。对于游戏应用或直播平台出现的高峰期,若在传统的IDC模式下,您根本无<br>法立即准备资源;而云计算却可以使用弹性的方式帮助客户度过这样的高峰。当业务高峰消失<br>时,您可以将多余的资源释放掉,以减少业务成本的开支。</p><h2 id="优势（和传统服务器相比）"><a href="#优势（和传统服务器相比）" class="headerlink" title="优势（和传统服务器相比）"></a>优势（和传统服务器相比）</h2><ul><li><p>稳定<br>实例可用性达99.95% ,云盘数据可靠性不低于999999%<br>自动者机迁移，自动快照备份(需手动配快照策略) . 数据恢复更方便<br>需手工备份，人工数据恢复困难、耗时</p></li><li><p>弹性<br>白由配置CPU.内存、带宽,可随时升级<br>升级配置数据不丢失,业务暂停时间可控</p></li><li><p>安全<br>免费提供DDoS防护、木马查杀，防暴力破解等服务<br>可轻松实现多用户对多服务器的访问控制</p></li><li><p>成本<br>高性价比,支持包年包月或按量计费，满足不同需求<br>无需服务器网络和硬件等维护, 0成本运维</p></li><li><p>易用性<br>丰富的操作系统和应用软件，通过境像可-键简单部署<br>同一境像可在多台ECS中快速复制环境,轻松扩展</p></li><li><p>可拓展性<br>ECS可与阿里云各种丰富的云产品无缝街接<br>可持续为业务发展提供完整的计算，存储、安全等解决方案</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 我的云之路 </category>
          
          <category> ECS简介 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 我的云之路 </tag>
            
            <tag> ECS简介 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ES6-扩展部分</title>
      <link href="/2020/06/26/ES6-%E6%89%A9%E5%B1%95%E9%83%A8%E5%88%86/"/>
      <url>/2020/06/26/ES6-%E6%89%A9%E5%B1%95%E9%83%A8%E5%88%86/</url>
      
        <content type="html"><![CDATA[<h1 id="字符串扩展"><a href="#字符串扩展" class="headerlink" title="字符串扩展"></a>字符串扩展</h1><ol><li><p>includes(str) : 判断是否包含指定的字符串</p></li><li><p>startsWith(str) : 判断是否以指定字符串开头</p></li><li><p>endsWith(str) : 判断是否以指定字符串结尾</p></li><li><p>repeat(count) : 重复指定次数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">'abcdefg'</span>;</span><br><span class="line">   <span class="built_in">console</span>.log(str.includes(<span class="string">'a'</span>));<span class="comment">//true</span></span><br><span class="line">   <span class="built_in">console</span>.log(str.includes(<span class="string">'h'</span>));<span class="comment">//false</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">//startsWith(str) : 判断是否以指定字符串开头</span></span><br><span class="line">   <span class="built_in">console</span>.log(str.startsWith(<span class="string">'a'</span>));<span class="comment">//true</span></span><br><span class="line">   <span class="built_in">console</span>.log(str.startsWith(<span class="string">'d'</span>));<span class="comment">//false</span></span><br><span class="line">   <span class="comment">//endsWith(str) : 判断是否以指定字符串结尾</span></span><br><span class="line">   <span class="built_in">console</span>.log(str.endsWith(<span class="string">'g'</span>));<span class="comment">//true</span></span><br><span class="line">   <span class="built_in">console</span>.log(str.endsWith(<span class="string">'d'</span>));<span class="comment">//false</span></span><br><span class="line">   <span class="comment">//repeat(count) : 重复指定次数a</span></span><br><span class="line">   <span class="built_in">console</span>.log(str.repeat(<span class="number">5</span>));</span><br></pre></td></tr></table></figure><h1 id="数值扩展"><a href="#数值扩展" class="headerlink" title="数值扩展"></a>数值扩展</h1></li><li><p>二进制与八进制数值表示法: 二进制用0b, 八进制用0o</p></li><li><p>Number.isFinite(i) : 判断是否是有限大的数</p></li><li><p>Number.isNaN(i) : 判断是否是NaN</p></li><li><p>Number.isInteger(i) : 判断是否是整数</p></li><li><p>Number.parseInt(str) : 将字符串转换为对应的数值</p></li><li><p>Math.trunc(i) : 直接去除小数部分</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">0b1010</span>);<span class="comment">//10</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">0o56</span>);<span class="comment">//46</span></span><br><span class="line"><span class="comment">//Number.isFinite(i) : 判断是否是有限大的数</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>.isFinite(<span class="literal">NaN</span>));<span class="comment">//false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>.isFinite(<span class="number">5</span>));<span class="comment">//true</span></span><br><span class="line"><span class="comment">//Number.isNaN(i) : 判断是否是NaN</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>.isNaN(<span class="literal">NaN</span>));<span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>.isNaN(<span class="number">5</span>));<span class="comment">//falsse</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Number.isInteger(i) : 判断是否是整数</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>.isInteger(<span class="number">5.23</span>));<span class="comment">//false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>.isInteger(<span class="number">5.0</span>));<span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>.isInteger(<span class="number">5</span>));<span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Number.parseInt(str) : 将字符串转换为对应的数值</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>.parseInt(<span class="string">'123abc'</span>));<span class="comment">//123</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>.parseInt(<span class="string">'a123abc'</span>));<span class="comment">//NaN</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Math.trunc(i) : 直接去除小数部分</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.trunc(<span class="number">13.123</span>));<span class="comment">//13</span></span><br></pre></td></tr></table></figure><h1 id="数组扩展"><a href="#数组扩展" class="headerlink" title="数组扩展"></a>数组扩展</h1></li><li><p>Array.from(v) : 将伪数组对象或可遍历对象转换为真数组</p></li><li><p>Array.of(v1, v2, v3) : 将一系列值转换成数组</p></li><li><p>find(function(value, index, arr){return true}) : 找出第一个满足条件返回true的元素</p></li><li><p>findIndex(function(value, index, arr){return true}) : 找出第一个满足条件返回true的元素下标</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Array.from(v) : 将伪数组对象或可遍历对象转换为真数组</span></span><br><span class="line">    <span class="keyword">let</span> btns = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'button'</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(btns.length);<span class="comment">//3</span></span><br><span class="line">    <span class="built_in">Array</span>.from(btns).forEach(<span class="function"><span class="keyword">function</span> (<span class="params">item, index</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(item, index);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">//Array.of(v1, v2, v3) : 将一系列值转换成数组</span></span><br><span class="line">    <span class="keyword">let</span> arr = <span class="built_in">Array</span>.of(<span class="number">1</span>, <span class="string">'abc'</span>, <span class="literal">true</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(arr);</span><br><span class="line">    <span class="comment">//find(function(value, index, arr)&#123;return true&#125;) : 找出第一个满足条件返回true的元素</span></span><br><span class="line">    <span class="keyword">let</span> arr1 = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">3</span>];</span><br><span class="line">    <span class="keyword">let</span> result = arr1.find(<span class="function"><span class="keyword">function</span> (<span class="params">item, index</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> item &gt;<span class="number">3</span></span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">console</span>.log(result);<span class="comment">//5</span></span><br><span class="line">    <span class="comment">//findIndex(function(value, index, arr)&#123;return true&#125;) : 找出第一个满足条件返回true的元素下标</span></span><br><span class="line">    <span class="keyword">let</span> result1 = arr1.findIndex(<span class="function"><span class="keyword">function</span> (<span class="params">item, index</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> item &gt;<span class="number">3</span></span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">console</span>.log(result1);<span class="comment">//2</span></span><br></pre></td></tr></table></figure><h1 id="对象扩展"><a href="#对象扩展" class="headerlink" title="对象扩展"></a>对象扩展</h1></li><li><p>Object.is(v1, v2)</p><ul><li>判断2个数据是否完全相等<blockquote><p>根据字符串编码来确定是否相等<br>注意与==，===区分</p></blockquote></li></ul></li><li><p>Object.assign(target, source1, source2..)</p><ul><li>将源对象的属性复制到目标对象上</li></ul></li><li><p>直接操作 <strong>proto</strong> 属性<br> let obj2 = {};<br> obj2.<strong>proto</strong> = obj1;</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.is(<span class="string">'abc'</span>, <span class="string">'abc'</span>));<span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">NaN</span> == <span class="literal">NaN</span>);<span class="comment">//false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.is(<span class="literal">NaN</span>, <span class="literal">NaN</span>));<span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">0</span> == <span class="number">-0</span>);<span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.is(<span class="number">0</span>, <span class="number">-0</span>));<span class="comment">//false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Object.assign(target, source1, source2..)</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;<span class="attr">name</span> : <span class="string">'kobe'</span>, <span class="attr">age</span> : <span class="number">39</span>, <span class="attr">c</span>: &#123;<span class="attr">d</span>: <span class="number">2</span>&#125;&#125;;</span><br><span class="line"><span class="keyword">let</span> obj1 = &#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.assign(obj1, obj);</span><br><span class="line"><span class="built_in">console</span>.log(obj1, obj1.name);</span><br><span class="line"></span><br><span class="line"><span class="comment">//直接操作 __proto__ 属性</span></span><br><span class="line"><span class="keyword">let</span> obj3 = &#123;<span class="attr">name</span> : <span class="string">'anverson'</span>, <span class="attr">age</span> : <span class="number">41</span>&#125;;</span><br><span class="line"><span class="keyword">let</span> obj4 = &#123;&#125;;</span><br><span class="line">obj4.__proto__ = obj3;</span><br><span class="line"><span class="built_in">console</span>.log(obj4, obj4.name, obj4.age);</span><br></pre></td></tr></table></figure><h1 id="深度克隆deepclone"><a href="#深度克隆deepclone" class="headerlink" title="深度克隆deepclone"></a>深度克隆deepclone</h1><h2 id="基本数据"><a href="#基本数据" class="headerlink" title="基本数据"></a>基本数据</h2></li></ol><ul><li>据分为基本的数据类型(String, Number, boolean, Null, Undefined)和对象数据类型<br>基本数据类型：<br>特点： 存储的是该对象的实际数据<br>对象数据类型：<br>特点： 存储的是该对象在栈中引用，真实的数据存放在堆内存里<h2 id="复制数据"><a href="#复制数据" class="headerlink" title="复制数据"></a>复制数据</h2>基本数据类型存放的就是实际的数据，可直接复制<br>let number2 = 2;<br>let number1 = number2;<h2 id="克隆数据：对象-数组"><a href="#克隆数据：对象-数组" class="headerlink" title="克隆数据：对象/数组"></a>克隆数据：对象/数组</h2>1、区别： 浅拷贝/深度拷贝<br>判断： 拷贝是否产生了新的数据还是拷贝的是数据的引用<br>知识点：对象数据存放的是对象在栈内存的引用，直接复制的是对象的引用<br>let obj = {username: ‘kobe’}<br>let obj1 = obj; // obj1 复制了obj在栈内存的引用<br>2、常用的拷贝技术<br>1). arr.concat(): 数组浅拷贝<br>2). arr.slice(): 数组浅拷贝<br>3). JSON.parse(JSON.stringify(arr/obj)): 数组或对象深拷贝, 但不能处理函数数据<br>4). 浅拷贝包含函数数据的对象/数组<br>5). 深拷贝包含函数数据的对象/数组</li></ul><h1 id="set和map容器"><a href="#set和map容器" class="headerlink" title="set和map容器"></a>set和map容器</h1><h2 id="Set容器"><a href="#Set容器" class="headerlink" title="Set容器 :"></a>Set容器 :</h2><p>无序不可重复的多个value的集合体</p><ul><li><p>Set()</p></li><li><p>Set(array)</p></li><li><p>add(value)</p></li><li><p>delete(value)</p></li><li><p>has(value)</p></li><li><p>clear()</p></li><li><p>size</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">set</span> = new Set([1,2,3,4,3,2,1,6]);</span><br><span class="line">console.log(<span class="keyword">set</span>);</span><br><span class="line"><span class="keyword">set</span>.add('abc');</span><br><span class="line">console.log(<span class="keyword">set</span>, <span class="keyword">set</span>.size);</span><br><span class="line">//delete(value)</span><br><span class="line"><span class="keyword">set</span>.delete(2);</span><br><span class="line">console.log(<span class="keyword">set</span>);</span><br><span class="line">//has(value)</span><br><span class="line">console.log(<span class="keyword">set</span>.has(2));//false</span><br><span class="line">console.log(<span class="keyword">set</span>.has(1));//true</span><br><span class="line">//clear()</span><br><span class="line"><span class="keyword">set</span>.clear();</span><br><span class="line">console.log(<span class="keyword">set</span>);</span><br></pre></td></tr></table></figure><h2 id="Map容器"><a href="#Map容器" class="headerlink" title="Map容器 :"></a>Map容器 :</h2><p>无序的 key不重复的多个key-value的集合体</p></li><li><p>Map()</p></li><li><p>Map(array)</p></li><li><p>set(key, value)//添加</p></li><li><p>get(key)</p></li><li><p>delete(key)</p></li><li><p>has(key)</p></li><li><p>clear()</p></li><li><p>size</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>([[<span class="string">'abc'</span>, <span class="number">12</span>],[<span class="number">25</span>, <span class="string">'age'</span>]]);</span><br><span class="line"><span class="built_in">console</span>.log(map);</span><br><span class="line">map.set(<span class="string">'男'</span>, <span class="string">'性别'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(map);</span><br><span class="line"><span class="built_in">console</span>.log(map.get(<span class="number">25</span>));<span class="comment">//age</span></span><br><span class="line"><span class="comment">//delete(key)</span></span><br><span class="line">map.delete(<span class="string">'男'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(map);</span><br><span class="line"><span class="built_in">console</span>.log(map.has(<span class="string">'男'</span>));<span class="comment">//false</span></span><br><span class="line"><span class="built_in">console</span>.log(map.has(<span class="string">'abc'</span>));<span class="comment">//true</span></span><br><span class="line">map.clear();</span><br><span class="line"><span class="built_in">console</span>.log(map);</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> ES6 </category>
          
          <category> 扩展部分 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ES6扩展 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ES6-ES5回顾</title>
      <link href="/2020/06/22/ES6-ES5%E5%9B%9E%E9%A1%BE/"/>
      <url>/2020/06/22/ES6-ES5%E5%9B%9E%E9%A1%BE/</url>
      
        <content type="html"><![CDATA[<h1 id="严格模式"><a href="#严格模式" class="headerlink" title="严格模式"></a>严格模式</h1><p>这种模式使得Javascript在更严格的语法条件下运行</p><p>目的(作用)</p><ul><li>消除Javascript语法的一些不合理、不严谨之处，减少一些怪异行为</li><li>消除代码运行的一些不安全之处，为代码的安全运行保驾护航</li><li>为未来新版本的Javascript做好铺垫</li></ul><p>使用</p><ul><li>在全局或函数的第一条语句定义为: ‘use strict’;</li><li>如果浏览器不支持, 只解析为一条简单的语句, 没有任何副作用</li></ul><p>语法和行为改变</p><ul><li>必须用var声明变量</li><li>对象不能有重名的属性</li><li>禁止自定义的函数中的this指向window</li><li>创建eval作用域</li></ul><blockquote><p>eval()方法，可以解析传入eval函数的代码执行语句<br>eval(‘alert(name)’)，代码会执行<br>如果不开全局模式，eval内部定义的变量，默认为全局变量<br>会污染作用域，同时容易被恶意代码攻击</p></blockquote><h1 id="json对象"><a href="#json对象" class="headerlink" title="json对象"></a>json对象</h1><ol><li>JSON.stringify(obj/arr)<ul><li>js对象(数组)转换为json对象(数组)</li></ul></li><li>JSON.parse(json)<ul><li>json对象(数组)转换为js对象(数组)</li></ul></li></ol><h1 id="object对象扩展"><a href="#object对象扩展" class="headerlink" title="object对象扩展"></a>object对象扩展</h1><ol><li>Object.create(prototype, [descriptors])<ul><li>作用: 以指定对象为原型创建新的对象</li><li>为新的对象指定新的属性, 并对属性进行描述<br>value : 指定值<br>writable : 标识当前属性值是否是可修改的, 默认为false<br>configurable: 标识当前属性是否可以被删除 默认为false<br>enumerable： 标识当前属性是否能用for in 枚举 默认为false<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;<span class="attr">name</span> : <span class="string">'curry'</span>, <span class="attr">age</span> : <span class="number">29</span>&#125;</span><br><span class="line"><span class="keyword">var</span> obj1 = &#123;&#125;;</span><br><span class="line">obj1 = <span class="built_in">Object</span>.create(obj, &#123;</span><br><span class="line">    sex : &#123;</span><br><span class="line">        value : <span class="string">'男'</span>,</span><br><span class="line">        writable : <span class="literal">true</span><span class="comment">//该属性可修改</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">obj1.sex = <span class="string">'女'</span>;<span class="comment">//</span></span><br><span class="line"><span class="built_in">console</span>.log(obj1.sex);<span class="comment">//writable属性为false时，无法修改sex属性，为true时才可修改</span></span><br></pre></td></tr></table></figure></li></ul></li><li>Object.defineProperties(object, descriptors)<ul><li>作用: 为指定对象定义扩展多个属性</li><li>get ：用来获取当前属性值的回调函数</li><li>set ：修改当前属性值时触发的回调函数，并且实参即为修改后的值</li><li>存取器属性：setter,getter一个用来存值，一个用来取值<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj2 = &#123;</span><br><span class="line">        firstName : <span class="string">'curry'</span>,</span><br><span class="line">        lastName : <span class="string">'stephen'</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">Object</span>.defineProperties(obj2, &#123;</span><br><span class="line">        fullName : &#123;</span><br><span class="line">            <span class="keyword">get</span> : function () &#123;</span><br><span class="line">            <span class="comment">//获取该属性值时，该函数自动调用</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">this</span>.firstName + <span class="string">'-'</span> + <span class="keyword">this</span>.lastName</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="keyword">set</span> : function (data) &#123;<span class="comment">//修改该属性值时，该函数自动调用</span></span><br><span class="line">                <span class="keyword">var</span> names = data.split(<span class="string">'-'</span>);</span><br><span class="line">                <span class="keyword">this</span>.firstName = names[<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">this</span>.lastName = names[<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">console</span>.log(obj2.fullName);</span><br><span class="line">    obj2.firstName = <span class="string">'tim'</span>;</span><br><span class="line">    obj2.lastName = <span class="string">'duncan'</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(obj2.fullName);</span><br><span class="line">    obj2.fullName = <span class="string">'kobe-bryant'</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(obj2.fullName);</span><br></pre></td></tr></table></figure>对象本身的两个方法</li></ul></li></ol><ul><li>get propertyName(){} 用来得到当前属性值的回调函数</li><li>set propertyName(){} 用来监视当前属性值变化的回调函数<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">        firstName : <span class="string">'kobe'</span>,</span><br><span class="line">        lastName : <span class="string">'bryant'</span>,</span><br><span class="line">        <span class="keyword">get</span> fullName()&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.firstName + <span class="string">' '</span> + <span class="keyword">this</span>.lastName</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="keyword">set</span> fullName(data)&#123;</span><br><span class="line">            <span class="keyword">var</span> names = data.split(<span class="string">' '</span>);</span><br><span class="line">            <span class="keyword">this</span>.firstName = names[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">this</span>.lastName = names[<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">console</span>.log(obj.fullName);</span><br><span class="line">    obj.fullName = <span class="string">'curry stephen'</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(obj.fullName);</span><br></pre></td></tr></table></figure></li></ul><h1 id="Array的扩展"><a href="#Array的扩展" class="headerlink" title="Array的扩展"></a>Array的扩展</h1><ol><li>Array.prototype.indexOf(value) : 得到值在数组中的第一个下标</li><li>Array.prototype.lastIndexOf(value) : 得到值在数组中的最后一个下标</li><li>Array.prototype.forEach(function(item, index){}) : 遍历数组</li><li>Array.prototype.map(function(item, index){}) : 遍历数组返回一个新的数组，返回加工之后的值</li><li>Array.prototype.filter(function(item, index){}) : 遍历过滤出一个新的子数组， 返回条件为true的值<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">6</span>];</span><br><span class="line">    <span class="built_in">console</span>.log(arr.indexOf(<span class="number">6</span>));<span class="comment">//2</span></span><br><span class="line">    <span class="comment">//Array.prototype.lastIndexOf(value) : 得到值在数组中的最后一个下标</span></span><br><span class="line">    <span class="built_in">console</span>.log(arr.lastIndexOf(<span class="number">6</span>));<span class="comment">//5</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//Array.prototype.forEach(function(item, index)&#123;&#125;) : 遍历数组</span></span><br><span class="line">    arr.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">item, index</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(item, index);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Array.prototype.map(function(item, index)&#123;&#125;) : 遍历数组返回一个新的数组，返回加工之后的值</span></span><br><span class="line">    <span class="keyword">var</span> arr1 = arr.map(<span class="function"><span class="keyword">function</span> (<span class="params">item, index</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> item + <span class="number">10</span></span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">console</span>.log(arr, arr1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Array.prototype.filter(function(item, index)&#123;&#125;) : 遍历过滤出一个新的子数组， 返回条件为true的值</span></span><br><span class="line">    <span class="keyword">var</span> arr2 = arr.filter(<span class="function"><span class="keyword">function</span> (<span class="params">item, index</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> item &gt; <span class="number">4</span></span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">console</span>.log(arr, arr2);</span><br></pre></td></tr></table></figure></li></ol><h1 id="Function扩展"><a href="#Function扩展" class="headerlink" title="Function扩展"></a>Function扩展</h1><ol><li>Function.prototype.bind(obj) :<ul><li>作用: 将函数内的this绑定为obj, 并将函数返回</li></ul></li><li>面试题: 区别bind()与call()和apply()?<ul><li>都能指定函数中的this</li><li>call()/apply()是立即调用函数</li><li>bind()是将函数返回</li></ul></li><li>需要传入参数时<ul><li>call()直接从第二个参数开始，依次传入</li><li>apply()第二参数必须是数组，传入放在数组里<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun</span>(<span class="params">age</span>) </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>.name = <span class="string">'kobe'</span>;</span><br><span class="line">       <span class="keyword">this</span>.age = age;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line">   fun.bind(obj, <span class="number">12</span>)();<span class="comment">//直接自调用bind返回函数</span></span><br><span class="line">   fun.call(obj,<span class="number">33</span>);</span><br><span class="line">   <span class="built_in">console</span>.log(obj.age);<span class="comment">//输出为33</span></span><br><span class="line">   <span class="comment">//fun.apply(obj,33);//报错</span></span><br><span class="line">   fun.apply(obj,[<span class="number">33</span>]);<span class="comment">//</span></span><br><span class="line">   <span class="built_in">console</span>.log(obj.age);<span class="comment">//输出为33</span></span><br></pre></td></tr></table></figure></li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> ES6 </category>
          
          <category> ES5回顾 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ES6 </tag>
            
            <tag> ES5 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ES6-常用关键字和方法</title>
      <link href="/2020/06/22/ES6-%E5%B8%B8%E7%94%A8%E5%8F%98%E5%8C%96/"/>
      <url>/2020/06/22/ES6-%E5%B8%B8%E7%94%A8%E5%8F%98%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h1 id="let-const关键字"><a href="#let-const关键字" class="headerlink" title="let const关键字"></a>let const关键字</h1><h2 id="let"><a href="#let" class="headerlink" title="let"></a>let</h2><p>作用：与var类似, 用于声明一个变量<br>特点：</p><ul><li>在块作用域内有效</li><li>不能重复声明</li><li>不会预处理, 不存在提升</li></ul><p>应用：</p><ul><li>循环遍历加监听</li><li>使用let取代var是趋势</li></ul><h2 id="const"><a href="#const" class="headerlink" title="const"></a>const</h2><p>作用: 定义一个常量</p><p>特点:</p><ul><li>不能修改</li><li>其它特点同let</li></ul><p>应用: 保存不用改变的数据</p><h1 id="变量的解构赋值"><a href="#变量的解构赋值" class="headerlink" title="变量的解构赋值"></a>变量的解构赋值</h1><p>从对象或数组中提取数据, 并赋值给变量(多个)<br>解构赋值：先解析结构，再赋值内容<br>用途：给多个形参赋值</p><h2 id="对象的解构赋值"><a href="#对象的解构赋值" class="headerlink" title="对象的解构赋值"></a>对象的解构赋值</h2><p>根据对象的属性名来取值</p><blockquote><p>let {n, a} = {n:’tom’, a:12}</p></blockquote><h2 id="数组的解构赋值"><a href="#数组的解构赋值" class="headerlink" title="数组的解构赋值"></a>数组的解构赋值</h2><p>根据数组下标来取值，可以通过添加逗号来顺延所取的内容</p><blockquote><p>let [a,b] = [1, ‘atguigu’];</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;<span class="attr">name</span> : <span class="string">'kobe'</span>, <span class="attr">age</span> : <span class="number">39</span>&#125;;</span><br><span class="line"><span class="comment">//    let name = obj.name;</span></span><br><span class="line"><span class="comment">//    let age = obj.age;</span></span><br><span class="line"><span class="comment">//    console.log(name, age);</span></span><br><span class="line">    <span class="comment">//对象的解构赋值</span></span><br><span class="line">    <span class="keyword">let</span> &#123;age&#125; = obj;</span><br><span class="line">    <span class="built_in">console</span>.log(age);</span><br><span class="line"><span class="comment">//    let &#123;name, age&#125; = &#123;name : 'kobe', age : 39&#125;;</span></span><br><span class="line"><span class="comment">//    console.log(name, age);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//3. 数组的解构赋值  不经常用</span></span><br><span class="line">    <span class="keyword">let</span> arr = [<span class="string">'abc'</span>, <span class="number">23</span>, <span class="literal">true</span>];</span><br><span class="line">    <span class="keyword">let</span> [a, b, c, d] = arr;</span><br><span class="line">    <span class="built_in">console</span>.log(a, b, c, d);</span><br><span class="line">    <span class="comment">//console.log(e);</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">person</span>(<span class="params">p</span>) </span>&#123;<span class="comment">//不用解构赋值</span></span><br><span class="line">        <span class="built_in">console</span>.log(p.name, p.age);</span><br><span class="line">    &#125;</span><br><span class="line">    person(obj);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">person1</span>(<span class="params">&#123;name, age&#125;</span>) </span>&#123;</span><br><span class="line">     <span class="built_in">console</span>.log(name, age);</span><br><span class="line">    &#125;</span><br><span class="line">    person1(obj);</span><br></pre></td></tr></table></figure><h1 id="模板字符串"><a href="#模板字符串" class="headerlink" title="模板字符串"></a>模板字符串</h1><blockquote><p>目的：简化字符串拼接</p></blockquote><ul><li>模板字符串必须用 `` 包含</li><li>变化的部分使用${xxx}定义<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    name : <span class="string">'anverson'</span>,</span><br><span class="line">    age : <span class="number">41</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'我叫:'</span> + obj.name + <span class="string">', 我的年龄是：'</span> + obj.age);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`我叫:<span class="subst">$&#123;obj.name&#125;</span>, 我的年龄是：<span class="subst">$&#123;obj.age&#125;</span>`</span>);</span><br></pre></td></tr></table></figure></li></ul><h1 id="简化的对象写法"><a href="#简化的对象写法" class="headerlink" title="简化的对象写法"></a>简化的对象写法</h1><ul><li>省略同名的属性值</li><li>省略方法的function<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">let</span> x = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">let</span> y = <span class="number">5</span>;</span><br><span class="line">    <span class="comment">//普通额写法</span></span><br><span class="line"><span class="comment">//    let obj = &#123;</span></span><br><span class="line"><span class="comment">//        x : x,</span></span><br><span class="line"><span class="comment">//        y : y,</span></span><br><span class="line"><span class="comment">//        getPoint : function () &#123;</span></span><br><span class="line"><span class="comment">//            return this.x + this.y</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//    &#125;;</span></span><br><span class="line">    <span class="comment">//简化的写法</span></span><br><span class="line">    <span class="keyword">let</span> obj = &#123;</span><br><span class="line">        x,</span><br><span class="line">        y,</span><br><span class="line">        getPoint()&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.x</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">console</span>.log(obj, obj.getPoint());</span><br></pre></td></tr></table></figure><h1 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h1><blockquote><p>多用来定义回调函数</p></blockquote></li></ul><h2 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h2><ul><li>简洁</li><li>箭头函数没有自己的this，箭头函数的this不是调用的时候决定的，而是在定义的时候处在的对象就是它的this</li><li>扩展理解： 箭头函数的this看外层的是否有函数，<br>  如果有，外层函数的this就是内部箭头函数的this，<br>  如果没有，则this是window。<h2 id="语法："><a href="#语法：" class="headerlink" title="语法："></a>语法：</h2></li><li>没有参数: () =&gt; console.log(‘xxxx’)</li><li>一个参数: i =&gt; i+2</li><li>大于一个参数: (i,j) =&gt; i+j</li><li>函数体不用大括号: 默认返回结果</li><li>函数体如果有多个语句, 需要用{}包围，若有需要返回的内容，需要手动返回<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> fun = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">       <span class="built_in">console</span>.log(<span class="string">'fun()'</span>);</span><br><span class="line">   &#125;;</span><br><span class="line">   fun();</span><br><span class="line">   <span class="comment">//形参数量：</span></span><br><span class="line">   <span class="comment">//1 没有形参，并且函数体只有一条语句</span></span><br><span class="line">   <span class="keyword">let</span> fun1 = <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'fun1()'</span>);</span><br><span class="line">    fun1();</span><br><span class="line">   <span class="built_in">console</span>.log(fun1());</span><br><span class="line">    <span class="comment">//2 一个形参，并且函数体只有一条语句</span></span><br><span class="line">    <span class="keyword">let</span> fun2 = <span class="function"><span class="params">x</span> =&gt;</span> x;</span><br><span class="line">    <span class="built_in">console</span>.log(fun2(<span class="number">5</span>));</span><br><span class="line">    <span class="comment">//3 形参是一个以上</span></span><br><span class="line">    <span class="keyword">let</span> fun3 = <span class="function">(<span class="params">x, y</span>) =&gt;</span> x + y;</span><br><span class="line">    <span class="built_in">console</span>.log(fun3(<span class="number">25</span>, <span class="number">39</span>));<span class="comment">//64</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//函数语句数量：</span></span><br><span class="line">    <span class="comment">//1 函数体有多条语句</span></span><br><span class="line">    <span class="keyword">let</span> fun4 = <span class="function">(<span class="params">x, y</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(x, y);</span><br><span class="line">        <span class="keyword">return</span> x + y;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">console</span>.log(fun4(<span class="number">34</span>, <span class="number">48</span>));<span class="comment">//82</span></span><br><span class="line"></span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">    &#125;,<span class="number">1000</span>)</span><br><span class="line"></span><br><span class="line">   <span class="keyword">let</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">'btn'</span>);</span><br><span class="line">   <span class="comment">//2 没有箭头函数</span></span><br><span class="line">   btn.onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">       <span class="built_in">console</span>.log(<span class="keyword">this</span>);<span class="comment">//btn</span></span><br><span class="line">   &#125;;</span><br><span class="line">   <span class="comment">//3 箭头函数</span></span><br><span class="line">   <span class="keyword">let</span> btn2 = <span class="built_in">document</span>.getElementById(<span class="string">'btn2'</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> obj = &#123;</span><br><span class="line">        name : <span class="string">'kobe'</span>,</span><br><span class="line">        age : <span class="number">39</span>,</span><br><span class="line">        getName : <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            btn2.onclick = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="keyword">this</span>);<span class="comment">//obj</span></span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    obj.getName();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">     <span class="keyword">this</span>.obj = &#123;</span><br><span class="line">         showThis : <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">             <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line">    <span class="keyword">let</span> fun5 = <span class="keyword">new</span> Person();</span><br><span class="line">    fun5.obj.showThis();</span><br></pre></td></tr></table></figure></li></ul><h1 id="点点点（…）运算符"><a href="#点点点（…）运算符" class="headerlink" title="点点点（…）运算符"></a>点点点（…）运算符</h1><h2 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h2><ol><li><p>rest(可变)参数</p><ul><li>用来取代arguments</li><li>但比arguments灵活</li><li>只能是最后部分形参参数<blockquote><p>arguments:函数的形参伪数组，内部存放了函数的形参的值</p></blockquote></li></ul></li><li><p>扩展运算符<br> let arr1 = [1,3,5];<br> let arr2 = [2,…arr1,6];<br> arr2.push(…arr1);</p></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun</span>(<span class="params">...values</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">arguments</span>);</span><br><span class="line"><span class="comment">//        arguments.forEach(function (item, index) &#123;</span></span><br><span class="line"><span class="comment">//            console.log(item, index);</span></span><br><span class="line"><span class="comment">//        &#125;);</span></span><br><span class="line">        <span class="built_in">console</span>.log(values);</span><br><span class="line">        values.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">item, index</span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(item, index);</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    fun(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> arr = [<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>];</span><br><span class="line">    <span class="keyword">let</span> arr1 = [<span class="string">'abc'</span>,...arr, <span class="string">'fg'</span>];</span><br><span class="line">    <span class="built_in">console</span>.log(arr1);</span><br></pre></td></tr></table></figure><h1 id="形参默认值"><a href="#形参默认值" class="headerlink" title="形参默认值"></a>形参默认值</h1><blockquote><p>当不传入参数的时候默认使用形参里的默认值</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Point</span>(<span class="params">x = <span class="number">1</span>,y = <span class="number">2</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.x = x;</span><br><span class="line">    <span class="keyword">this</span>.y = y;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="Promise对象"><a href="#Promise对象" class="headerlink" title="Promise对象"></a>Promise对象</h1><ol><li>理解:<ul><li>Promise对象: 代表了未来某个将要发生的事件(通常是一个异步操作)</li><li>有了promise对象, 可以将异步操作以同步的流程表达出来, 避免了层层嵌套的回调函数(俗称’回调地狱’)</li><li>ES6的Promise是一个构造函数, 用来生成promise实例</li></ul></li><li>使用promise基本步骤(2步):<ul><li>创建promise对象</li></ul></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">       <span class="comment">//初始化promise状态为 pending</span></span><br><span class="line">     <span class="comment">//执行异步操作</span></span><br><span class="line">     <span class="keyword">if</span>(异步操作成功) &#123;</span><br><span class="line">       resolve(value);<span class="comment">//修改promise的状态为fullfilled</span></span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       reject(errMsg);<span class="comment">//修改promise的状态为rejected</span></span><br><span class="line">     &#125;</span><br><span class="line">   &#125;)</span><br></pre></td></tr></table></figure><ul><li>调用promise的then()<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">promise.then(<span class="function"><span class="keyword">function</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">result =&gt; console.log(result</span>),</span></span><br><span class="line"><span class="function"><span class="title">errorMsg</span> =&gt; <span class="title">alert</span>(<span class="params">errorMsg</span>)</span></span><br><span class="line"><span class="function">))</span></span><br></pre></td></tr></table></figure></li></ul><ol start="3"><li><p>promise对象的3个状态</p><ul><li>pending: 初始化状态</li><li>fullfilled: 成功状态</li><li>rejected: 失败状态</li></ul></li><li><p>应用:</p><ul><li><p>使用promise实现超时处理</p></li><li><p>使用promise封装处理ajax请求</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> request = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">  request.onreadystatechange = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  &#125;</span><br><span class="line">  request.responseType = <span class="string">'json'</span>;</span><br><span class="line">  request.open(<span class="string">"GET"</span>, url);</span><br><span class="line">  request.send();</span><br></pre></td></tr></table></figure></li></ul></li></ol><h1 id="Symbol"><a href="#Symbol" class="headerlink" title="Symbol"></a>Symbol</h1><h2 id="概念："><a href="#概念：" class="headerlink" title="概念："></a>概念：</h2><p>ES6中的添加了一种原始数据类型symbol(已有的原始数据类型：String, Number, boolean, null, undefined, 对象)</p><h2 id="特点：-1"><a href="#特点：-1" class="headerlink" title="特点："></a>特点：</h2><p>1、Symbol属性对应的值是唯一的，解决命名冲突问题<br>2、Symbol值不能与其他数据进行计算，包括同字符串拼串<br>3、for in, for of遍历时不会遍历symbol属性。</p><h2 id="使用："><a href="#使用：" class="headerlink" title="使用："></a>使用：</h2><p>1、调用Symbol函数得到symbol值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> symbol = <span class="built_in">Symbol</span>();</span><br><span class="line"><span class="keyword">let</span> obj = &#123;&#125;;</span><br><span class="line">obj[symbol] = <span class="string">'hello'</span>;</span><br></pre></td></tr></table></figure><p>2、传参标识</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> symbol = <span class="built_in">Symbol</span>(<span class="string">'one'</span>);</span><br><span class="line"><span class="keyword">let</span> symbol2 = <span class="built_in">Symbol</span>(<span class="string">'two'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(symbol);<span class="comment">// Symbol('one')</span></span><br><span class="line"><span class="built_in">console</span>.log(symbol2);<span class="comment">// Symbol('two')</span></span><br></pre></td></tr></table></figure><p>3、内置Symbol值</p><ul><li>除了定义自己使用的Symbol值以外，ES6还提供了11个内置的Symbol值，指向语言内部使用的方法。</li></ul><ul><li>Symbol.iterator</li></ul><ul><li>对象的Symbol.iterator属性，指向该对象的默认遍历器方法(后边讲)</li></ul><h1 id="Iterator遍历器"><a href="#Iterator遍历器" class="headerlink" title="Iterator遍历器"></a>Iterator遍历器</h1><blockquote><p>iterator是一种接口机制，为各种不同的数据结构提供统一的访问机制</p></blockquote><h2 id="作用："><a href="#作用：" class="headerlink" title="作用："></a>作用：</h2><p>1、为各种数据结构，提供一个统一的、简便的访问接口；<br>2、使得数据结构的成员能够按某种次序排列<br>3、ES6创造了一种新的遍历命令for…of循环，Iterator接口主要供for…of消费。</p><h2 id="工作原理："><a href="#工作原理：" class="headerlink" title="工作原理："></a>工作原理：</h2><p>1、 创建一个指针对象，指向数据结构的起始位置。<br>2、第一次调用next方法，指针自动指向数据结构的第一个成员<br>3、 接下来不断调用next方法，指针会一直往后移动，直到指向最后一个成员<br>4、 每调用next方法返回的是一个包含value和done的对象，{value: 当前成员的值,done: 布尔值}</p><blockquote><p>value表示当前成员的值，done对应的布尔值表示当前的数据的结构是否遍历结束。<br>当遍历结束的时候返回的value值是undefined，done值为true。</p></blockquote><h2 id="原生具备iterator接口的数据-可用for-of遍历"><a href="#原生具备iterator接口的数据-可用for-of遍历" class="headerlink" title="原生具备iterator接口的数据(可用for of遍历)"></a>原生具备iterator接口的数据(可用for of遍历)</h2><p>1、Array<br>2、arguments<br>3、set容器<br>4、map容器<br>5、String</p><h1 id="Generator函数"><a href="#Generator函数" class="headerlink" title="Generator函数"></a>Generator函数</h1><h2 id="概念：-1"><a href="#概念：-1" class="headerlink" title="概念："></a>概念：</h2><p>1、ES6提供的解决异步编程的方案之一<br>2、Generator函数是一个状态机，内部封装了不同状态的数据，<br>3、用来生成遍历器对象<br>4、可暂停函数(惰性求值), yield可暂停，next方法可启动。每次返回的是yield后的表达式结果</p><h2 id="特点：-2"><a href="#特点：-2" class="headerlink" title="特点："></a>特点：</h2><p>1、function 与函数名之间有一个星号<br>2、内部用yield表达式来定义不同的状态<br>3、generator函数返回的是指针对象(接11章节里iterator)，而不会执行函数内部逻辑<br>4、调用next方法函数内部逻辑开始执行，遇到yield表达式停止，返回{value: yield后的表达式结果/undefined, done: false/true}<br>5、再次调用next方法会从上一次停止时的yield处开始，直到最后<br>6、yield语句返回结果通常为undefined， 当调用next方法时传参内容会作为启动时yield语句的返回值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 小试牛刀</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span>* <span class="title">generatorTest</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'函数开始执行'</span>);</span><br><span class="line">      <span class="keyword">yield</span> <span class="string">'hello'</span>;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'函数暂停后再次启动'</span>);</span><br><span class="line">      <span class="keyword">yield</span> <span class="string">'generator'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 生成遍历器对象</span></span><br><span class="line">    <span class="keyword">let</span> Gt = generatorTest();</span><br><span class="line">    <span class="comment">// 执行函数，遇到yield后即暂停</span></span><br><span class="line">    <span class="built_in">console</span>.log(Gt); <span class="comment">// 遍历器对象</span></span><br><span class="line">    <span class="keyword">let</span> result = Gt.next(); <span class="comment">// 函数执行,遇到yield暂停</span></span><br><span class="line">    <span class="built_in">console</span>.log(result); <span class="comment">// &#123;value: "hello", done: false&#125;</span></span><br><span class="line">    result = Gt.next(); <span class="comment">// 函数再次启动</span></span><br><span class="line">    <span class="built_in">console</span>.log(result); <span class="comment">// &#123;value: 'generator', done: false&#125;</span></span><br><span class="line">    result = Gt.next();</span><br><span class="line">    <span class="built_in">console</span>.log(result); <span class="comment">// &#123;value: undefined, done: true&#125;表示函数内部状态已经遍历完毕</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对象的Symbol.iterator属性;</span></span><br><span class="line">    <span class="keyword">let</span> myIterable = &#123;&#125;;</span><br><span class="line">    myIterable[<span class="built_in">Symbol</span>.iterator] = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">      <span class="keyword">yield</span> <span class="number">4</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i <span class="keyword">of</span> myIterable)&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> obj = [...myIterable];</span><br><span class="line">    <span class="built_in">console</span>.log(obj);</span><br></pre></td></tr></table></figure><h1 id="async函数-源自ES2017"><a href="#async函数-源自ES2017" class="headerlink" title="async函数(源自ES2017)"></a>async函数(源自ES2017)</h1><h2 id="概念：-2"><a href="#概念：-2" class="headerlink" title="概念："></a>概念：</h2><p>真正意义上去解决异步回调的问题，同步流程表达异步操作</p><blockquote><p>本质： Generator的语法糖</p></blockquote><h2 id="语法：-1"><a href="#语法：-1" class="headerlink" title="语法："></a>语法：</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">await</span> 异步操作;</span><br><span class="line">    <span class="keyword">await</span> 异步操作；</span><br><span class="line">  &#125;</span><br><span class="line"><span class="string">``</span><span class="string">` </span></span><br><span class="line"><span class="string">## 特点：</span></span><br><span class="line"><span class="string">1、不需要像Generator去调用next方法，遇到await等待，当前的异步操作完成就往下执行</span></span><br><span class="line"><span class="string">2、返回的总是Promise对象，可以用then方法进行下一步操作</span></span><br><span class="line"><span class="string">3、async取代Generator函数的星号，await取代Generator的yield</span></span><br><span class="line"><span class="string">4、语意上更为明确，使用简单，经临床验证，暂时没有任何副作用</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># class(ES6；ES2015)</span></span><br><span class="line"><span class="string">1. 通过class定义类/实现类的继承</span></span><br><span class="line"><span class="string">2. 在类中通过constructor定义构造方法</span></span><br><span class="line"><span class="string">3. 通过new来创建类的实例</span></span><br><span class="line"><span class="string">4. 通过extends来实现类的继承</span></span><br><span class="line"><span class="string">5. 通过super调用父类的构造方法</span></span><br><span class="line"><span class="string">6. 重写从父类中继承的一般方法</span></span><br><span class="line"><span class="string">`</span><span class="string">``</span>js</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">        <span class="comment">//调用类的构造方法</span></span><br><span class="line">        <span class="keyword">constructor</span>(name, age)&#123;</span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">            <span class="keyword">this</span>.age = age;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//定义一般的方法</span></span><br><span class="line">        showName()&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="keyword">this</span>.name, <span class="keyword">this</span>.age);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> person = <span class="keyword">new</span> Person(<span class="string">'kobe'</span>, <span class="number">39</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(person, person.showName());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义一个子类</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">StrPerson</span> <span class="keyword">extends</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">        <span class="keyword">constructor</span>(name, age, salary)&#123;</span><br><span class="line">            <span class="keyword">super</span>(name, age);<span class="comment">//调用父类的构造方法</span></span><br><span class="line">            <span class="keyword">this</span>.salary = salary;</span><br><span class="line">        &#125;</span><br><span class="line">        showName()&#123;<span class="comment">//在子类自身定义方法</span></span><br><span class="line">            <span class="built_in">console</span>.log(<span class="keyword">this</span>.name, <span class="keyword">this</span>.age, <span class="keyword">this</span>.salary);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> str = <span class="keyword">new</span> StrPerson(<span class="string">'weide'</span>, <span class="number">38</span>, <span class="number">1000000000</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(str);</span><br><span class="line">    str.showName();</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ES6 </category>
          
          <category> 常用关键字和方法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ES6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer-03数组中重复的数字</title>
      <link href="/2020/06/14/%E5%89%91%E6%8C%87offer-03%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97/"/>
      <url>/2020/06/14/%E5%89%91%E6%8C%87offer-03%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97/</url>
      
        <content type="html"><![CDATA[<h1 id="3-数组中重复的数字"><a href="#3-数组中重复的数字" class="headerlink" title="3 数组中重复的数字"></a>3 数组中重复的数字</h1><h2 id="基本题目及解法"><a href="#基本题目及解法" class="headerlink" title="基本题目及解法"></a>基本题目及解法</h2><blockquote><p>题目：在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。<br>示例 ：<br>输入：<br>[2, 3, 1, 0, 2, 5, 3]<br>输出：2 或 3<br>限制：<br>2 &lt;= n &lt;= 100000<br>leecode网址：<br><a href="https://leetcode-cn.com/" target="_blank" rel="noopener">https://leetcode-cn.com/</a></p></blockquote><p>1 我最开始想到的解法：循环遍历</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> findRepeatNumber = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;nums.length;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i!=j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i]===nums[j])</span><br><span class="line">                    <span class="keyword">return</span> nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度O(n2),空间复杂度为0(1)<br>结果如下：</p><blockquote><p>执行用时 :7308 ms, 在所有 JavaScript 提交中击败了5.02%的用户<br>内存消耗 :40 MB, 在所有 JavaScript 提交中击败了100.00%的用户</p></blockquote><p>2 优化：先给数组排序，再查找，只需看当前元素和下一个元素是否相等就行</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> findRepeatNumber = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    nums.sort()</span><br><span class="line">    <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;nums.length<span class="number">-1</span>;j++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[j]===nums[j+<span class="number">1</span>])&#123;</span><br><span class="line">            <span class="keyword">return</span> nums[j]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>利用了js数组中的sort( ),该方法是在数组本身上做修改<br>时间复杂度O(n);空间复杂度度O(1)<br>结果：</p><blockquote><p>执行用时 :112 ms, 在所有 JavaScript 提交中击败了34.21%的用户<br>内存消耗 :41.1 MB, 在所有 JavaScript 提交中击败了100.00%的用户</p></blockquote><p>3 我发现没有考虑数据非法的情况，所以赶快补上了</p><blockquote><p>数据非法: 非数组，或者数组长度不足2</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> findRepeatNumber = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums <span class="keyword">instanceof</span> <span class="built_in">Array</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length&gt;=<span class="number">2</span>)&#123;</span><br><span class="line">            nums.sort()</span><br><span class="line">            <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;nums.length<span class="number">-1</span>;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[j]===nums[j+<span class="number">1</span>])&#123;</span><br><span class="line">                    <span class="keyword">return</span> nums[j]</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;     </span><br><span class="line">    &#125; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度O(n);空间复杂度度O(1)<br>结果：</p><blockquote><p>执行用时 :80 ms, 在所有 JavaScript 提交中击败了76.46%的用户<br>内存消耗 :41.4 MB, 在所有 JavaScript 提交中击败了100.00%的用户</p></blockquote><p>4 （原书最优解）重新看了一次题目，发现一个新的提示：数组长度为n，且数字范围在0~n-1<br>可以选择利用数组元素下标和元素值是否对应来判断，如果没有重复的数字，则<br>nums[i]=i<br>代码如下:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> findRepeatNumber = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums <span class="keyword">instanceof</span> <span class="built_in">Array</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]!=i)&#123;</span><br><span class="line">                <span class="comment">//判断nums[i]和nums[nums[i]]是否相等</span></span><br><span class="line">                <span class="keyword">if</span>(nums[i]===nums[nums[i]])&#123;</span><br><span class="line">                    <span class="keyword">return</span> nums[i]</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//判断结束，发现不相等，说明该数字还没排序</span></span><br><span class="line">                <span class="keyword">var</span> num=nums[i]</span><br><span class="line">                nums[i]=nums[num]</span><br><span class="line">                nums[num]=num</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;  </span><br><span class="line">    &#125; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度：O(n)，空间复杂度O(1)<br>优势：不使用自带的sort()排序方法，节省了时间<br>结果：</p><blockquote><p>执行用时 :72 ms, 在所有 JavaScript 提交中击败了94.32%的用户<br>内存消耗 :39.8 MB, 在所有 JavaScript 提交中击败了100.00%的用户</p></blockquote><p>5  可以使用js的set方法</p><blockquote><p>从leecode的题解中找到的，只能说用了新的东西，但是效果不怎么样</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> findRepeatNumber = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> num =<span class="keyword">new</span> <span class="built_in">Set</span>()</span><br><span class="line">    <span class="keyword">if</span>(nums <span class="keyword">instanceof</span> <span class="built_in">Array</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i <span class="keyword">in</span> nums)&#123;</span><br><span class="line">            <span class="keyword">let</span> SetLength=num.size</span><br><span class="line">            num.add(nums[i])</span><br><span class="line">            <span class="keyword">if</span>(SetLength===num.size)&#123;</span><br><span class="line">                <span class="keyword">return</span> nums[i]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度O(n),空间复杂度最大为O(n)，因为毕竟重新添加了一个新的set实例对象<br>结果：</p><blockquote><p>执行用时 :100 ms, 在所有 JavaScript 提交中击败了40.59%的用户<br>内存消耗 :50.2 MB, 在所有 JavaScript 提交中击败了100.00%的用户</p></blockquote><p>6 hash方法：利用一个空数组，设置hash[nums[i]]</p><blockquote><p>使用ES6新特性 for of</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ar findRepeatNumber = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> hash = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> item <span class="keyword">of</span> nums) &#123;</span><br><span class="line">        <span class="keyword">if</span> (item &gt;= <span class="number">0</span> &amp;&amp; item &lt;= nums.length - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (hash[item]) &#123;</span><br><span class="line">                <span class="keyword">return</span> item</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                hash[item] = <span class="literal">true</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度O(n),空间复杂度为(n)<br>结果为：</p><blockquote><p>执行用时 :100 ms, 在所有 JavaScript 提交中击败了40.59%的用户<br>内存消耗 :43.3 MB, 在所有 JavaScript 提交中击败了100.00%的用户</p></blockquote><h2 id="条件增加，不修改输入数组"><a href="#条件增加，不修改输入数组" class="headerlink" title="条件增加，不修改输入数组"></a>条件增加，不修改输入数组</h2><p>以上方法中，不修改原始数组的，有1 ，5 ，6<br>其中好用的有5 6</p>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
          <category> 03-数组中重复的数字 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 剑指offer </tag>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo入门</title>
      <link href="/2020/06/14/hexo%E5%85%A5%E9%97%A8/"/>
      <url>/2020/06/14/hexo%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="HEXO-使用"><a href="#HEXO-使用" class="headerlink" title="HEXO 使用"></a>HEXO 使用</h1><h2 id="网站个性化"><a href="#网站个性化" class="headerlink" title="网站个性化"></a>网站个性化</h2><pre><code>这里产生两个问题 我修改的是本地的 还是github仓库里的</code></pre><h3 id="本地修改"><a href="#本地修改" class="headerlink" title="本地修改"></a>本地修改</h3><pre><code>通过修改pubilc内的index.html修改页面</code></pre><ol><li>hexo g 渲染相关页面</li><li>hexo clean</li><li>hexo deploy提交<h3 id="github修改z"><a href="#github修改z" class="headerlink" title="github修改z"></a>github修改z</h3> 问题：如果我使用github修改了网站样式 那么我再通过hexo提交样式的时候 是否会把我github上修改的样式给替换掉<br> 会 所以直接使用模板 简化操作 </li></ol><h2 id="写文件"><a href="#写文件" class="headerlink" title="写文件"></a>写文件</h2><h3 id="md语法："><a href="#md语法：" class="headerlink" title="md语法："></a>md语法：</h3><h4 id="块级元素"><a href="#块级元素" class="headerlink" title="块级元素"></a>块级元素</h4><ol><li><p>段落和换行</p><ol><li>段落:用空行隔开</li><li>换行:行尾添加两个及以上空格</li></ol></li><li><p>标题</p><ol><li>setext样式：在该行下方使用==表示一级标题 –表示二级标题<br>.</li><li>atx样式：前方使用1-6#号表示1-6级别标题</li></ol></li><li><p>块引用</p><ol><li>使用 email 样式的 &gt; 字符作为块引用 </li><li>使用多个 &gt; 表示多层引用，各层引用间使用&gt;隔开<blockquote><p>一级引用</p><blockquote><p>二级引用</p></blockquote><p>一级引用</p></blockquote></li></ol></li><li><p>列表</p><ol><li><p>有序列表：数字加句号，md文件会自动排序</p><blockquote><p>md文件有序列表数字可以自动排序，只和位置有关</p></blockquote><ol><li>第一项</li><li>第二项</li></ol></li><li><p>无序列表：*  + -三者都可以</p><ul><li>*号</li></ul><ul><li>+号</li></ul><ul><li>-号</li></ul></li><li><p>嵌套：子层列表 要缩进2个空格 或者缩进一个制表符table        </p></li></ol></li><li><p>代码块</p><ol><li><p>使用缩进（相对于上一行非代码块部分）    </p><pre><code>不在列表项中：一层缩进在的话 两层缩进</code></pre></li><li><p>使用三个反引号</p></li></ol></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这是代码块</span><br></pre></td></tr></table></figure><ol start="6"><li>分割线<ol><li>行中只有三个以上的  * * * 或者 — 则会生成分割线</li></ol></li></ol><h4 id="内联元素"><a href="#内联元素" class="headerlink" title="内联元素"></a>内联元素</h4><ol><li>连接<br> 链接格式：<pre><code>[连接名称] (url/&quot;title&quot;)</code></pre><a href="https:/www.baidu.com/" target="_blank" rel="noopener" title="baidu">百度</a></li></ol><ol start="2"><li><p>强调<br> 使用 * 和 -包裹文本</p></li><li><p>图片<br> 语法：</p><pre><code>![Alt text](/path/to/img.jpg)![Alt text](/path/to/img.jpg &quot;Optional title&quot;)</code></pre></li></ol>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
          <category> 基本流程和md语法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo基本使用 </tag>
            
            <tag> md语法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js高级-线程和事件机制</title>
      <link href="/2020/06/13/js%E9%AB%98%E7%BA%A7-%E7%BA%BF%E7%A8%8B%E5%92%8C%E4%BA%8B%E4%BB%B6%E6%9C%BA%E5%88%B6/"/>
      <url>/2020/06/13/js%E9%AB%98%E7%BA%A7-%E7%BA%BF%E7%A8%8B%E5%92%8C%E4%BA%8B%E4%BB%B6%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="线程，事件"><a href="#线程，事件" class="headerlink" title="线程，事件"></a>线程，事件</h1><h2 id="线程和进程"><a href="#线程和进程" class="headerlink" title="线程和进程"></a>线程和进程</h2><ol start="2"><li><ol><li>进程：程序的一次执行, 它占有一片独有的内存空间</li></ol></li><li>线程： CPU的基本调度单位, 是程序执行的一个完整流程</li><li>进程与线程<ul><li>一个进程中一般至少有一个运行的线程: 主线程</li><li>一个进程中也可以同时运行多个线程, 我们会说程序是多线程运行的</li><li>一个进程内的数据可以供其中的多个线程直接共享</li><li>多个进程之间的数据是不能直接共享的</li></ul></li><li>浏览器运行是单进程还是多进程?<ul><li>有的是单进程<ul><li>firefox</li><li>老版IE</li></ul></li><li>有的是多进程<ul><li>chrome</li><li>新版IE</li></ul></li></ul></li><li>如何查看浏览器是否是多进程运行的呢?<ul><li>任务管理器==&gt;进程</li></ul></li><li>浏览器运行是单线程还是多线程?<ul><li>都是多线程运行的<h2 id="浏览器内核"><a href="#浏览器内核" class="headerlink" title="浏览器内核"></a>浏览器内核</h2></li></ul></li><li>什么是浏览器内核?<ul><li>支持浏览器运行的最核心的程序</li></ul></li><li>不同的浏览器可能不太一样<ul><li>Chrome, Safari: webkit</li><li>firefox: Gecko</li><li>IE: Trident</li><li>360,搜狗等国内浏览器: Trident + webkit</li></ul></li><li>内核由很多模块组成<ul><li>html,css文档解析模块 : 负责页面文本的解析</li><li>dom/css模块 : 负责dom/css在内存中的相关处理</li><li>布局和渲染模块 : 负责页面的布局和效果的绘制</li><li>布局和渲染模块 : 负责页面的布局和效果的绘制</li><li>定时器模块 : 负责定时器的管理</li><li>网络请求模块 : 负责服务器请求(常规/Ajax)</li><li>事件响应模块 : 负责事件的管理</li></ul></li></ol><h2 id="js单线程机制"><a href="#js单线程机制" class="headerlink" title="js单线程机制"></a>js单线程机制</h2><ol><li>如何证明js执行是单线程的?<ul><li>setTimeout()的回调函数是在主线程执行的</li><li>定时器回调函数只有在运行栈中的代码全部执行完后才有可能执行</li></ul></li><li>为什么js要用单线程模式, 而不用多线程模式?<ul><li>JavaScript的单线程，与它的用途有关。</li><li>作为浏览器脚本语言，JavaScript的主要用途是与用户互动，以及操作DOM。</li><li>这决定了它只能是单线程，否则会带来很复杂的同步问题</li></ul></li><li>代码的分类:<ul><li>初始化代码</li><li>回调代码</li></ul></li><li>js引擎执行代码的基本流程<ul><li>先执行初始化代码: 包含一些特别的代码   回调函数(异步执行)<ul><li>设置定时器</li><li>绑定事件监听</li><li>发送ajax请求</li></ul></li><li>后面在某个时刻才会执行回调代码</li></ul></li></ol><h2 id="事件循环模型"><a href="#事件循环模型" class="headerlink" title="事件循环模型"></a>事件循环模型</h2><ol><li>所有代码分类<ul><li>初始化执行代码(同步代码): 包含绑定dom事件监听, 设置定时器, 发送ajax请求的代码</li><li>回调执行代码(异步代码): 处理回调逻辑</li></ul></li><li>js引擎执行代码的基本流程:<ul><li>初始化代码===&gt;回调代码</li></ul></li><li>模型的2个重要组成部分:<ul><li>事件(定时器/DOM事件/Ajax)管理模块</li><li>回调队列</li></ul></li><li>模型的运转流程<ul><li>执行初始化代码, 将事件回调函数交给对应模块管理</li><li>当事件发生时, 管理模块会将回调函数及其数据添加到回调列队中</li><li>只有当初始化代码执行完后(可能要一定时间), 才会遍历读取回调队列中的回调函数执行</li></ul></li></ol><h2 id="Web-Workers分线程"><a href="#Web-Workers分线程" class="headerlink" title="Web Workers分线程"></a>Web Workers分线程</h2><ol><li>H5规范提供了js分线程的实现, 取名为: Web Workers</li><li>相关API<ul><li>Worker: 构造函数, 加载分线程执行的js文件</li><li>Worker.prototype.onmessage: 用于接收另一个线程的回调函数</li><li>Worker.prototype.postMessage: 向另一个线程发送消息</li></ul></li><li>不足<ul><li>worker内代码不能操作DOM(更新UI)</li><li>不能跨域加载JS</li><li>不是每个浏览器都支持这个新特性</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> js高级 </category>
          
          <category> 线程_事件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线程 </tag>
            
            <tag> 事件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js高级-对象-继承模式</title>
      <link href="/2020/06/13/js%E9%AB%98%E7%BA%A7-%E5%AF%B9%E8%B1%A1-%E7%BB%A7%E6%89%BF%E6%A8%A1%E5%BC%8F/"/>
      <url>/2020/06/13/js%E9%AB%98%E7%BA%A7-%E5%AF%B9%E8%B1%A1-%E7%BB%A7%E6%89%BF%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="对象的几种继承模式"><a href="#对象的几种继承模式" class="headerlink" title="对象的几种继承模式"></a>对象的几种继承模式</h1><h2 id="原型链继承"><a href="#原型链继承" class="headerlink" title="原型链继承"></a>原型链继承</h2><ul><li>套路<ol><li>定义父类型构造函数</li><li>给父类型的原型添加方法</li><li>定义子类型的构造函数</li><li>创建父类型的对象赋值给子类型的原型</li><li>将子类型原型的构造属性设置为子类型</li><li>给子类型原型添加方法</li><li>创建子类型的对象: 可以调用父类型的方法</li></ol></li><li>关键：子类型的原型为父类型的一个实例对象</li><li>问题：由子类型生成的实例对象的，其constructor属性直接指向的是父元素的原型对象，而不是其子类型的原型对象<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//父类型</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Supper</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.supProp = <span class="string">'Supper property'</span></span><br><span class="line">&#125;</span><br><span class="line">Supper.prototype.showSupperProp = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.supProp)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//子类型</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Sub</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.subProp = <span class="string">'Sub property'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类型的原型为父类型的一个实例对象</span></span><br><span class="line">Sub.prototype = <span class="keyword">new</span> Supper()</span><br><span class="line"><span class="comment">// 让子类型的原型的constructor指向子类型</span></span><br><span class="line">Sub.prototype.constructor = Sub</span><br><span class="line">Sub.prototype.showSubProp = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.subProp)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> sub = <span class="keyword">new</span> Sub()</span><br><span class="line">sub.showSupperProp()</span><br><span class="line"><span class="comment">// sub.toString()</span></span><br><span class="line">sub.showSubProp()</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(sub)  <span class="comment">// Sub</span></span><br></pre></td></tr></table></figure>以上代码在内存中的情况如下：<br><img src="/images/js%E9%AB%98%E7%BA%A7-%E5%AF%B9%E8%B1%A1-%E7%BB%A7%E6%89%BF-%E5%9B%BE%E4%B8%80.png" alt="图一"></li></ul><h2 id="借用构造函数继承（假继承）"><a href="#借用构造函数继承（假继承）" class="headerlink" title="借用构造函数继承（假继承）"></a>借用构造函数继承（假继承）</h2><blockquote><p>只是利用了call函数调用了父类型的构造函数，并不是真正的继承<br>call()方法：使用一个指定的 this 值和单独给出的一个或多个参数来调用一个函数。</p></blockquote><ul><li>套路:<ol><li>定义父类型构造函数</li><li>定义子类型构造函数</li><li>在子类型构造函数中调用父类型构造</li></ol></li><li>关键:<ol><li>在子类型构造函数中通用call()调用父类型构造函数</li></ol></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">    <span class="keyword">this</span>.age = age</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params">name, age, price</span>) </span>&#123;</span><br><span class="line">    Person.call(<span class="keyword">this</span>, name, age)  <span class="comment">// 相当于: this.Person(name, age)</span></span><br><span class="line">    <span class="comment">/*this.name = name</span></span><br><span class="line"><span class="comment">    this.age = age*/</span></span><br><span class="line">    <span class="keyword">this</span>.price = price</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> s = <span class="keyword">new</span> Student(<span class="string">'Tom'</span>, <span class="number">20</span>, <span class="number">14000</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(s.name, s.age, s.price)</span><br></pre></td></tr></table></figure><h2 id="组合继承（原型链加借用构造函数继承）"><a href="#组合继承（原型链加借用构造函数继承）" class="headerlink" title="组合继承（原型链加借用构造函数继承）"></a>组合继承（原型链加借用构造函数继承）</h2><ol><li>利用原型链实现对父类型对象的方法继承</li><li>利用call()借用父类型构建函数初始化相同属性<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">    <span class="keyword">this</span>.age = age</span><br><span class="line">  &#125;</span><br><span class="line">  Person.prototype.setName = <span class="function"><span class="keyword">function</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params">name, age, price</span>) </span>&#123;</span><br><span class="line">    Person.call(<span class="keyword">this</span>, name, age)  <span class="comment">// 为了得到属性</span></span><br><span class="line">    <span class="keyword">this</span>.price = price</span><br><span class="line">  &#125;</span><br><span class="line">  Student.prototype = <span class="keyword">new</span> Person() <span class="comment">// 为了能看到父类型的方法</span></span><br><span class="line">  Student.prototype.constructor = Student <span class="comment">//修正constructor属性</span></span><br><span class="line">  Student.prototype.setPrice = <span class="function"><span class="keyword">function</span> (<span class="params">price</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.price = price</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> s = <span class="keyword">new</span> Student(<span class="string">'Tom'</span>, <span class="number">24</span>, <span class="number">15000</span>)</span><br><span class="line">  s.setName(<span class="string">'Bob'</span>)</span><br><span class="line">  s.setPrice(<span class="number">16000</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(s.name, s.age, s.price)</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> js高级 </category>
          
          <category> 对象 </category>
          
          <category> 继承模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js高级 </tag>
            
            <tag> js对象 </tag>
            
            <tag> 对象继承 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js高级-对象-创建模式</title>
      <link href="/2020/06/13/js%E9%AB%98%E7%BA%A7-%E5%AF%B9%E8%B1%A1-%E5%88%9B%E5%BB%BA%E6%A8%A1%E5%BC%8F/"/>
      <url>/2020/06/13/js%E9%AB%98%E7%BA%A7-%E5%AF%B9%E8%B1%A1-%E5%88%9B%E5%BB%BA%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="js对象的几种创建模式及优缺点"><a href="#js对象的几种创建模式及优缺点" class="headerlink" title="js对象的几种创建模式及优缺点"></a>js对象的几种创建模式及优缺点</h1><h2 id="1-Object构造函数模式"><a href="#1-Object构造函数模式" class="headerlink" title="1 Object构造函数模式"></a>1 Object构造函数模式</h2><ul><li>套路: 先创建空Object对象, 再动态添加属性/方法</li><li>适用场景: 起始时不确定对象内部数据</li><li>问题: 语句太多</li></ul><blockquote><p>代码如下</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 先创建空Object对象</span></span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="built_in">Object</span>()</span><br><span class="line">p = &#123;&#125; <span class="comment">//此时内部数据是不确定的</span></span><br><span class="line"><span class="comment">// 再动态添加属性/方法</span></span><br><span class="line">p.name = <span class="string">'Tom'</span></span><br><span class="line">p.age = <span class="number">12</span></span><br><span class="line">p.setName = <span class="function"><span class="keyword">function</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试</span></span><br><span class="line"><span class="built_in">console</span>.log(p.name, p.age)</span><br><span class="line">p.setName(<span class="string">'Bob'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(p.name, p.age)</span><br></pre></td></tr></table></figure><h2 id="2-对象字面量模式"><a href="#2-对象字面量模式" class="headerlink" title="2_对象字面量模式"></a>2_对象字面量模式</h2><ul><li>套路: 使用{}创建对象, 同时指定属性/方法</li><li>适用场景: 起始时对象内部数据是确定的</li><li>问题: 如果创建多个对象, 有重复代码<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p = &#123;</span><br><span class="line">   name: <span class="string">'Tom'</span>,</span><br><span class="line">   age: <span class="number">12</span>,</span><br><span class="line">   setName: <span class="function"><span class="keyword">function</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">     <span class="keyword">this</span>.name = name</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//测试</span></span><br><span class="line"> <span class="built_in">console</span>.log(p.name, p.age)</span><br><span class="line"> p.setName(<span class="string">'JACK'</span>)</span><br><span class="line"> <span class="built_in">console</span>.log(p.name, p.age)</span><br><span class="line"></span><br><span class="line"> <span class="keyword">var</span> p2 = &#123;  <span class="comment">//如果创建多个对象代码很重复</span></span><br><span class="line">   name: <span class="string">'Bob'</span>,</span><br><span class="line">   age: <span class="number">13</span>,</span><br><span class="line">   setName: <span class="function"><span class="keyword">function</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">     <span class="keyword">this</span>.name = name</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2></li><li>套路: 通过工厂函数动态创建对象并返回</li><li>适用场景: 需要创建多个对象</li><li>问题: 对象没有一个具体的类型, 都是Object类型</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createPerson</span>(<span class="params">name, age</span>) </span>&#123; <span class="comment">//返回一个对象的函数===&gt;工厂函数</span></span><br><span class="line">   <span class="keyword">var</span> obj = &#123;</span><br><span class="line">     name: name,</span><br><span class="line">     age: age,</span><br><span class="line">     setName: <span class="function"><span class="keyword">function</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>.name = name</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> obj</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 创建2个人</span></span><br><span class="line"> <span class="keyword">var</span> p1 = createPerson(<span class="string">'Tom'</span>, <span class="number">12</span>)</span><br><span class="line"> <span class="keyword">var</span> p2 = createPerson(<span class="string">'Bob'</span>, <span class="number">13</span>)</span><br><span class="line"></span><br><span class="line"> <span class="comment">// p1/p2是Object类型</span></span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">createStudent</span>(<span class="params">name, price</span>) </span>&#123;</span><br><span class="line">   <span class="keyword">var</span> obj = &#123;</span><br><span class="line">     name: name,</span><br><span class="line">     price: price</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> obj</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">var</span> s = createStudent(<span class="string">'张三'</span>, <span class="number">12000</span>)</span><br><span class="line"> <span class="comment">// s也是Object</span></span><br></pre></td></tr></table></figure><p>很明显，无法区分学生张三和非学生p1，p2</p><h2 id="自定义构造函数"><a href="#自定义构造函数" class="headerlink" title="自定义构造函数"></a>自定义构造函数</h2><ul><li>套路: 自定义构造函数, 通过new创建对象</li><li>适用场景: 需要创建多个类型确定的对象</li><li>问题: 每个对象都有相同的数据, 浪费内存<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义类型</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name</span><br><span class="line">  <span class="keyword">this</span>.age = age</span><br><span class="line">  <span class="keyword">this</span>.setName = <span class="function"><span class="keyword">function</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> Person(<span class="string">'Tom'</span>, <span class="number">12</span>)</span><br><span class="line">p1.setName(<span class="string">'Jack'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(p1.name, p1.age)</span><br><span class="line"><span class="built_in">console</span>.log(p1 <span class="keyword">instanceof</span> Person)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student</span> (<span class="params">name, price</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name</span><br><span class="line">  <span class="keyword">this</span>.price = price</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> s = <span class="keyword">new</span> Student(<span class="string">'Bob'</span>, <span class="number">13000</span>)</span><br><span class="line"><span class="built_in">console</span>.log(s <span class="keyword">instanceof</span> Student)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> Person(<span class="string">'JACK'</span>, <span class="number">23</span>)</span><br><span class="line"><span class="built_in">console</span>.log(p1, p2)</span><br></pre></td></tr></table></figure>所谓的浪费内存是指，每个对象内部都会有同样的区域，去存放同样的方法</li></ul><h2 id="构造函数-原型的组合模式"><a href="#构造函数-原型的组合模式" class="headerlink" title="构造函数+原型的组合模式"></a>构造函数+原型的组合模式</h2><ul><li>套路: 自定义构造函数, 属性在函数中初始化, 方法添加到原型上</li><li>适用场景: 需要创建多个类型确定的对象<blockquote><p>最常用的一种,解决了以上的问题</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age</span>) </span>&#123; <span class="comment">//在构造函数中只初始化一般函数</span></span><br><span class="line">  <span class="keyword">this</span>.name = name</span><br><span class="line">  <span class="keyword">this</span>.age = age</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.setName = <span class="function"><span class="keyword">function</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> Person(<span class="string">'Tom'</span>, <span class="number">23</span>)</span><br><span class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> Person(<span class="string">'Jack'</span>, <span class="number">24</span>)</span><br><span class="line"><span class="built_in">console</span>.log(p1, p2)</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> js高级 </category>
          
          <category> 对象 </category>
          
          <category> 创建 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js对象 </tag>
            
            <tag> 对象创建 </tag>
            
            <tag> 创建模式比较 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js高级-面试题-闭包</title>
      <link href="/2020/06/12/js%E9%AB%98%E7%BA%A7-%E9%9D%A2%E8%AF%95%E9%A2%98-%E9%97%AD%E5%8C%85/"/>
      <url>/2020/06/12/js%E9%AB%98%E7%BA%A7-%E9%9D%A2%E8%AF%95%E9%A2%98-%E9%97%AD%E5%8C%85/</url>
      
        <content type="html"><![CDATA[<h1 id="闭包面试"><a href="#闭包面试" class="headerlink" title="闭包面试"></a>闭包面试</h1><h2 id="第一题"><a href="#第一题" class="headerlink" title="第一题"></a>第一题</h2><blockquote><p>输出是什么</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">"The Window"</span>;</span><br><span class="line">  <span class="keyword">var</span> object = &#123;</span><br><span class="line">    name : <span class="string">"My Object"</span>,</span><br><span class="line">    getNameFunc : <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  alert(object.getNameFunc()());  <span class="comment">//?  the window</span></span><br></pre></td></tr></table></figure><p>片段一是作用域的问题</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码片段二</span></span><br><span class="line"><span class="keyword">var</span> name2 = <span class="string">"The Window"</span>;</span><br><span class="line"><span class="keyword">var</span> object2 = &#123;</span><br><span class="line">  name2 : <span class="string">"My Object"</span>,</span><br><span class="line">  getNameFunc : <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> that = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> that.name2;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">alert(object2.getNameFunc()()); <span class="comment">//?  my object</span></span><br></pre></td></tr></table></figure><p>片段二，由于返回函数使用了外层函数的变量that，<br>在其内部产生了闭包，闭包内that属性指向了object2<br>故输出为object2内部的name2属性</p><h2 id="面试题2"><a href="#面试题2" class="headerlink" title="面试题2"></a>面试题2</h2><p>代码如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun</span>(<span class="params">n,o</span>) </span>&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(o)</span><br><span class="line">   <span class="keyword">return</span> &#123;</span><br><span class="line">     fun:<span class="function"><span class="keyword">function</span>(<span class="params">m</span>)</span>&#123;</span><br><span class="line">       <span class="keyword">return</span> fun(m,n)</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">var</span> a = fun(<span class="number">0</span>)</span><br><span class="line"> a.fun(<span class="number">1</span>)</span><br><span class="line"> a.fun(<span class="number">2</span>)</span><br><span class="line"> a.fun(<span class="number">3</span>)<span class="comment">//undefined,0,0,0</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">var</span> b = fun(<span class="number">0</span>).fun(<span class="number">1</span>).fun(<span class="number">2</span>).fun(<span class="number">3</span>)<span class="comment">//undefined,0,1,2</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">var</span> c = fun(<span class="number">0</span>).fun(<span class="number">1</span>)<span class="comment">//undefine 0</span></span><br><span class="line"> c.fun(<span class="number">2</span>)<span class="comment">//1</span></span><br><span class="line"> c.fun(<span class="number">3</span>)<span class="comment">//1</span></span><br></pre></td></tr></table></figure><p>总结来说，每一次调用fun函数，都会更新返回函数的闭包内的属性n</p>]]></content>
      
      
      <categories>
          
          <category> js高级 </category>
          
          <category> 面试题 </category>
          
          <category> 闭包 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js高级 </tag>
            
            <tag> 闭包 </tag>
            
            <tag> 面试题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js高级-函数-闭包</title>
      <link href="/2020/06/12/js%E9%AB%98%E7%BA%A7-%E5%87%BD%E6%95%B0-%E9%97%AD%E5%8C%85/"/>
      <url>/2020/06/12/js%E9%AB%98%E7%BA%A7-%E5%87%BD%E6%95%B0-%E9%97%AD%E5%8C%85/</url>
      
        <content type="html"><![CDATA[<h1 id="理解闭包"><a href="#理解闭包" class="headerlink" title="理解闭包"></a>理解闭包</h1><h2 id="如何产生闭包"><a href="#如何产生闭包" class="headerlink" title="如何产生闭包"></a>如何产生闭包</h2><ul><li>函数嵌套</li><li>内部函数引用了外部函数的数据(变量/函数)<blockquote><p>二者缺一不可</p></blockquote></li></ul><h2 id="闭包到底是什么"><a href="#闭包到底是什么" class="headerlink" title="闭包到底是什么"></a>闭包到底是什么</h2><blockquote><p>使用chrome调试查看<br>注意: 闭包存在于嵌套的内部函数中</p></blockquote><p>理解一: 闭包是嵌套的内部函数(绝大部分人)</p><p>理解二: 包含被引用变量(函数)的对象(极少数人)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn1</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">2</span></span><br><span class="line"><span class="keyword">var</span> b = <span class="string">'abc'</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn2</span> (<span class="params"></span>) </span>&#123; <span class="comment">//执行函数定义就会产生闭包(不用调用内部函数)</span></span><br><span class="line">  <span class="built_in">console</span>.log(a)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// fn2()</span></span><br><span class="line">&#125;</span><br><span class="line">fn1()</span><br></pre></td></tr></table></figure><p>就以上述代码而言，只有当fn1执行时，才会在fn2内部产生闭包，一个包含着引用对象（或者函数）的对象</p><h2 id="闭包作用"><a href="#闭包作用" class="headerlink" title="闭包作用"></a>闭包作用</h2><ul><li>使用函数内部的变量在函数执行完后, 仍然存活在内存中(延长了局部变量的生命周期)</li><li>让函数外部可以操作(读写)到函数内部的数据(变量/函数)</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">2</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  a++</span><br><span class="line">  <span class="built_in">console</span>.log(a)</span><br><span class="line">  <span class="comment">// return a</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> fn2</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> f = fn1()</span><br><span class="line">f() <span class="comment">// 3</span></span><br><span class="line">f() <span class="comment">// 4</span></span><br></pre></td></tr></table></figure><p>问题:<br>函数执行完后, 函数内部声明的局部变量是否还存在?  </p><blockquote><p>一般是不存在, 存在于闭中的变量才可能存在</p></blockquote><p>在函数外部能直接访问函数内部的局部变量吗?</p><blockquote><p>不能, 但我们可以通过闭包让外部操作它</p></blockquote><h2 id="闭包的生命周期"><a href="#闭包的生命周期" class="headerlink" title="闭包的生命周期"></a>闭包的生命周期</h2><blockquote><p>产生: 在嵌套内部函数定义执行完时就产生了(不是在调用)<br>死亡: 在嵌套的内部函数成为垃圾对象时</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//此时闭包就已经产生了(函数提升, 内部函数对象已经创建了)</span></span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">2</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">fn2</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      a++</span><br><span class="line">      <span class="built_in">console</span>.log(a)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fn2</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> f = fn1()</span><br><span class="line">  f() <span class="comment">// 3</span></span><br><span class="line">  f() <span class="comment">// 4</span></span><br><span class="line">  f = <span class="literal">null</span> <span class="comment">//闭包死亡(包含闭包的函数对象成为垃圾对象)</span></span><br></pre></td></tr></table></figure><h2 id="闭包应用"><a href="#闭包应用" class="headerlink" title="闭包应用"></a>闭包应用</h2><p>定义JS模块</p><ul><li>具有特定功能的js文件</li><li>将所有的数据和功能都封装在一个函数内部(私有的)</li><li>只向外暴露一个包信n个方法的对象或函数</li><li>模块的使用者, 只需要通过模块暴露的对象调用方法来实现对应的功能  </li></ul><p>js文件内容：</p><blockquote><p>一般情况</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myModule</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">//私有数据</span></span><br><span class="line">  <span class="keyword">var</span> msg = <span class="string">'My atguigu'</span></span><br><span class="line">  <span class="comment">//操作数据的函数</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'doSomething() '</span>+msg.toUpperCase())</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">doOtherthing</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'doOtherthing() '</span>+msg.toLowerCase())</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//向外暴露对象(给外部使用的方法)</span></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    doSomething: doSomething,</span><br><span class="line">    doOtherthing: doOtherthing</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用时，需要先生成一个函数对象，才能调用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="built_in">module</span> = myModule()</span><br><span class="line"> <span class="built_in">module</span>.doSomething()</span><br><span class="line"> <span class="built_in">module</span>.doOtherthing()</span><br></pre></td></tr></table></figure><blockquote><p>匿名函数自调用</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">//私有数据</span></span><br><span class="line">  <span class="keyword">var</span> msg = <span class="string">'My atguigu'</span></span><br><span class="line">  <span class="comment">//操作数据的函数</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'doSomething() '</span>+msg.toUpperCase())</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">doOtherthing</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'doOtherthing() '</span>+msg.toLowerCase())</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//向外暴露对象(给外部使用的方法)</span></span><br><span class="line">  <span class="built_in">window</span>.myModule2 = &#123;</span><br><span class="line">    doSomething: doSomething,</span><br><span class="line">    doOtherthing: doOtherthing</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure><p>该方式可以直接调用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">myModule2.doSomething()</span><br><span class="line">myModule2.doOtherthing()</span><br></pre></td></tr></table></figure><p>后者容易压缩，工作时会常用</p><h2 id="缺点及解决方法"><a href="#缺点及解决方法" class="headerlink" title="缺点及解决方法"></a>缺点及解决方法</h2><p>缺点</p><ul><li>函数执行完后, 函数内的局部变量没有释放, 占用内存时间会变长</li><li>容易造成内存泄露<br>解决</li><li>能不用闭包就不用</li><li>及时释放</li></ul>]]></content>
      
      
      <categories>
          
          <category> js高级 </category>
          
          <category> 函数 </category>
          
          <category> 闭包 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 闭包 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js高级-面试题-作用域_作用域链</title>
      <link href="/2020/06/12/js%E9%AB%98%E7%BA%A7-%E9%9D%A2%E8%AF%95%E9%A2%98-%E4%BD%9C%E7%94%A8%E5%9F%9F-%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE/"/>
      <url>/2020/06/12/js%E9%AB%98%E7%BA%A7-%E9%9D%A2%E8%AF%95%E9%A2%98-%E4%BD%9C%E7%94%A8%E5%9F%9F-%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE/</url>
      
        <content type="html"><![CDATA[<h1 id="作用域面试题"><a href="#作用域面试题" class="headerlink" title="作用域面试题"></a>作用域面试题</h1><h2 id="第一题-输出什么"><a href="#第一题-输出什么" class="headerlink" title="第一题 输出什么"></a>第一题 输出什么</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">show</span>(<span class="params">f</span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> x = <span class="number">20</span>;</span><br><span class="line">f();</span><br><span class="line">&#125;</span><br><span class="line">show(fn);<span class="comment">//10</span></span><br></pre></td></tr></table></figure><p>js中的作用域是静态作用域，在代码执行前就已经划分好了<br>当执行show（fn）时，fn内部没有定义x，故fn向外层，对于上述函数，就是全局作用域中找，故输出为：10</p><h2 id="第二题"><a href="#第二题" class="headerlink" title="第二题"></a>第二题</h2><blockquote><p>输出什么</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fn = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(fn)</span><br><span class="line">&#125;</span><br><span class="line">fn()</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">fn2: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="built_in">console</span>.log(fn2)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.fn2()</span><br></pre></td></tr></table></figure><p>显然<br>fn（）会输出自身<br>而obj.fn（2） 则会报错，因为其输出的变量fn2在obj中，而全局作用域中也只有obj，没有fn2</p><blockquote><p>要想输出fn2，怎么办呢</p></blockquote><p>很简单，只需要把输出语句<br>     console.log(fn2)<br>改为<br>      console.log(this.fn2)<br>利用this指向引用对象本身，则该函数就会从引用对象中找匹配的变量</p>]]></content>
      
      
      <categories>
          
          <category> js高级 </category>
          
          <category> 面试题 </category>
          
          <category> 作用域 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 作用域 </tag>
            
            <tag> 面试题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js高级-函数-作用域_作用域链</title>
      <link href="/2020/06/11/js%E9%AB%98%E7%BA%A7-%E5%87%BD%E6%95%B0-%E4%BD%9C%E7%94%A8%E5%9F%9F-%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE/"/>
      <url>/2020/06/11/js%E9%AB%98%E7%BA%A7-%E5%87%BD%E6%95%B0-%E4%BD%9C%E7%94%A8%E5%9F%9F-%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE/</url>
      
        <content type="html"><![CDATA[<h1 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h1><h2 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h2><ul><li>就是一块”地盘”, 一个代码段所在的区域</li><li>它是静态的(相对于上下文对象), 在编写代码时就确定<h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2></li><li>全局作用域</li><li>函数作用域</li><li>块级作用域（ES6）<h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2></li><li>隔离变量，不同作用域下同名变量不会有冲突</li></ul><h1 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h1><h2 id="理解-1"><a href="#理解-1" class="headerlink" title="理解"></a>理解</h2><ul><li>多个上下级关系的作用域形成的链, 它的方向是从下向上的(从内到外)</li><li>查找变量时就是沿着作用域链来查找的<h2 id="查找一个变量的查找规则"><a href="#查找一个变量的查找规则" class="headerlink" title="查找一个变量的查找规则"></a>查找一个变量的查找规则</h2></li><li>在当前作用域下的执行上下文中查找对应的属性, 如果有直接返回, 否则进入2</li><li>在上一级作用域的执行上下文中查找对应的属性, 如果有直接返回, 否则进入3</li><li>再次执行2的相同操作, 直到全局作用域, 如果还找不到就抛出找不到的异常</li></ul><h1 id="块级作用域"><a href="#块级作用域" class="headerlink" title="块级作用域"></a>块级作用域</h1><blockquote><p>ES6之前js没有块级作用域，它使用var声明变量，以function来划分作用域，大括号“{}” 却限定不了var的作用域,用var声明的变量具有变量提升（declaration hoisting）的效果。</p></blockquote><p>  ES6新增加了一个let，可以在{}， if， for里声明。用法同var，但作用域限定在块级，let声明的变量不存在变量提升。<br>  ES6规定，如果代码块中存在let，这个区块从一开始就形成了封闭作用域,凡是在声明之前就使用，就会报错。即在代码块内，在let声明之前使用变量都是不可用的。<br>例1: 块级作用域 if</p><p>function test(flag) {<br>    if (flag) {<br>        var a = ‘js’<br>    }<br>    // 这里也可以访问 a<br>}<br>变量a在if块里声明的，但在else块和if外都可以访问到val,把var换成let后：</p><pre><code>function test(flag) {    if (flag) {        let a = &apos;js&apos;    }     // 这里也访问不到 a}</code></pre><p>例２块级作用域 for</p><pre><code>for(var i=0; i&lt;2; i++){    console.log(&apos;outer i: &apos; + i);    for(var i=0; i&lt;2; i++){    console.log(&apos;inner i: &apos;+i);    }}</code></pre><p>执行结果如下：</p><pre><code>outer i: 0test.html:12 inner i: 0test.html:12 inner i: 1</code></pre><p>可以看到，外层循环被打断了，因为ｉ为全局变量所以 i 的值被内层循环修改了，把内层循环的var换成let后：</p><pre><code>for(var i=0; i&lt;2; i++){    console.log(&apos;outer i: &apos; + i);    for(let i=0; i&lt;2; i++){    console.log(&apos;inner i: &apos;+i);    }}</code></pre><p>执行结果如下：</p><pre><code>outer i: 0test.html:12 inner i: 0test.html:12 inner i: 1test.html:10 outer i: 1test.html:12 inner i: 0test.html:12 inner i: 1</code></pre><p>示例3: 变量提升</p><p>先使用后声明</p><pre><code>console.log(a) // undefinedvar a;</code></pre><p>变量val先使用后声明，输出undefined，也不报错。把var换成let，就报错了</p><pre><code>console.log(a) // Uncaught ReferenceError: a is not definedvar a;</code></pre><p>先判断后声明</p><pre><code>if (typeof a == &apos;undefined&apos;) {    // ...}var a = &apos;&apos;</code></pre><p>把var换成let，if处报语法错 Uncaught ReferenceError: a is not defined</p><pre><code>if (typeof a == &apos;undefined&apos;) {    // ...}var a = &apos;&apos;</code></pre>]]></content>
      
      
      <categories>
          
          <category> js高级 </category>
          
          <category> 函数 </category>
          
          <category> 作用域和作用域链 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 作用域 </tag>
            
            <tag> 作用域链 </tag>
            
            <tag> 块级作用域 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js高级-面试题-上下文与上下文栈</title>
      <link href="/2020/06/11/js%E9%AB%98%E7%BA%A7-%E9%9D%A2%E8%AF%95%E9%A2%98-%E4%B8%8A%E4%B8%8B%E6%96%87%E4%B8%8E%E4%B8%8A%E4%B8%8B%E6%96%87%E6%A0%88/"/>
      <url>/2020/06/11/js%E9%AB%98%E7%BA%A7-%E9%9D%A2%E8%AF%95%E9%A2%98-%E4%B8%8A%E4%B8%8B%E6%96%87%E4%B8%8E%E4%B8%8A%E4%B8%8B%E6%96%87%E6%A0%88/</url>
      
        <content type="html"><![CDATA[<h1 id="上下文栈典型面试题"><a href="#上下文栈典型面试题" class="headerlink" title="上下文栈典型面试题"></a>上下文栈典型面试题</h1><blockquote><p>凡是出现和上下文有关的面试题，第一步永远先改写代码，反映出其真正的处理过程，再进行判断</p></blockquote><h2 id="1-代码执行时控制台输出什么？整个过程产生了几个执行上下文？"><a href="#1-代码执行时控制台输出什么？整个过程产生了几个执行上下文？" class="headerlink" title="1 代码执行时控制台输出什么？整个过程产生了几个执行上下文？"></a>1 代码执行时控制台输出什么？整个过程产生了几个执行上下文？</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'gb: '</span>+ i)</span><br><span class="line"><span class="keyword">var</span> i = <span class="number">1</span></span><br><span class="line">foo(<span class="number">1</span>)</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">i</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (i == <span class="number">4</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'fb:'</span> + i)</span><br><span class="line">  foo(i + <span class="number">1</span>) <span class="comment">//递归调用: 在函数内部调用自己</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'fe:'</span> + i)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'ge: '</span> + i)</span><br></pre></td></tr></table></figure><p>先改写代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">i</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (i == <span class="number">4</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'fb:'</span> + i)</span><br><span class="line">  foo(i + <span class="number">1</span>) <span class="comment">//递归调用: 在函数内部调用自己</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'fe:'</span> + i)</span><br><span class="line">&#125;</span><br><span class="line">i = <span class="number">1</span></span><br><span class="line">foo(<span class="number">1</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'ge: '</span> + i)</span><br></pre></td></tr></table></figure><p>首先来回答第一个问题：代码输出什么？<br>第一个控制台输出语句，考察的是变量提升，那么输出define<br>接下来就是函数模块很明显，这是一个简单的递归函数问题，i&lt;3时，foo函数会先输出fb，再调用自身，调用结束后，才会输出fe，<br>故针对于函数模块来说，输出如下：<br><img src="/images/js%E9%AB%98%E7%BA%A7_%E9%9D%A2%E8%AF%95_%E4%B8%8A%E4%B8%8B%E6%96%87_1_1.png" alt="函数部分结果"><br>最后一个输出语句考察的就是引用变量赋值问题，由于函数内部数据随着函数上下文的清除而清楚，最终输出的还是其外部定义的值，即：1<br>最终结果如下<br><img src="/images/js%E9%AB%98%E7%BA%A7_%E9%9D%A2%E8%AF%95_%E4%B8%8A%E4%B8%8B%E6%96%87_1_2.png" alt="函数部分结果"></p><h2 id="2-先执行变量提升，再执行函数"><a href="#2-先执行变量提升，再执行函数" class="headerlink" title="2 先执行变量提升，再执行函数"></a>2 先执行变量提升，再执行函数</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> a</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> a) <span class="comment">// 'function'</span></span><br></pre></td></tr></table></figure><p>以上代码根据js语法，改写为：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> a) <span class="comment">// 'function'</span></span><br></pre></td></tr></table></figure><blockquote><p>第二句把第一句的a的数据类型给覆盖了，输出：function<br>题目简单，只是别突然忘记了就行</p></blockquote><h2 id="3"><a href="#3" class="headerlink" title="3"></a>3</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!(b <span class="keyword">in</span> <span class="built_in">window</span>)) &#123;</span><br><span class="line">    <span class="keyword">var</span> b = <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(b) <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>以上代码改写为：<br>    var b<br>    if (!(b in window)) {<br>    b = 1<br>    }<br>    console.log(b) // undefined</p><blockquote><p>因为if语句只做判断，并非函数模块，内部不会产生新的上下文<br>所以结果很明显，就是undefined</p></blockquote><h2 id="4"><a href="#4" class="headerlink" title="4"></a>4</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> c = <span class="number">1</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">c</span>(<span class="params">c</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(c)</span><br><span class="line">  <span class="keyword">var</span> c = <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line">c(<span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>上边的代码，一开始看起来很懵，这啥啊？<br>但是，别急，先改写</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> c = <span class="number">1</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">c</span>(<span class="params">c</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> c</span><br><span class="line">  <span class="built_in">console</span>.log(c)</span><br><span class="line">  c = <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line">c = <span class="number">1</span></span><br><span class="line">c(<span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>改写过后，结果显而易见的，浏览器直接报错，c根本就不是一个函数嘛</p><h2 id="总结：所有涉及到上下文的面试题，第一步永远先改写代码"><a href="#总结：所有涉及到上下文的面试题，第一步永远先改写代码" class="headerlink" title="总结：所有涉及到上下文的面试题，第一步永远先改写代码"></a>总结：所有涉及到上下文的面试题，第一步永远先改写代码</h2>]]></content>
      
      
      <categories>
          
          <category> js高级 </category>
          
          <category> 面试题 </category>
          
          <category> 上下文栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js面试 </tag>
            
            <tag> 上下文面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js高级-执行上下文与执行上下文栈</title>
      <link href="/2020/06/10/js%E9%AB%98%E7%BA%A7-%E5%87%BD%E6%95%B0-%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E4%B8%8E%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E6%A0%88/"/>
      <url>/2020/06/10/js%E9%AB%98%E7%BA%A7-%E5%87%BD%E6%95%B0-%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E4%B8%8E%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E6%A0%88/</url>
      
        <content type="html"><![CDATA[<h1 id="执行上下文，上下文栈"><a href="#执行上下文，上下文栈" class="headerlink" title="执行上下文，上下文栈"></a>执行上下文，上下文栈</h1><h2 id="变量，函数提升"><a href="#变量，函数提升" class="headerlink" title="变量，函数提升"></a>变量，函数提升</h2><blockquote><p>说白了就是写代码的时候先引用后声明<br>对于同名的情况 先执行变量提升，再执行函数提升</p></blockquote><p>变量声明提升</p><ul><li><p>通过var定义(声明)的变量, 在定义语句之前就可以访问到</p></li><li><p>值: undefined</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">3</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(a)</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">4</span></span><br><span class="line">&#125;</span><br><span class="line">fn()       <span class="comment">//输出 undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(b) <span class="comment">//undefined  变量提升</span></span><br><span class="line"><span class="keyword">var</span> b = <span class="number">3</span></span><br></pre></td></tr></table></figure></li></ul><p>函数声明提升</p><ul><li><p>通过function声明的函数, 在之前就可以直接调用</p></li><li><p>值: 函数定义(对象)</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">    fn2() <span class="comment">//可调用  函数提升</span></span><br><span class="line">    <span class="comment">// fn3() //不能  变量提升</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">fn2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'fn2()'</span>)</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> fn3 = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'fn3()'</span>)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="执行上下文"><a href="#执行上下文" class="headerlink" title="执行上下文"></a>执行上下文</h2><blockquote><p>执行代码时才产生上下文</p></blockquote></li></ul><p>全局执行上下文</p><ul><li>在执行全局代码前将window确定为全局执行上下文</li><li>对全局数据进行预处理<ul><li>var定义的全局变量==&gt;undefined, 添加为window的属性</li><li>function声明的全局函数==&gt;赋值(fun), 添加为window的方法</li><li>this==&gt;赋值(window)</li></ul></li><li>开始执行全局代码<br>函数（局部）执行上下文</li><li>在调用函数, 准备执行函数体之前, 创建对应的函数执行上下文对象(虚拟的, 存在于栈中)</li><li>对局部数据进行预处理<ul><li>形参变量==&gt;赋值(实参)==&gt;添加为执行上下文的属性</li><li>arguments==&gt;赋值(实参列表), 添加为执行上下文的属性  </li><li>var定义的局部变量==&gt;undefined, 添加为执行上下文的属性 </li><li>function声明的函数 ==&gt;赋值(fun), 添加为执行上下文的方法</li><li>this==&gt;赋值(调用函数的对象)</li></ul></li><li>开始执行函数体代码</li></ul><h2 id="执行上下文栈"><a href="#执行上下文栈" class="headerlink" title="执行上下文栈"></a>执行上下文栈</h2><blockquote><p>首先看看以下代码：<br>会产生多少个上下文对象？</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> bar = <span class="function"><span class="keyword">function</span> (<span class="params">x</span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> b = <span class="number">5</span></span><br><span class="line">foo(x + b)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span> (<span class="params">y</span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> c = <span class="number">5</span></span><br><span class="line"><span class="built_in">console</span>.log(c + y)</span><br><span class="line">&#125;</span><br><span class="line">bar(<span class="number">10</span>)</span><br><span class="line">bar(<span class="number">10</span>)</span><br></pre></td></tr></table></figure><p>3个？5个？6个？都有可能啊，别急，我们先来看看js存储上下文的机制：</p><ol><li><p>在全局代码执行前, JS引擎就会创建一个栈来存储管理所有的执行上下文对象</p></li><li><p>在全局执行上下文(window)确定后, 将其添加到栈中(压栈)</p></li><li><p>在函数执行上下文创建后, 将其添加到栈中(压栈)</p></li><li><p>在当前函数执行完后,将栈顶的对象移除(出栈)</p></li><li><p>当所有的代码执行完后, 栈中只剩下window</p><p><em>函数执行结束后，其对应的上下文对象就立刻从上下文栈中释放</em><br><img src="/images/js%E9%AB%98%E7%BA%A7-%E4%B8%8A%E4%B8%8B%E6%96%87%E6%A0%88.png" alt="上下文栈"></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> js高级 </category>
          
          <category> js函数 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 执行上下文 </tag>
            
            <tag> 执行上下文栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js高级-面试题-原型_原型链</title>
      <link href="/2020/06/10/js%E9%AB%98%E7%BA%A7-%E9%9D%A2%E8%AF%95%E9%A2%98-%E5%8E%9F%E5%9E%8B%E9%93%BE/"/>
      <url>/2020/06/10/js%E9%AB%98%E7%BA%A7-%E9%9D%A2%E8%AF%95%E9%A2%98-%E5%8E%9F%E5%9E%8B%E9%93%BE/</url>
      
        <content type="html"><![CDATA[<h1 id="原型链典型面试题"><a href="#原型链典型面试题" class="headerlink" title="原型链典型面试题"></a>原型链典型面试题</h1><h2 id="1"><a href="#1" class="headerlink" title="1"></a>1</h2><blockquote><p>以下代码输出的值是多少</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"> A.prototype.n = <span class="number">1</span> </span><br><span class="line"></span><br><span class="line"> <span class="keyword">var</span> b = <span class="keyword">new</span> A()</span><br><span class="line"></span><br><span class="line"> A.prototype = &#123;</span><br><span class="line">   n: <span class="number">2</span>,</span><br><span class="line">   m: <span class="number">3</span></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">var</span> c = <span class="keyword">new</span> A()</span><br><span class="line"> <span class="built_in">console</span>.log(b.n, b.m, c.n, c.m) <span class="comment">// 1 define 2 3</span></span><br></pre></td></tr></table></figure><p>解答：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A.prototype.n = <span class="number">1</span></span><br></pre></td></tr></table></figure><blockquote><p>这一步 是在A的原型对象内部新增了一个属性 n ，其值为1<br>之后由此时的A创建的实例对象b的隐式原型指向的，也是有该属性的A的原型对象</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A.prototype = &#123;</span><br><span class="line">    n: <span class="number">2</span>,</span><br><span class="line">    m: <span class="number">3</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><blockquote><p>这一操作，是直接在堆内存中重新开辟了一段具有n m两个属性的空间<br>同时A的实例对象地址也从新改变，指向了新开辟的地方<br>即 上述语句与下列语句等价</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A.prototype =<span class="keyword">new</span> <span class="built_in">Object</span> (&#123;</span><br><span class="line">n:<span class="number">2</span>,</span><br><span class="line">m:<span class="number">3</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><blockquote><p>以A为构造函数新产生的实例c的 _ _ proto _ _ 的值会继承构造函数的prototype<br>故此时c继承的就是A的现有的prototype的值<br>故c可以通过原型链找到n,m两个属性</p></blockquote><h2 id="2"><a href="#2" class="headerlink" title="2"></a>2</h2><blockquote><p>f中有（可以使用）a，b方法吗？Foo中呢？</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span> (<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">  <span class="built_in">Object</span>.prototype.a = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'a()'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">Function</span>.prototype.b = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'b()'</span>)oo</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> f = <span class="keyword">new</span> Foo()</span><br></pre></td></tr></table></figure><blockquote><p>首先来探讨f：<br>所有对象的prototype属性默认指向一个空的Object实例对象，此Object为该对象的原型对象（当然 Object（）除外）<br>实例对象的 _ _ proto  _ _ 指向构造函数的原型对象<br>所以， f的 _ _ proto  _ _ 指向的，也就是Foo函数的Object实例<br>而Object.prototype.a 是给Object的原型对象里面加的方法<br>所以，可以通过f来调用a方法<br>寻找过程：f=&gt;f._ _ proto  _ _ (Foo.prototype)=&gt;Foo.prototype.  _ _ proto  _ _ =&gt;Object.prototype 找到了<br>同理，f.b找到Object.prototype 也没找到<br>如下图所示：</p></blockquote><p><img src="/images/%E5%8E%9F%E5%9E%8B%E9%93%BE%E5%87%BD%E6%95%B0%E9%9D%A2%E8%AF%95%E9%A2%981.png" alt="f的原型链"></p><blockquote><p>接着来讨论Foo函数<br>首先，Foo作为一个函数，其可以理解为这样：</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Foo = <span class="keyword">new</span> <span class="built_in">Function</span>()</span><br></pre></td></tr></table></figure><blockquote><p>我理解为：Function是一切函数的源头，当然Function也是其自己的源头<br>所以，Foo函数可以使用构造函数函数的原型对象内部的b方法<br>同时，由于Function也有自己的原型对象也是一个空的Object实例对象<br>所以Function.prototype.b添加的方法，Foo也可以调用<br>同时Function指向了Object实例对象，所以Foo也可以调用a方法</p></blockquote><p><img src="/images/%E5%8E%9F%E5%9E%8B%E9%93%BE%E5%87%BD%E6%95%B0%E9%9D%A2%E8%AF%95%E9%A2%982.png" alt="F的原型链"></p><blockquote><p>F.a() F没有a属性，往原型上找<br>F.<em>proto</em> = Function.prototype 没找到a<br>Function.prototype.<em>proto</em> = Object.prototype  找到了<br>同理F.b找到Function.prototype时找到了</p></blockquote><blockquote><p><a href="https://juejin.im/post/5c72a1766fb9a049ea3993e6" target="_blank" rel="noopener">还是理解不了的话，可以看一下这里的内容</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> js高级 </category>
          
          <category> 面试题 </category>
          
          <category> 原型链 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 原型链面试 </tag>
            
            <tag> js面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js高级-原型_原型链</title>
      <link href="/2020/06/09/js%E9%AB%98%E7%BA%A7-%E5%87%BD%E6%95%B0-%E5%8E%9F%E5%9E%8B_%E5%8E%9F%E5%9E%8B%E9%93%BE/"/>
      <url>/2020/06/09/js%E9%AB%98%E7%BA%A7-%E5%87%BD%E6%95%B0-%E5%8E%9F%E5%9E%8B_%E5%8E%9F%E5%9E%8B%E9%93%BE/</url>
      
        <content type="html"><![CDATA[<h1 id="原型与原型链"><a href="#原型与原型链" class="headerlink" title="原型与原型链"></a>原型与原型链</h1><h2 id="原型（prototype）"><a href="#原型（prototype）" class="headerlink" title="原型（prototype）"></a>原型（prototype）</h2><ul><li>函数的prototype属性(图)    </li></ul><blockquote><p>每个函数都有一个prototype属性, 它默认指向一个Object空对象(即称为: 原型对象)<br>原型对象中有一个属性constructor, 它指向函数对象</p></blockquote><ul><li><p>给原型对象添加属性(一般都是方法)</p><blockquote><p>作用: 函数的所有实例对象自动拥有原型中的属性(方法)</p></blockquote>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 每个函数都有一个prototype属性, 它默认指向一个Object空对象(即称为: 原型对象)</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Date</span>.prototype, <span class="keyword">typeof</span> <span class="built_in">Date</span>.prototype)</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fun</span> (<span class="params"></span>) </span>&#123;<span class="comment">//alt + shift +r(重命名rename)</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(Fun.prototype)  <span class="comment">// 默认指向一个Object空对象(没有我们的属性)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 原型对象中有一个属性constructor, 它指向函数对象</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Date</span>.prototype.constructor===<span class="built_in">Date</span>)</span><br><span class="line"><span class="built_in">console</span>.log(Fun.prototype.constructor===Fun)</span><br><span class="line"></span><br><span class="line"><span class="comment">//给原型对象添加属性(一般是方法) ===&gt;实例对象可以访问</span></span><br><span class="line">Fun.prototype.test = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'test()'</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> fun = <span class="keyword">new</span> Fun()</span><br><span class="line">fun.test()</span><br></pre></td></tr></table></figure></li></ul><h2 id="显示原型（属性）和隐式原型（属性）"><a href="#显示原型（属性）和隐式原型（属性）" class="headerlink" title="显示原型（属性）和隐式原型（属性）"></a>显示原型（属性）和隐式原型（属性）</h2><ol><li>每个函数function都有一个prototype，即显式原型(属性)</li><li>每个实例对象都有一个<strong>proto</strong>，可称为隐式原型(属性)</li><li>对象的隐式原型的值为其对应构造函数的显式原型的值</li><li>内存结构(图)</li><li>总结:</li></ol><ul><li><p>函数的prototype属性: 在定义函数时自动添加的, 默认值是一个空Object对象</p></li><li><p>对象的<strong>proto</strong>属性: 创建对象时自动添加的, 默认值为构造函数的prototype属性值</p></li><li><p>程序员能直接操作显式原型, 但不能直接操作隐式原型(ES6之前)</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.__proto__)</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.test1 = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'test1()'</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(Fn.prototype)</span><br><span class="line">Fn.prototype.test2 = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'test2()'</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> fn = <span class="keyword">new</span> Fn()</span><br><span class="line">fn.test1()</span><br><span class="line">fn.test2()</span><br><span class="line"><span class="built_in">console</span>.log(fn.toString())</span><br><span class="line"><span class="built_in">console</span>.log(fn.test3)</span><br><span class="line"><span class="comment">// fn.test3()</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1. 函数的显示原型指向的对象默认是空Object实例对象(但Object不满足)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="built_in">console</span>.log(Fn.prototype <span class="keyword">instanceof</span> <span class="built_in">Object</span>) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype <span class="keyword">instanceof</span> <span class="built_in">Object</span>) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Function</span>.prototype <span class="keyword">instanceof</span> <span class="built_in">Object</span>) <span class="comment">// true</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">2. 所有函数都是Function的实例(包含Function)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Function</span>.__proto__===<span class="built_in">Function</span>.prototype)</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">3. Object的原型对象是原型链尽头</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.__proto__) <span class="comment">// null</span></span><br></pre></td></tr></table></figure></li></ul><p><img src="/images/%E6%98%BE%E5%BC%8F%E5%8E%9F%E5%9E%8B%E4%B8%8E%E9%9A%90%E5%BC%8F%E5%8E%9F%E5%9E%8B.png" alt="显式原型与隐式原型"></p><h2 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h2><ul><li><p>访问一个对象的属性时:</p><ul><li><p>先在自身属性中查找，找到返回</p></li><li><p>如果没有, 再沿着<strong>proto</strong>这条链向上查找, 找到返回</p></li><li><p>如果最终没找到, 返回undefined</p></li></ul></li><li><p>别名: 隐式原型链</p></li><li><p>作用: 查找对象的属性(方法)</p></li></ul><p><img src="/images/%E5%8E%9F%E5%9E%8B%E9%93%BE%E5%88%86%E6%9E%90.png" alt="原型链分析"></p><pre><code>console.log(Object.prototype)console.log(Object.prototype.__proto__)function Fn() {this.test1 = function () {  console.log(&apos;test1()&apos;)}}console.log(Fn.prototype)Fn.prototype.test2 = function () {console.log(&apos;test2()&apos;)}var fn = new Fn()fn.test1()fn.test2()console.log(fn.toString())console.log(fn.test3)// fn.test3()</code></pre><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1. 函数的显示原型指向的对象默认是空Object实例对象(但Object不满足)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="built_in">console</span>.log(Fn.prototype <span class="keyword">instanceof</span> <span class="built_in">Object</span>) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype <span class="keyword">instanceof</span> <span class="built_in">Object</span>) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Function</span>.prototype <span class="keyword">instanceof</span> <span class="built_in">Object</span>) <span class="comment">// true</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">2. 所有函数都是Function的实例(包含Function)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Function</span>.__proto__===<span class="built_in">Function</span>.prototype)</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">3. Object的原型对象是原型链尽头</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.__proto__) <span class="comment">// null</span></span><br></pre></td></tr></table></figure><h2 id="原型链-属性读取"><a href="#原型链-属性读取" class="headerlink" title="原型链_属性读取"></a>原型链_属性读取</h2><ol><li>读取对象的属性值时: 会自动到原型链中查找</li><li>设置对象的属性值时: 不会查找原型链, 如果当前对象中没有此属性, 直接添加此属性并设置其值</li><li>方法一般定义在原型中, 属性一般通过构造函数定义在对象本身上</li></ol><h2 id="探索instanceof"><a href="#探索instanceof" class="headerlink" title="探索instanceof"></a>探索instanceof</h2><ol><li>instanceof是如何判断的?<ul><li>表达式: A instanceof B</li><li>如果B函数的显式原型对象在A对象的原型链上, 返回true, 否则返回false</li></ul></li><li>Function是通过new自己产生的实例<blockquote><p>即：function name（）&lt;===&gt; name = new Function （）{}</p></blockquote></li></ol>]]></content>
      
      
      <categories>
          
          <category> js高级 </category>
          
          <category> js函数 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> prototype </tag>
            
            <tag> 原型 </tag>
            
            <tag> 原型链 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js高级-IEFE-this</title>
      <link href="/2020/06/09/js%E9%AB%98%E7%BA%A7-%E5%9F%BA%E7%A1%80-IEFE/"/>
      <url>/2020/06/09/js%E9%AB%98%E7%BA%A7-%E5%9F%BA%E7%A1%80-IEFE/</url>
      
        <content type="html"><![CDATA[<h1 id="IEFE"><a href="#IEFE" class="headerlink" title="IEFE"></a>IEFE</h1><blockquote><p>Immediately-Invoked Function Expression（立即执行函数表达式）<br>匿名函数自调用</p></blockquote><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><ul><li><p>隐藏实现</p></li><li><p>不会污染外部（全局）命名空间</p></li><li><p>用它来编码js模块</p><pre><code>(function () { //匿名函数自调用var a = 3console.log(a + 3)})()var a = 4console.log(a)// 4</code></pre></li></ul><h1 id="THIS"><a href="#THIS" class="headerlink" title="THIS"></a>THIS</h1><blockquote><p>主要研究函数中的this</p></blockquote><h2 id="this是什么"><a href="#this是什么" class="headerlink" title="this是什么"></a>this是什么</h2><ul><li>任何函数本质上都是通过某个对象来调用的,如果没有直接指定就是window</li><li>所有函数内部都有一个变量this</li><li>它的值是调用函数的当前对象</li></ul><h2 id="确定this的值"><a href="#确定this的值" class="headerlink" title="确定this的值"></a>确定this的值</h2><ul><li><p>test(): window</p></li><li><p>p.test(): p</p></li><li><p>new test(): 新创建的对象</p></li><li><p>p.call(obj): obj</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">color</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>)</span><br><span class="line">    <span class="keyword">this</span>.color = color;</span><br><span class="line">    <span class="keyword">this</span>.getColor = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="keyword">this</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.color;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">this</span>.setColor = <span class="function"><span class="keyword">function</span> (<span class="params">color</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="keyword">this</span>)</span><br><span class="line">      <span class="keyword">this</span>.color = color;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>Person(“red”); //this是谁? window</p><p>var p = new Person(“yello”); //this是谁? p</p><p>p.getColor(); //this是谁? p</p><p>  var obj = {};<br>p.setColor.call(obj, “black”); //this是谁? obj</p><p>  var test = p.setColor;<br>test(); //this是谁? window</p><p>  function fun1() {<br>    function fun2() {<br>      console.log(this);<br>  }</p><pre><code>fun2(); //this是谁? window</code></pre><p>  }<br>  fun1();</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> js高级 </category>
          
          <category> js基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IEFE </tag>
            
            <tag> this </tag>
            
            <tag> js高级 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js高级-函数</title>
      <link href="/2020/06/09/js%E9%AB%98%E7%BA%A7-%E5%9F%BA%E7%A1%80-%E5%87%BD%E6%95%B0/"/>
      <url>/2020/06/09/js%E9%AB%98%E7%BA%A7-%E5%9F%BA%E7%A1%80-%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="函数（基础）"><a href="#函数（基础）" class="headerlink" title="函数（基础）"></a>函数（基础）</h1><h2 id="什么是函数"><a href="#什么是函数" class="headerlink" title="什么是函数"></a>什么是函数</h2><ul><li><p>实现特定功能的多条语句的封装体</p></li><li><p>只有函数可以执行 其他类型数据无法执行</p><h2 id="为什么要用函数"><a href="#为什么要用函数" class="headerlink" title="为什么要用函数"></a>为什么要用函数</h2></li><li><p>提高代码复用</p></li><li><p>便于阅读和交流</p><h2 id="如何定义"><a href="#如何定义" class="headerlink" title="如何定义"></a>如何定义</h2></li><li><p>函数声明</p><pre><code>function fn1 () { //函数声明    console.log(&apos;fn1()&apos;)}</code></pre></li><li><p>表达式</p><pre><code>var fn2 = function () { //表达式    console.log(&apos;fn2()&apos;)}</code></pre></li></ul><blockquote><p>二者有区别/</p></blockquote><h2 id="如何调用"><a href="#如何调用" class="headerlink" title="如何调用"></a>如何调用</h2><ul><li>test(): 直接调用</li><li>obj.test(): 通过对象调用</li><li>new test(): new调用</li><li>test.call/apply(obj): 临时让test成为obj的方法进行调用</li></ul><h2 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h2><ul><li><p>特殊的函数</p><ul><li>用户或者系统内部定义的</li><li>没有调用</li><li>最终函数执行了</li></ul></li><li><p>常见的回调函数</p><ul><li><p>dom事件回调函数</p><pre><code>document.getElementById(&apos;btn&apos;).onclick = function () { // dom事件回调函数alert(this.innerHTML)}</code></pre></li><li><p>定时器回调函数</p><pre><code>setTimeout(function () { // 定时器回调函数alert(&apos;到点了&apos;+this)}, 2000)</code></pre></li><li></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> js高级 </category>
          
          <category> js基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js函数 </tag>
            
            <tag> 函数调用 </tag>
            
            <tag> 回调函数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js高级-对象基础</title>
      <link href="/2020/06/09/js%E9%AB%98%E7%BA%A7-%E5%9F%BA%E7%A1%80-%E5%AF%B9%E8%B1%A1/"/>
      <url>/2020/06/09/js%E9%AB%98%E7%BA%A7-%E5%9F%BA%E7%A1%80-%E5%AF%B9%E8%B1%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h1><h2 id="什么是对象"><a href="#什么是对象" class="headerlink" title="什么是对象"></a>什么是对象</h2><ul><li><p>多个数据的分装体</p></li><li><p>用来保存多个数据的容器</p></li><li><p>可以类比现实中的具有多个属性的事物</p><h2 id="为什么要用对象"><a href="#为什么要用对象" class="headerlink" title="为什么要用对象"></a>为什么要用对象</h2></li><li><p>统一管理多个数据</p><h2 id="对象的组成"><a href="#对象的组成" class="headerlink" title="对象的组成"></a>对象的组成</h2></li><li><p>属性：属性名(字符串)和属性值(任意)组成</p></li><li><p>方法：一种特别的属性(属性值是函数)</p><h2 id="如何访问对象内部数据"><a href="#如何访问对象内部数据" class="headerlink" title="如何访问对象内部数据"></a>如何访问对象内部数据</h2></li><li><p>.属性名: 编码简单, 有时不能用</p></li><li><p>[‘属性’]: 编码麻烦, 能通用</p><h2 id="何时使用-属性名"><a href="#何时使用-属性名" class="headerlink" title="何时使用[属性名]"></a>何时使用[属性名]</h2></li><li><p>属性名中含有特殊字符： “ - ” ，空格等</p><pre><code>var p = {}// p.content-type = &apos;text/json&apos; //不能用p[&apos;content-type&apos;] = &apos;text/json&apos;console.log(p[&apos;content-type&apos;])//text/jsonconsole.log(p.content-type)//报错</code></pre></li><li><p>属性名为变量时</p><pre><code>var propName = &apos;myAge&apos;var value = 18// p.propName = value //不能用p[propName] = valueconsole.log(p[propName])</code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> js高级 </category>
          
          <category> js基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js对象 </tag>
            
            <tag> 对象基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据-变量-内存</title>
      <link href="/2020/06/08/js%E9%AB%98%E7%BA%A7-%E5%9F%BA%E7%A1%80-%E6%95%B0%E6%8D%AE_%E5%8F%98%E9%87%8F_%E5%86%85%E5%AD%98/"/>
      <url>/2020/06/08/js%E9%AB%98%E7%BA%A7-%E5%9F%BA%E7%A1%80-%E6%95%B0%E6%8D%AE_%E5%8F%98%E9%87%8F_%E5%86%85%E5%AD%98/</url>
      
        <content type="html"><![CDATA[<h1 id="数据变量内存"><a href="#数据变量内存" class="headerlink" title="数据变量内存"></a>数据变量内存</h1><blockquote><p> 内存,数据, 变量三者之间的关系</p><ul><li>内存用来存储数据的空间</li><li>变量是内存的标识</li></ul></blockquote><ol><li><p>什么是数据?</p><ul><li>存储在内存中代表特定信息的’东东’, 本质上是0101…</li><li>数据的特点: 可传递, 可运算</li><li>一切皆数据</li><li>内存中所有操作的目标: 数据<ul><li>算术运算 逻辑运算 赋值 运行函数</li></ul></li></ul></li><li><p>什么是内存?</p><ul><li>内存条通电后产生的可储存数据的空间(临时的)</li><li>内存产生和死亡: 内存条(电路版)==&gt;通电==&gt;产生内存空间==&gt;存储数据==&gt;处理数据==&gt;断电==&gt;内存空间和数据都消失</li><li>一块小内存的2个数据<ul><li>内部存储的数据</li><li>地址值</li></ul></li><li>内存分类<ul><li>栈: 全局变量/局部变量</li><li>堆: 对象</li></ul></li></ul></li><li><p>什么是变量?</p><ul><li>可变化的量, 由变量名和变量值组成</li><li>每个变量都对应的一块小内存, 变量名用来查找对应的内存, 变量值就是内存中保存的数据</li></ul></li><li><p>问题：</p><ol><li><p>赋值和内存</p><blockquote><p>   var a = xxx, a内存中到底保存的是什么?</p><ul><li>xxx 是基本数据, 保存的就是这个数据</li><li>xxx 是对象, 保存的是对象的地址值</li><li>xxx 是一个变量, 保存的xxx的内存内容(可能是基本数据, 也可能是地址值</li></ul></blockquote></li><li><p>引用变量赋值</p><blockquote><p>关于引用变量赋值问题</p><ul><li>2个引用变量指向同一个对象, 通过一个变量修改对象内部数据, 另一个变量看到的是修改之后的数据</li></ul></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj1 = &#123;<span class="attr">name</span>: <span class="string">'Tom'</span>&#125;</span><br><span class="line"><span class="keyword">var</span> obj2 = obj1</span><br><span class="line">obj2.age = <span class="number">12</span></span><br><span class="line"><span class="built_in">console</span>.log(obj1.age)  <span class="comment">// 12</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span> (<span class="params">obj</span>) </span>&#123;</span><br><span class="line">obj.name = <span class="string">'A'</span></span><br><span class="line">&#125;</span><br><span class="line">fn(obj1)</span><br><span class="line"><span class="built_in">console</span>.log(obj2.name) <span class="comment">//A</span></span><br></pre></td></tr></table></figure><blockquote><ul><li>2个引用变量指向同一个对象, 让其中一个引用变量指向另一个对象, 另一引用变量依然指向前一个对象</li></ul></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123;<span class="attr">age</span>: <span class="number">12</span>&#125;</span><br><span class="line"><span class="keyword">var</span> b = a</span><br><span class="line">a = &#123;<span class="attr">name</span>: <span class="string">'BOB'</span>, <span class="attr">age</span>: <span class="number">13</span>&#125;</span><br><span class="line">b.age = <span class="number">14</span></span><br><span class="line"><span class="built_in">console</span>.log(b.age, a.name, a.age) <span class="comment">// 14 Bob 13</span></span><br></pre></td></tr></table></figure></li><li><p>函数参数传递</p><blockquote><p>在js调用函数时传递变量参数时, 是值传递还是引用传递（地址值）</p><ul><li>理解1: 都是值(基本/地址值)传递</li><li>理解2: 可能是值传递, 也可能是引用传递(地址值)</li></ul></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">3</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span> (<span class="params">a</span>) </span>&#123;</span><br><span class="line">a = a +<span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">fn(a)</span><br><span class="line"><span class="built_in">console</span>.log(a)<span class="comment">//a=3</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn2</span> (<span class="params">obj</span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(obj.name)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;<span class="attr">name</span>: <span class="string">'Tom'</span>&#125;</span><br><span class="line">fn2(obj)</span><br></pre></td></tr></table></figure></li><li><p>通过函数修改变量值</p><blockquote><p>对于基本变量 无法修改</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">x = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">foo(a);</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// 仍为1, 未受x = 2赋值所影响</span></span><br></pre></td></tr></table></figure><blockquote><p>对于引用变量<br>修改形参来修改原变量 ❌</p></blockquote><p> var obj = {x : 1};<br> function foo(o) {<br> o = 100;<br> }<br> foo(obj);<br> console.log(obj.x); // 仍然是1, obj并未被修改为100.</p><blockquote><p>修改形参的属性值来修改原变量的对应属性值</p></blockquote><p> var obj = {x : 1};<br> function foo(o) {</p><pre><code>o.x = 3;</code></pre><p> }<br> foo(obj);<br> console.log(obj.x); // 3, 被修改了!</p></li><li><p>内存管理</p><blockquote><p>   JS引擎如何管理内存?</p><ol><li>内存生命周期</li></ol><ul><li>分配小内存空间, 得到它的使用权</li><li>存储数据, 可以反复进行操作</li><li>释放小内存空间</li></ul><ol start="2"><li>释放内存</li></ol><ul><li>局部变量: 函数执行完自动释放</li><li>对象: 成为垃圾对象==&gt;垃圾回收器回收<br>垃圾对象：我理解为不被引用的对象</li></ul></blockquote></li></ol></li></ol>]]></content>
      
      
      <categories>
          
          <category> js高级 </category>
          
          <category> js基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 变量赋值 </tag>
            
            <tag> 函数参数传递 </tag>
            
            <tag> 内存管理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据类型</title>
      <link href="/2020/06/08/js%E9%AB%98%E7%BA%A7-%E5%87%BD%E6%95%B0-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
      <url>/2020/06/08/js%E9%AB%98%E7%BA%A7-%E5%87%BD%E6%95%B0-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><ul><li>基本类型<ul><li>string：任意字符串</li><li>number：任意数字</li><li>Boolean：true/false</li><li>undefined：undefined，未赋值的var变量</li><li>null：null</li></ul></li><li>对象（引用）类型<ul><li>object：任意对象</li><li>function：特别的对象（可以执行）</li><li>array：特别的对象（数值下标，内部数据有序）</li></ul></li></ul><h2 id="类型判断"><a href="#类型判断" class="headerlink" title="类型判断"></a>类型判断</h2><ul><li><p>typeof：</p><pre><code>特殊情况记一下</code></pre><ul><li>可以判断: undefined/ 数值 / 字符串 / 布尔值 / function</li><li>不能判断: null与object  object与array</li></ul></li><li><p>instanceof：</p><ul><li>可以判断对象类型 </li></ul></li><li><p>===:</p><ul><li>可以判断undefined和null</li></ul></li></ul><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><ul><li>undefined 和null的区别<ul><li>undefine:代表变量定义未赋值</li><li>null：变量的一种特殊的值</li></ul></li><li>何时使用null？<ul><li>初始赋值为null，在开始对象内容不明确时，表明将来赋值为对象</li><li>结束时赋值为null，内存回收，被垃圾回收器回收</li></ul></li><li>严格区分变量类型和数据类型<ul><li>数据的类型<ul><li>基本类型</li><li>对象类型</li></ul></li><li>变量的类型(变量内存值的类型)<ul><li>基本类型: 保存就是基本类型的数据</li><li>引用类型: 保存的是地址值</li></ul></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> js高级 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js数据类型 </tag>
            
            <tag> typeof </tag>
            
            <tag> instanceof </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
