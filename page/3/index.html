<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>二木</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="personal blog">
<meta property="og:type" content="website">
<meta property="og:title" content="二木">
<meta property="og:url" content="https://qiao666.github.io/page/3/index.html">
<meta property="og:site_name" content="二木">
<meta property="og:description" content="personal blog">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Qiao666">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="二木" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 4.2.1"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">二木</a>
        <div style="color: white;padding: 10px;"><span >为什么要去登山？因为山就在那里</span></div>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">主页</a>
        
          <a class="main-nav-link" href="/archives">归档</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS 订阅"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="搜索"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://qiao666.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-剑指offer-37序列化二叉树" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/07/17/%E5%89%91%E6%8C%87offer-37%E5%BA%8F%E5%88%97%E5%8C%96%E4%BA%8C%E5%8F%89%E6%A0%91/" class="article-date">
  <time class="dt-published" datetime="2020-07-17T10:31:36.000Z" itemprop="datePublished">2020-07-17</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%89%91%E6%8C%87offer/">剑指offer</a>►<a class="article-category-link" href="/categories/%E5%89%91%E6%8C%87offer/37%E5%BA%8F%E5%88%97%E5%8C%96%E4%BA%8C%E5%8F%89%E6%A0%91/">37序列化二叉树</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/07/17/%E5%89%91%E6%8C%87offer-37%E5%BA%8F%E5%88%97%E5%8C%96%E4%BA%8C%E5%8F%89%E6%A0%91/">剑指offer-37序列化二叉树</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>请实现两个函数，分别用来序列化和反序列化二叉树。</p>
<p>示例: </p>
<p>你可以将以下二叉树：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  1</span><br><span class="line"> &#x2F; \</span><br><span class="line">2   3</span><br><span class="line">   &#x2F; \</span><br><span class="line">  4   5</span><br></pre></td></tr></table></figure>
<p>序列化为 “[1,2,3,null,null,4,5]”</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/xu-lie-hua-er-cha-shu-lcof" target="_blank" rel="noopener">https://leetcode-cn.com/problems/xu-lie-hua-er-cha-shu-lcof</a></p>
<h1 id="算法分析-代码实现"><a href="#算法分析-代码实现" class="headerlink" title="算法分析+代码实现"></a>算法分析+代码实现</h1><p>序列化函数：利用队列，注意空结点也要输出，值为null</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> serialize = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root)&#123;</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> stack =[]</span><br><span class="line">    <span class="keyword">let</span> queue = [root]</span><br><span class="line">    <span class="keyword">while</span>(queue.length)&#123;</span><br><span class="line">        <span class="comment">//当前结点出队</span></span><br><span class="line">        node=queue.shift()</span><br><span class="line">        <span class="keyword">if</span>(!node)&#123;</span><br><span class="line">            stack.push(<span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            stack.push(node.val)</span><br><span class="line">            queue.push(node.left)</span><br><span class="line">            queue.push(node.right)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> stack</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>反序列化函数，利用队列，和指针i，队列存储当前根节点，指针i指向当前根结点的子节点</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> deserialize = <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!data.length)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> root=<span class="keyword">new</span> TreeNode(data[<span class="number">0</span>])</span><br><span class="line">    <span class="keyword">let</span> i=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">let</span> queue=[root]</span><br><span class="line">    <span class="keyword">while</span>(queue.length&amp;&amp;i&lt;data.length)&#123;</span><br><span class="line">       <span class="comment">//当前根节点</span></span><br><span class="line">       <span class="keyword">let</span>  curRoot=queue.shift()</span><br><span class="line">        <span class="keyword">if</span>(!curRoot)&#123;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//先加一个左节点</span></span><br><span class="line">        <span class="keyword">if</span>(data[i]!=<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">let</span> cur = <span class="keyword">new</span> TreeNode(data[i])</span><br><span class="line">            curRoot.left = cur;</span><br><span class="line">            queue.push(cur)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            curRoot.left=<span class="literal">null</span></span><br><span class="line">            queue.push(<span class="literal">null</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        i++</span><br><span class="line">        <span class="comment">//再加一个右节点</span></span><br><span class="line">        <span class="keyword">if</span>(data[i]!=<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">let</span> cur =<span class="keyword">new</span> TreeNode(data[i])</span><br><span class="line">            curRoot.right = cur</span><br><span class="line">            queue.push(cur)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            curRoot.right = <span class="literal">null</span></span><br><span class="line">            queue.push(<span class="literal">null</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        i++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>结果：<br>执行用时：148 ms, 在所有 JavaScript 提交中击败了42.61%的用户<br>内存消耗：48.1 MB, 在所有 JavaScript 提交中击败了100.00%的用户</p>
<h1 id="总结反思"><a href="#总结反思" class="headerlink" title="总结反思"></a>总结反思</h1><p>该题目主要考察的是队列，注意空结点值仍需要存储</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://qiao666.github.io/2020/07/17/%E5%89%91%E6%8C%87offer-37%E5%BA%8F%E5%88%97%E5%8C%96%E4%BA%8C%E5%8F%89%E6%A0%91/" data-id="ckcq773k4000qicva7ffy8tlc" data-title="剑指offer-37序列化二叉树" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%BA%8F%E5%88%97%E5%8C%96%E4%BA%8C%E5%8F%89%E6%A0%91/" rel="tag">序列化二叉树</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%98%9F%E5%88%97/" rel="tag">队列</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-剑指offer-36二叉搜索树和双向链表" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/07/17/%E5%89%91%E6%8C%87offer-36%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E5%92%8C%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/" class="article-date">
  <time class="dt-published" datetime="2020-07-17T08:25:04.000Z" itemprop="datePublished">2020-07-17</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%89%91%E6%8C%87offer/">剑指offer</a>►<a class="article-category-link" href="/categories/%E5%89%91%E6%8C%87offer/36%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E5%92%8C%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/">36二叉搜索树和双向链表</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/07/17/%E5%89%91%E6%8C%87offer-36%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E5%92%8C%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/">剑指offer-36二叉搜索树和双向链表</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的循环双向链表。要求不能创建任何新的节点，只能调整树中节点指针的指向。<br>特别地，我们希望可以就地完成转换操作。当转化完成以后，树中节点的左指针需要指向前驱，树中节点的右指针需要指向后继。还需要返回链表中的第一个节点的指针。</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-yu-shuang-xiang-lian-biao-lcof" target="_blank" rel="noopener">https://leetcode-cn.com/problems/er-cha-sou-suo-shu-yu-shuang-xiang-lian-biao-lcof</a></p>
<h1 id="算法分析-代码实现"><a href="#算法分析-代码实现" class="headerlink" title="算法分析+代码实现"></a>算法分析+代码实现</h1><p>1 简单思路，将该树所有结点按中序遍历递归入栈，然后操作栈中元素，修改栈中元素的左右结点，注意首尾结点要连接成环</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> treeToDoublyList = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root)&#123;</span><br><span class="line">        <span class="keyword">return</span> root</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> stack = [];</span><br><span class="line">    <span class="keyword">let</span> dfs = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)&#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        dfs(root.left)</span><br><span class="line">        stack.push(root)</span><br><span class="line">        dfs(root.right)</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(root)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i =<span class="number">0</span>;i&lt;stack.length<span class="number">-1</span>;i++)&#123;</span><br><span class="line">        stack[i].right=stack[i+<span class="number">1</span>]</span><br><span class="line">        stack[i+<span class="number">1</span>].left = stack[i]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//更新首尾结点</span></span><br><span class="line">    stack[<span class="number">0</span>].left=stack[stack.length<span class="number">-1</span>]</span><br><span class="line">    stack[stack.length<span class="number">-1</span>].right = stack[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">return</span> stack[<span class="number">0</span>]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>结果:递归一次，遍历一次</p>
<p>执行用时：92 ms, 在所有 JavaScript 提交中击败了8.95%的用户</p>
<p>内存消耗：40 MB, 在所有 JavaScript 提交中击败了100.00%的用户</p>
<p>2 不用栈，直接在递归过程中修改代码，需要双指针，头指针和工作指针</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> treeToDoublyList = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root)&#123;</span><br><span class="line">        <span class="keyword">return</span> root</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> pre=head=<span class="literal">null</span></span><br><span class="line">    <span class="keyword">let</span> dfs = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)&#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//找左子节点</span></span><br><span class="line">        dfs(root.left)</span><br><span class="line">        <span class="comment">//当前结点为最左子节点，更新head和pre两个指针</span></span><br><span class="line">        <span class="keyword">if</span>(!pre)&#123;</span><br><span class="line">            head = root;</span><br><span class="line">            pre = root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//pre指针保存的当前节点的左子节点，更新当前结点和左子节点的关系，pre更新为当前结点</span></span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            pre.right = root;</span><br><span class="line">            root.left=pre;</span><br><span class="line">            pre = root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//遍历右子节点</span></span><br><span class="line">        dfs(root.right)</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(root)</span><br><span class="line">    <span class="comment">//递归结束以后形成新的链表，跟新头尾，生成循环链表</span></span><br><span class="line">    head.left=pre;</span><br><span class="line">    pre.right=head;</span><br><span class="line">    <span class="keyword">return</span> head</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>结果：<br>执行用时：92 ms, 在所有 JavaScript 提交中击败了8.95%的用户<br>内存消耗：39.8 MB, 在所有 JavaScript 提交中击败了100.00%的用户</p>
<h2 id="总结反思"><a href="#总结反思" class="headerlink" title="总结反思"></a>总结反思</h2><p>首先要明白二叉搜索树的定义，然后了解中序遍历<br>结合双指针或者数据栈把算法实现</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://qiao666.github.io/2020/07/17/%E5%89%91%E6%8C%87offer-36%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E5%92%8C%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/" data-id="ckcq773je000licvacaifbcb9" data-title="剑指offer-36二叉搜索树和双向链表" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/" rel="tag">二叉搜索树</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/" rel="tag">双向链表</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%8F%8C%E6%8C%87%E9%92%88/" rel="tag">双指针</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%80%92%E5%BD%92/" rel="tag">递归</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-剑指offer-35复杂链表的复制" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/07/16/%E5%89%91%E6%8C%87offer-35%E5%A4%8D%E6%9D%82%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%8D%E5%88%B6/" class="article-date">
  <time class="dt-published" datetime="2020-07-16T08:04:42.000Z" itemprop="datePublished">2020-07-16</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%89%91%E6%8C%87offer/">剑指offer</a>►<a class="article-category-link" href="/categories/%E5%89%91%E6%8C%87offer/35%E5%A4%8D%E6%9D%82%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%8D%E5%88%B6/">35复杂链表的复制</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/07/16/%E5%89%91%E6%8C%87offer-35%E5%A4%8D%E6%9D%82%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%8D%E5%88%B6/">剑指offer-35复杂链表的复制</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>请实现 copyRandomList 函数，复制一个复杂链表。在复杂链表中，每个节点除了有一个 next 指针指向下一个节点，还有一个 random 指针指向链表中的任意节点或者 null。<br>示例 1：<br><img src="/images/%E5%89%91%E6%8C%87-35/e1.png" alt="img"><br>输入：head = [[7,null],[13,0],[11,4],[10,2],[1,0]]<br>输出：[[7,null],[13,0],[11,4],[10,2],[1,0]]<br>示例 2：<br><img src="/images/%E5%89%91%E6%8C%87-35/e2.png" alt="img"><br>输入：head = [[1,1],[2,1]]<br>输出：[[1,1],[2,1]]<br>示例 3：<br><img src="/images/%E5%89%91%E6%8C%87-35/e3.png" alt="img"><br>输入：head = [[3,null],[3,0],[3,null]]<br>输出：[[3,null],[3,0],[3,null]]<br>示例 4：<br>输入：head = []<br>输出：[]<br>解释：给定的链表为空（空指针），因此返回 null。<br>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/fu-za-lian-biao-de-fu-zhi-lcof" target="_blank" rel="noopener">https://leetcode-cn.com/problems/fu-za-lian-biao-de-fu-zhi-lcof</a></p>
<h1 id="算法分析-代码实现"><a href="#算法分析-代码实现" class="headerlink" title="算法分析+代码实现"></a>算法分析+代码实现</h1><p>算法思路：<br>第一步复制当前节点和next结点<br>第二步更新新节点的random的值<br>第三步拆分所得链表，得到新链表</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> copyRandomList = <span class="function"><span class="keyword">function</span>(<span class="params">head</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">null</span>) &#123;</span><br><span class="line">         <span class="keyword">return</span> head;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">//将拷贝节点放到原节点后面，例如1-&gt;2-&gt;3这样的链表就变成了这样1-&gt;1'-&gt;2'-&gt;3-&gt;3'</span></span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">let</span> node = head, copy = <span class="literal">null</span>; node != <span class="literal">null</span>; node = node.next.next) &#123;</span><br><span class="line">         copy = <span class="keyword">new</span> Node(node.val);</span><br><span class="line">         copy.next = node.next;</span><br><span class="line">         node.next = copy;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">//把拷贝节点的random指针安排上</span></span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">let</span> node = head; node != <span class="literal">null</span>; node = node.next.next) &#123;</span><br><span class="line">         <span class="keyword">if</span> (node.random != <span class="literal">null</span>) &#123;</span><br><span class="line">             node.next.random = node.random.next;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">//分离拷贝节点和原节点，变成1-&gt;2-&gt;3和1'-&gt;2'-&gt;3'两个链表，后者就是答案</span></span><br><span class="line">     <span class="keyword">let</span> newHead = head.next;</span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">let</span> node = head, temp = <span class="literal">null</span>; node != <span class="literal">null</span> &amp;&amp; node.next != <span class="literal">null</span>;) &#123;</span><br><span class="line">         temp = node.next;</span><br><span class="line">         node.next = temp.next;</span><br><span class="line">         node = temp;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">return</span> newHead;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>结果：<br>执行用时：92 ms, 在所有 JavaScript 提交中击败了8.99%的用户<br>内存消耗：39.9 MB, 在所有 JavaScript 提交中击败了100.00%的用户</p>
<h1 id="总结反思"><a href="#总结反思" class="headerlink" title="总结反思"></a>总结反思</h1><p>该问题考察的主要是深拷贝，其次就是复杂问题简单化</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://qiao666.github.io/2020/07/16/%E5%89%91%E6%8C%87offer-35%E5%A4%8D%E6%9D%82%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%8D%E5%88%B6/" data-id="ckcq773kw000xicva4eej56ll" data-title="剑指offer-35复杂链表的复制" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%B7%B1%E6%8B%B7%E8%B4%9D/" rel="tag">深拷贝</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%93%BE%E8%A1%A8/" rel="tag">链表</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-剑指offer-34二叉树中和为某一值的路径" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/07/16/%E5%89%91%E6%8C%87offer-34%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%92%8C%E4%B8%BA%E6%9F%90%E4%B8%80%E5%80%BC%E7%9A%84%E8%B7%AF%E5%BE%84/" class="article-date">
  <time class="dt-published" datetime="2020-07-16T07:13:13.000Z" itemprop="datePublished">2020-07-16</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%89%91%E6%8C%87offer/">剑指offer</a>►<a class="article-category-link" href="/categories/%E5%89%91%E6%8C%87offer/34%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%92%8C%E4%B8%BA%E6%9F%90%E4%B8%80%E5%80%BC%E7%9A%84%E8%B7%AF%E5%BE%84/">34二叉树中和为某一值的路径</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/07/16/%E5%89%91%E6%8C%87offer-34%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%92%8C%E4%B8%BA%E6%9F%90%E4%B8%80%E5%80%BC%E7%9A%84%E8%B7%AF%E5%BE%84/">剑指offer-34二叉树中和为某一值的路径</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>输入一棵二叉树和一个整数，打印出二叉树中节点值的和为输入整数的所有路径。从树的根节点开始往下一直到叶节点所经过的节点形成一条路径。</p>
<p>示例:<br>给定如下二叉树，以及目标和 sum = 22，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">	  5</span><br><span class="line">   &#x2F;     \</span><br><span class="line">  4       8</span><br><span class="line"> &#x2F;       &#x2F; \</span><br><span class="line">11      13  4</span><br><span class="line">&#x2F;  \       &#x2F; \</span><br><span class="line">7   2     5   1</span><br></pre></td></tr></table></figure>
<p>返回:<br>[<br>[5,4,11,2],<br>[5,8,4,5]<br>]<br>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/er-cha-shu-zhong-he-wei-mou-yi-zhi-de-lu-jing-lcof" target="_blank" rel="noopener">https://leetcode-cn.com/problems/er-cha-shu-zhong-he-wei-mou-yi-zhi-de-lu-jing-lcof</a></p>
<h1 id="算法分析-代码实现"><a href="#算法分析-代码实现" class="headerlink" title="算法分析+代码实现"></a>算法分析+代码实现</h1><p>正常思路：递归算法实现</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> pathSum = <span class="function"><span class="keyword">function</span>(<span class="params">root, sum</span>) </span>&#123;</span><br><span class="line">	<span class="comment">//如果是空数组的，直接返回[]</span></span><br><span class="line">    <span class="keyword">if</span>(!root)&#123;</span><br><span class="line">        <span class="keyword">return</span> [];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> arr=[]</span><br><span class="line">    <span class="comment">//arr存放相关路径</span></span><br><span class="line">    <span class="keyword">var</span> dfs=<span class="function"><span class="keyword">function</span>(<span class="params">root,sum,path</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)&#123;<span class="keyword">return</span>&#125;</span><br><span class="line">        path.push(root.val)</span><br><span class="line">        <span class="keyword">if</span>(sum===root.val&amp;&amp;!root.left&amp;&amp;!root.right)&#123;</span><br><span class="line">        <span class="comment">//注意这里使用的是深拷贝</span></span><br><span class="line">        <span class="comment">//js中数组是引用类型，浅拷贝的是path数组的地址，当path数组内容改变时，该数组相应的也会发生变化</span></span><br><span class="line">        <span class="comment">//这里为什么可以定义arr呢?js支持闭包</span></span><br><span class="line">            arr.push([...path])</span><br><span class="line">            path.pop()</span><br><span class="line">            <span class="keyword">return</span> </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(sum!=root.val&amp;&amp;!root.left&amp;&amp;!root.right)&#123;</span><br><span class="line">            path.pop()</span><br><span class="line">            <span class="keyword">return</span> </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root.left)&#123;</span><br><span class="line">            dfs(root.left,sum-root.val,path)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root.right)&#123;</span><br><span class="line">            dfs(root.right,sum-root.val,path)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//执行一次以后将该元素出栈 </span></span><br><span class="line">        path.pop()</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(root,sum,[])</span><br><span class="line">    <span class="keyword">return</span> arr</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>结果：<br>执行用时：84 ms, 在所有 JavaScript 提交中击败了84.42%的用户<br>内存消耗：37.8 MB, 在所有 JavaScript 提交中击败了100.00%的用户</p>
<h1 id="总结反思"><a href="#总结反思" class="headerlink" title="总结反思"></a>总结反思</h1><p>普通的递归，要注意js的引用变量特性和闭包特性</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://qiao666.github.io/2020/07/16/%E5%89%91%E6%8C%87offer-34%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%92%8C%E4%B8%BA%E6%9F%90%E4%B8%80%E5%80%BC%E7%9A%84%E8%B7%AF%E5%BE%84/" data-id="ckcq773l00010icva3u912wq1" data-title="剑指offer-34二叉树中和为某一值的路径" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/" rel="tag">二叉树</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%80%92%E5%BD%92/" rel="tag">递归</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-webpack-入门" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/07/16/webpack-%E5%85%A5%E9%97%A8/" class="article-date">
  <time class="dt-published" datetime="2020-07-16T01:28:36.000Z" itemprop="datePublished">2020-07-16</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/webpack/">webpack</a>►<a class="article-category-link" href="/categories/webpack/%E5%85%A5%E9%97%A8/">入门</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/07/16/webpack-%E5%85%A5%E9%97%A8/">webpack-入门</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="WebPack到底是什么？"><a href="#WebPack到底是什么？" class="headerlink" title="WebPack到底是什么？"></a>WebPack到底是什么？</h1><p>本质上，webpack 是一个现代 JavaScript 应用程序的静态模块打包器(module bundler)。当 webpack 处理应用程序时，它会递归地构建一个依赖关系图(dependency graph)，其中包含应用程序需要的每个模块，然后将所有这些模块打包成一个或多个 bundle。</p>
<p>当我们写网站时，会用一些less，sass等预处理语言，直接引入index.html时，浏览器无法编译运行，此时需要一些小工具将less，sass等文件转换为css文件，相关效果才能显示出来；<br>换一个情况，当我们使用es6，es7，es8甚至更高版本的语法编译js文件时，浏览器它翻译不了，或者说是不支持新版语法，因为并不是所有pc都会更新最新版的浏览器，此时我们需要一种工具，将写好的js代码转换成旧版语法的js代码。<br>还有，使用一些字体库，图标库什么的，也需要另一种工具。<br>所谓webpack就是将这些工具综合起来，将那些文件，也就是模块，静态模块，给翻译成浏览器可以理解，编译的内容，这一过程就叫做打包，生成的新的文件就叫做静态资源（bundle）</p>
<h1 id="几个核心概念"><a href="#几个核心概念" class="headerlink" title="几个核心概念"></a>几个核心概念</h1><p>1 入口Entry<br>入口起点(entry point)指示 webpack 应该使用哪个模块，来作为构建其内部依赖图的开始。进入入口起点后，webpack 会找出有哪些模块和库是入口起点（直接和间接）依赖的。</p>
<p>2 出口output<br>output 属性告诉 webpack 在哪里输出它所创建的 bundles，以及如何命名这些文件，默认值为 ./dist。基本上，整个应用程序结构，都会被编译到你指定的输出路径的文件夹中。</p>
<p>3 loader<br>loader 让 webpack 能够去处理那些非 JavaScript 文件（webpack 自身只理解 JavaScript）。loader 可以将所有类型的文件转换为 webpack 能够处理的有效模块，然后你就可以利用 webpack 的打包能力，对它们进行处理。<br>本质上，webpack loader 将所有类型的文件，转换为应用程序的依赖图（和最终的 bundle）可以直接引用的模块。</p>
<p>4 插件plugins<br>loader 被用于转换某些类型的模块，而插件则可以用于执行范围更广的任务。插件的范围包括，从打包优化和压缩，一直到重新定义环境中的变量。插件接口功能极其强大，可以用来处理各种各样的任务。</p>
<p>5 模式（mode）<br>通过选择 development 或 production 之中的一个，来设置 mode 参数，你可以启用相应模式下的 webpack 内置的优化</p>
<h1 id="webpack初体验"><a href="#webpack初体验" class="headerlink" title="webpack初体验"></a>webpack初体验</h1><p>1 首先利用npm初始化环境<br>    npm init<br>2 利用npm安装webpack-cil包，可以通过指令来使用webpack,-g全局安装<br>    npm i webpack webpack-cli -g<br>3 安装开发依赖<br>    npm i webpack webpack-cli -D<br>4 准备工作结束，开始写代码<br>新建两个文件夹，src文件夹，存放初始模块；build：存放打包后的模块<br>src中新建入口文件index.js 该文件是webpack默认的入口起点文件<br>运行指令：<br>开发环境：webpack ./src/index.js -o ./build/built.js –mode=development<br>webpack会以 ./src/index.js 为入口文件开始打包，打包后输出到 ./build/built.js<br>整体打包环境，是开发环境<br>PS C:\Users\ASUS\Desktop\webpack资料\1.webpack基本使用\webpack初体验&gt; webpack ./src/index.js -o ./build/built.js –mode=development<br>输出</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;Hash: d38f6fb5b3d3a4001133</span><br><span class="line">Version: webpack <span class="number">4.43</span><span class="number">.0</span></span><br><span class="line">Time: <span class="number">169</span>ms</span><br><span class="line">Built at: <span class="number">2020</span><span class="number">-07</span><span class="number">-16</span> <span class="number">10</span>:<span class="number">14</span>:<span class="number">47</span></span><br><span class="line">Asset      Size  Chunks             Chunk Names</span><br><span class="line">built.js  <span class="number">4.63</span> KiB    main  [emitted]  main</span><br><span class="line">Entrypoint main = built.js</span><br><span class="line">[./src/index.js] <span class="number">842</span> bytes &#123;main&#125; [built]</span><br></pre></td></tr></table></figure>
<p>生产环境：webpack ./src/index.js -o ./build/built.js –mode=production<br>webpack会以 ./src/index.js 为入口文件开始打包，打包后输出到 ./build/built.js<br>整体打包环境，是生产环境<br>PS C:\Users\ASUS\Desktop\webpack资料\1.webpack基本使用\webpack初体验&gt; webpack ./src/index.js -o ./build/built.js –mode=production<br>输出：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Hash: <span class="number">47</span>d3fd5e30dd54db54e3</span><br><span class="line">Version: webpack <span class="number">4.43</span><span class="number">.0</span></span><br><span class="line">Time: <span class="number">648</span>ms</span><br><span class="line">Built at: <span class="number">2020</span><span class="number">-07</span><span class="number">-16</span> <span class="number">10</span>:<span class="number">17</span>:<span class="number">37</span></span><br><span class="line">   Asset       Size  Chunks             Chunk Names</span><br><span class="line">built.js  <span class="number">973</span> bytes       <span class="number">0</span>  [emitted]  main</span><br><span class="line">Entrypoint main = built.js</span><br><span class="line">[<span class="number">0</span>] ./src/index.js <span class="number">1.22</span> KiB &#123;<span class="number">0</span>&#125; [built]</span><br></pre></td></tr></table></figure>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>webpack能处理js/json资源，不能处理css/img等其他资源<br>生产环境和开发环境将ES6模块化编译成浏览器能识别的模块化~<br>生产环境比开发环境多一个压缩js代码。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://qiao666.github.io/2020/07/16/webpack-%E5%85%A5%E9%97%A8/" data-id="ckcq773g20001icva5ryj09wc" data-title="webpack-入门" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/webpack/" rel="tag">webpack</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-剑指offer-33二叉搜索树的后续遍历序列" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/07/15/%E5%89%91%E6%8C%87offer-33%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%90%8E%E7%BB%AD%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97/" class="article-date">
  <time class="dt-published" datetime="2020-07-15T07:39:18.000Z" itemprop="datePublished">2020-07-15</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%89%91%E6%8C%87offer/">剑指offer</a>►<a class="article-category-link" href="/categories/%E5%89%91%E6%8C%87offer/33%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%90%8E%E7%BB%AD%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97/">33二叉搜索树的后续遍历序列</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/07/15/%E5%89%91%E6%8C%87offer-33%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%90%8E%E7%BB%AD%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97/">剑指offer-33二叉搜索树的后续遍历序列</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="题目描述（中等）"><a href="#题目描述（中等）" class="headerlink" title="题目描述（中等）"></a>题目描述（中等）</h1><p>输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历结果。如果是则返回 true，否则返回 false。假设输入的数组的任意两个数字都互不相同。</p>
<p>参考以下这颗二叉搜索树：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> 5</span><br><span class="line">   &#x2F; \</span><br><span class="line">  2   6</span><br><span class="line"> &#x2F; \</span><br><span class="line">1   3</span><br></pre></td></tr></table></figure>
<p>示例 1：<br>输入: [1,6,3,2,5]<br>输出: false<br>示例 2：<br>输入: [1,3,2,6,5]<br>输出: true<br>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof" target="_blank" rel="noopener">https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof</a></p>
<h1 id="算法分析-代码实现"><a href="#算法分析-代码实现" class="headerlink" title="算法分析+代码实现"></a>算法分析+代码实现</h1><p>二叉搜索树：以根节点为标准，左子节点比根节点大；右子节点比根节点小<br>循环遍历，简单做法<br>将根节点出栈<br>然后根据根节点将原数组分为左右两个子节点数组<br>如果右节点数组的值存在小于根节点的值，则false<br>否则递归两个子数组，取二者返回值的与</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> verifyPostorder = <span class="function"><span class="keyword">function</span>(<span class="params">postorder</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(postorder.length&lt;<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//左子树的值</span></span><br><span class="line">    <span class="keyword">let</span> left =[];</span><br><span class="line">    <span class="comment">//右子树的值</span></span><br><span class="line">    <span class="keyword">let</span> right = [];</span><br><span class="line">    <span class="keyword">let</span> root = postorder.pop()</span><br><span class="line">    <span class="keyword">for</span>(i <span class="keyword">in</span> postorder)&#123;   </span><br><span class="line">        <span class="keyword">if</span>(postorder[i]&lt;root)&#123;</span><br><span class="line">            left.push(postorder[i])</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            right = postorder.slice(i);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//从0~i左子节点 i+1~postorder.length-1右子节点</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> item <span class="keyword">in</span> right)&#123;</span><br><span class="line">        <span class="keyword">if</span>(right[item]&lt;root)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> verifyPostorder(left)&amp;&amp;verifyPostorder(right)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://qiao666.github.io/2020/07/15/%E5%89%91%E6%8C%87offer-33%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%90%8E%E7%BB%AD%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97/" data-id="ckcq773j9000jicvadhsf0eaj" data-title="剑指offer-33二叉搜索树的后续遍历序列" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/" rel="tag">二叉搜索树</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/" rel="tag">后序遍历</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-剑指offer-32从上到下打印二叉树" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/07/15/%E5%89%91%E6%8C%87offer-32%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91/" class="article-date">
  <time class="dt-published" datetime="2020-07-15T06:10:20.000Z" itemprop="datePublished">2020-07-15</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%89%91%E6%8C%87offer/">剑指offer</a>►<a class="article-category-link" href="/categories/%E5%89%91%E6%8C%87offer/32%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91/">32从上到下打印二叉树</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/07/15/%E5%89%91%E6%8C%87offer-32%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91/">剑指offer-32从上到下打印二叉树</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>从上到下打印出二叉树的每个节点，同一层的节点按照从左到右的顺序打印。</p>
<blockquote>
<p>例如:<br>给定二叉树: [3,9,20,null,null,15,7],<br>    3<br>   / <br>  9  20<br>    /  <br>   15   7<br>返回：<br>[3,9,20,15,7]<br>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-lcof" target="_blank" rel="noopener">https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-lcof</a></p>
</blockquote>
<p>2 :从上到下按层打印二叉树，同一层的节点按从左到右的顺序打印，每一层打印到一行。</p>
<blockquote>
<p>例如:<br>给定二叉树: [3,9,20,null,null,15,7],<br>    3<br>   / <br>  9  20<br>    /  <br>   15   7<br>返回其层次遍历结果：<br>[<br>  [3],<br>  [9,20],<br>  [15,7]<br>]<br>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-ii-lcof" target="_blank" rel="noopener">https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-ii-lcof</a></p>
</blockquote>
<h1 id="算法分析-代码实现"><a href="#算法分析-代码实现" class="headerlink" title="算法分析+代码实现"></a>算法分析+代码实现</h1><p>1 利用队列，按顺序存储节点<br>主要思路：<br>当前节点出队时，将当前节点的左右子节点入队<br>js中队列和栈都是通过数组自带的方法实现的：<br>入队：push（）<br>出队：shift（）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> levelOrder = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line"><span class="comment">//空树返回空，由于判断条件和队列长度有关，所以无法判断根节点为空的情况</span></span><br><span class="line"><span class="comment">//需要再加一次判断</span></span><br><span class="line"><span class="keyword">if</span>(!root)&#123;</span><br><span class="line">    <span class="keyword">return</span> [];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> NodeQueue = [];</span><br><span class="line"><span class="keyword">let</span> NodeQueueVal=[];</span><br><span class="line"></span><br><span class="line">NodeQueue.push(root)</span><br><span class="line"><span class="comment">//节点队列不为空,执行出入队列算法</span></span><br><span class="line"><span class="keyword">while</span>(NodeQueue.length)&#123;</span><br><span class="line">	<span class="comment">//保存出队节点</span></span><br><span class="line">    <span class="keyword">let</span> curNode = NodeQueue.shift()</span><br><span class="line">    <span class="comment">//将出队节点的值保存至辅助数组中</span></span><br><span class="line">    <span class="keyword">if</span>(curNode)&#123;</span><br><span class="line">        NodeQueueVal.push(curNode.val)</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//出队节点左右节点不为空，将左右节点入队</span></span><br><span class="line">    <span class="keyword">if</span>(curNode.left)&#123;</span><br><span class="line">        NodeQueue.push(curNode.left);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(curNode.right)&#123;</span><br><span class="line">        NodeQueue.push(curNode.right);</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> NodeQueueVal</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>结果：<br>执行用时：68 ms, 在所有 JavaScript 提交中击败了85.68%的用户<br>内存消耗：36.9 MB, 在所有 JavaScript 提交中击败了100.00%的用户</p>
<p>2 基本思路不变，但是队列存储的是当前层的所有节点值</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> levelOrder = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line"><span class="comment">//空树返回空</span></span><br><span class="line"><span class="keyword">if</span>(!root)&#123;</span><br><span class="line">    <span class="keyword">return</span> [];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> NodeQueue = [root];</span><br><span class="line"><span class="keyword">let</span> NodeQueueVal=[];</span><br><span class="line">   </span><br><span class="line"><span class="comment">//节点队列不为空</span></span><br><span class="line"><span class="keyword">while</span>(NodeQueue.length)&#123;</span><br><span class="line">        <span class="keyword">var</span> tmp = [];</span><br><span class="line">        <span class="keyword">var</span> next = [];</span><br><span class="line">        <span class="keyword">for</span>(item <span class="keyword">of</span> NodeQueue)&#123;</span><br><span class="line">            tmp.push(item.val);</span><br><span class="line">            <span class="keyword">if</span>(item.left)&#123;</span><br><span class="line">                next.push(item.left)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(item.right)&#123;</span><br><span class="line">                next.push(item.right)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        NodeQueue = next;</span><br><span class="line">        NodeQueueVal.push(tmp);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">return</span> NodeQueueVal</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>结果：<br>执行用时：68 ms, 在所有 JavaScript 提交中击败了88.70%的用户<br>内存消耗：37.1 MB, 在所有 JavaScript 提交中击败了100.00%的用户</p>
<h1 id="总结反思"><a href="#总结反思" class="headerlink" title="总结反思"></a>总结反思</h1><p>该题目考察的是队列，多练习多复习，才能将算法和队列结合起来。当明白考察的是队列时，题目就变得简单多了</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://qiao666.github.io/2020/07/15/%E5%89%91%E6%8C%87offer-32%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91/" data-id="ckcq773jk000micvabpyd4vyq" data-title="剑指offer-32从上到下打印二叉树" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/" rel="tag">二叉树</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%98%9F%E5%88%97/" rel="tag">队列</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-剑指offer-31栈的压入弹出序列" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/07/14/%E5%89%91%E6%8C%87offer-31%E6%A0%88%E7%9A%84%E5%8E%8B%E5%85%A5%E5%BC%B9%E5%87%BA%E5%BA%8F%E5%88%97/" class="article-date">
  <time class="dt-published" datetime="2020-07-14T08:32:34.000Z" itemprop="datePublished">2020-07-14</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%89%91%E6%8C%87offer/">剑指offer</a>►<a class="article-category-link" href="/categories/%E5%89%91%E6%8C%87offer/31%E6%A0%88%E7%9A%84%E5%8E%8B%E5%85%A5%E5%BC%B9%E5%87%BA%E5%BA%8F%E5%88%97/">31栈的压入弹出序列</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/07/14/%E5%89%91%E6%8C%87offer-31%E6%A0%88%E7%9A%84%E5%8E%8B%E5%85%A5%E5%BC%B9%E5%87%BA%E5%BA%8F%E5%88%97/">剑指offer-31栈的压入弹出序列</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如，序列 {1,2,3,4,5} 是某栈的压栈序列，序列 {4,5,3,2,1} 是该压栈序列对应的一个弹出序列，但 {4,3,5,1,2} 就不可能是该压栈序列的弹出序列。</p>
<p>示例 1：<br>输入：pushed = [1,2,3,4,5], popped = [4,5,3,2,1]<br>输出：true<br>解释：我们可以按以下顺序执行：<br>push(1), push(2), push(3), push(4), pop() -&gt; 4,<br>push(5), pop() -&gt; 5, pop() -&gt; 3, pop() -&gt; 2, pop() -&gt; 1<br>示例 2：<br>输入：pushed = [1,2,3,4,5], popped = [4,3,5,1,2]<br>输出：false<br>解释：1 不能在 2 之前弹出。</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/zhan-de-ya-ru-dan-chu-xu-lie-lcof" target="_blank" rel="noopener">https://leetcode-cn.com/problems/zhan-de-ya-ru-dan-chu-xu-lie-lcof</a></p>
<h1 id="算法分析-代码实现"><a href="#算法分析-代码实现" class="headerlink" title="算法分析+代码实现"></a>算法分析+代码实现</h1><p>分析</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始代码</span></span><br><span class="line"><span class="keyword">var</span> validateStackSequences = <span class="function"><span class="keyword">function</span>(<span class="params">pushed, popped</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//利用辅助栈来判断当前栈顶元素</span></span><br><span class="line">    <span class="keyword">let</span> stack=[]</span><br><span class="line">    <span class="keyword">let</span> i=<span class="number">0</span>,j=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=pushed.length&amp;&amp;j&lt;=poped.length)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!stack.length)&#123;</span><br><span class="line">            stack.push[pushed[i]]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果出栈元素和栈顶元素不相等时</span></span><br><span class="line">        <span class="keyword">if</span>(stack[stack.length<span class="number">-1</span>]!=popped[j])&#123;</span><br><span class="line">        </span><br><span class="line">            <span class="keyword">if</span>(pushed[i] != popped[j])&#123;</span><br><span class="line">                stack.push(pushed[i])</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//当入站元素和出栈元素相同时，则进行一次出栈入栈操作</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(pushed[i]===popped[j])&#123;</span><br><span class="line">                stack.push(pushed[i]);</span><br><span class="line">                stack.pop()</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            stack.pop();</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> stack.length===<span class="number">0</span></span><br><span class="line">   </span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//简化版代码</span></span><br><span class="line"><span class="keyword">var</span> validateStackSequences = <span class="function"><span class="keyword">function</span>(<span class="params">pushed, popped</span>) </span>&#123; </span><br><span class="line">    <span class="comment">//利用辅助栈来判断当前栈顶元素</span></span><br><span class="line">    <span class="keyword">let</span> stack=[]</span><br><span class="line">    <span class="keyword">let</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(item <span class="keyword">of</span> pushed)&#123;</span><br><span class="line">        <span class="comment">//先入栈</span></span><br><span class="line">        stack.push(item);</span><br><span class="line">        <span class="comment">//如果stack不空且stack栈顶元素和poped数组的当前元素相等</span></span><br><span class="line">        <span class="keyword">while</span>(stack.length&amp;&amp;stack[stack.length<span class="number">-1</span>]===popped[i])&#123;</span><br><span class="line">            stack.pop();</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> stack.length===<span class="number">0</span></span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>结果：二者思路基本一致，所谓的简化指的是代码量上的简化，但是就理解程度来说，未简化版的要更好理解一些<br>执行用时：80 ms, 在所有 JavaScript 提交中击败了54.03%的用户<br>内存消耗：37.3 MB, 在所有 JavaScript 提交中击败了100.00%的用户</p>
<h1 id="总结反思"><a href="#总结反思" class="headerlink" title="总结反思"></a>总结反思</h1><p>同时利用出栈和入栈，只需要考虑当前出栈顺序是否满足即可</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://qiao666.github.io/2020/07/14/%E5%89%91%E6%8C%87offer-31%E6%A0%88%E7%9A%84%E5%8E%8B%E5%85%A5%E5%BC%B9%E5%87%BA%E5%BA%8F%E5%88%97/" data-id="ckcq773iz000gicvaelse79ws" data-title="剑指offer-31栈的压入弹出序列" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%87%BA%E5%85%A5%E6%A0%88/" rel="tag">出入栈</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-剑指offer-30包含min函数的栈" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/07/14/%E5%89%91%E6%8C%87offer-30%E5%8C%85%E5%90%ABmin%E5%87%BD%E6%95%B0%E7%9A%84%E6%A0%88/" class="article-date">
  <time class="dt-published" datetime="2020-07-14T07:45:17.000Z" itemprop="datePublished">2020-07-14</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%89%91%E6%8C%87offer/">剑指offer</a>►<a class="article-category-link" href="/categories/%E5%89%91%E6%8C%87offer/30%E5%8C%85%E5%90%ABmin%E5%87%BD%E6%95%B0%E7%9A%84%E6%A0%88/">30包含min函数的栈</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/07/14/%E5%89%91%E6%8C%87offer-30%E5%8C%85%E5%90%ABmin%E5%87%BD%E6%95%B0%E7%9A%84%E6%A0%88/">剑指offer-30包含min函数的栈</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的 min 函数在该栈中，调用 min、push 及 pop 的时间复杂度都是 O(1)。<br>示例:<br>MinStack minStack = new MinStack();<br>minStack.push(-2);<br>minStack.push(0);<br>minStack.push(-3);<br>minStack.min();   –&gt; 返回 -3.<br>minStack.pop();<br>minStack.top();      –&gt; 返回 0.<br>minStack.min();   –&gt; 返回 -2.</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/bao-han-minhan-shu-de-zhan-lcof" target="_blank" rel="noopener">https://leetcode-cn.com/problems/bao-han-minhan-shu-de-zhan-lcof</a></p>
<h1 id="算法分析-代码实现"><a href="#算法分析-代码实现" class="headerlink" title="算法分析+代码实现"></a>算法分析+代码实现</h1><p>利用辅助栈，每当数据栈中存入新数据时，都要实时更新辅助栈顶的值，保证二者长度相等的同时，辅助栈顶的值为对应数据栈的最小值</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> MinStack = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//实际栈</span></span><br><span class="line">    <span class="keyword">this</span>.stack=[]</span><br><span class="line">    <span class="comment">//辅助栈</span></span><br><span class="line">    <span class="keyword">this</span>.test =[]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">x</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;void&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">MinStack.prototype.push = <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(x!=<span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="comment">//实际栈入栈</span></span><br><span class="line">        <span class="keyword">this</span>.stack.push(x)</span><br><span class="line">        <span class="comment">//如果辅助栈为空，则先将x入栈</span></span><br><span class="line">        <span class="keyword">if</span>(!<span class="keyword">this</span>.test.length)&#123;</span><br><span class="line">            <span class="keyword">this</span>.test.push(x)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果当前值比辅助栈的最小值小，将该数字压入辅助栈</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(x&lt;<span class="keyword">this</span>.test[<span class="keyword">this</span>.test.length<span class="number">-1</span>])&#123;</span><br><span class="line">            <span class="keyword">this</span>.test.push(x)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//将栈顶的元素重新入栈，使辅助栈和原数据栈长度保持一致</span></span><br><span class="line">            <span class="keyword">this</span>.test.push(<span class="keyword">this</span>.test[<span class="keyword">this</span>.test.length<span class="number">-1</span>])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;void&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">MinStack.prototype.pop = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>.stack.length)&#123;</span><br><span class="line">        <span class="comment">//数据栈和辅助栈同时出栈，保证长度一直相等</span></span><br><span class="line">        <span class="keyword">this</span>.test.pop();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.stack.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">MinStack.prototype.top = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//返回数据栈的最上方的值但不出栈</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.stack[<span class="keyword">this</span>.stack.length<span class="number">-1</span>]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">MinStack.prototype.min = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.test[<span class="keyword">this</span>.test.length<span class="number">-1</span>]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>结果：<br>执行用时：124 ms, 在所有 JavaScript 提交中击败了70.34%的用户<br>内存消耗：41.7 MB, 在所有 JavaScript 提交中击败了100.00%的用户</p>
<h1 id="总结反思"><a href="#总结反思" class="headerlink" title="总结反思"></a>总结反思</h1><p>该题目考察的就是一个画图理解的问题，分析时勤动笔，多找一些典型，就能把算法实现</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://qiao666.github.io/2020/07/14/%E5%89%91%E6%8C%87offer-30%E5%8C%85%E5%90%ABmin%E5%87%BD%E6%95%B0%E7%9A%84%E6%A0%88/" data-id="ckcq773j1000hicva16w47wew" data-title="剑指offer-30包含min函数的栈" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%A0%88/" rel="tag">栈</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%87%AA%E5%AE%9A%E4%B9%89%E5%87%BD%E6%95%B0/" rel="tag">自定义函数</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-剑指offer-29顺时针打印矩阵" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/07/13/%E5%89%91%E6%8C%87offer-29%E9%A1%BA%E6%97%B6%E9%92%88%E6%89%93%E5%8D%B0%E7%9F%A9%E9%98%B5/" class="article-date">
  <time class="dt-published" datetime="2020-07-13T12:25:11.000Z" itemprop="datePublished">2020-07-13</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%89%91%E6%8C%87offer/">剑指offer</a>►<a class="article-category-link" href="/categories/%E5%89%91%E6%8C%87offer/29%E9%A1%BA%E6%97%B6%E9%92%88%E6%89%93%E5%8D%B0%E7%9F%A9%E9%98%B5/">29顺时针打印矩阵</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/07/13/%E5%89%91%E6%8C%87offer-29%E9%A1%BA%E6%97%B6%E9%92%88%E6%89%93%E5%8D%B0%E7%9F%A9%E9%98%B5/">剑指offer-29顺时针打印矩阵</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。<br>示例 1：<br>输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]<br>输出：[1,2,3,6,9,8,7,4,5]<br>示例 2：<br>输入：matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]<br>输出：[1,2,3,4,8,12,11,10,9,5,6,7]<br>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/shun-shi-zhen-da-yin-ju-zhen-lcof" target="_blank" rel="noopener">https://leetcode-cn.com/problems/shun-shi-zhen-da-yin-ju-zhen-lcof</a></p>
<h1 id="算法分析-代码实现"><a href="#算法分析-代码实现" class="headerlink" title="算法分析+代码实现"></a>算法分析+代码实现</h1><p>1 一层一层循环，直到最后一层，通过添加判定条件来确定什么时候跳出循环</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> spiralOrder = <span class="function"><span class="keyword">function</span>(<span class="params">matrix</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!matrix.length)&#123;</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> res = [];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> right = matrix[<span class="number">0</span>].length<span class="number">-1</span></span><br><span class="line">    <span class="keyword">let</span> down=matrix.length<span class="number">-1</span></span><br><span class="line">    <span class="keyword">let</span> left = <span class="number">0</span></span><br><span class="line">    <span class="keyword">let</span> up = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span>(left&lt;=right&amp;&amp;up&lt;=down)&#123;</span><br><span class="line">        <span class="comment">//最上边从左到右</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> r=left;r&lt;=right;r++)&#123;</span><br><span class="line">            res.push(matrix[up][r])</span><br><span class="line">        &#125;       </span><br><span class="line">            up++;</span><br><span class="line">        <span class="comment">//最右边从上到下</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> d=up;d&lt;=down;d++)&#123;</span><br><span class="line">            res.push(matrix[d][right])</span><br><span class="line">        &#125;       </span><br><span class="line">            right--;</span><br><span class="line">        <span class="comment">//确定循环结束条件，保证不会多次递归</span></span><br><span class="line">        <span class="keyword">if</span>(up&gt;down||right&lt;left) <span class="keyword">break</span>;      </span><br><span class="line">        </span><br><span class="line">        <span class="comment">//最下边从右到左</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> l =right;l&gt;=left;l--)&#123;</span><br><span class="line">            res.push(matrix[down][l])</span><br><span class="line">        &#125;</span><br><span class="line">            down--;</span><br><span class="line">        <span class="comment">//最左边从下到上</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> u = down;u&gt;=up;u--)&#123;</span><br><span class="line">            res.push(matrix[u][left])</span><br><span class="line">        &#125;</span><br><span class="line">            left++   </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>结果：<br>执行用时：96 ms, 在所有 JavaScript 提交中击败了77.67%的用户<br>内存消耗：39.1 MB, 在所有 JavaScript 提交中击败了100.00%的用户<br>2 思路大致一样，但是只遍历环，最后一行或者最后一列在循环外输出</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> spiralOrder = <span class="function"><span class="keyword">function</span>(<span class="params">matrix</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!matrix.length)&#123;</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> res = [];</span><br><span class="line">    <span class="keyword">let</span> right = matrix[<span class="number">0</span>].length<span class="number">-1</span></span><br><span class="line">    <span class="keyword">let</span> down=matrix.length<span class="number">-1</span></span><br><span class="line">    <span class="keyword">let</span> left = <span class="number">0</span></span><br><span class="line">    <span class="keyword">let</span> up = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span>(left&lt;right&amp;&amp;up&lt;down)&#123;</span><br><span class="line">        <span class="comment">//最上边从左到右</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> r=left;r&lt;right;r++)&#123;</span><br><span class="line">            res.push(matrix[up][r])</span><br><span class="line">        &#125;       </span><br><span class="line">            </span><br><span class="line">        <span class="comment">//最右边从上到下</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> d=up;d&lt;down;d++)&#123;</span><br><span class="line">            res.push(matrix[d][right])</span><br><span class="line">        &#125;       </span><br><span class="line">            </span><br><span class="line">        </span><br><span class="line">        <span class="comment">//最下边从右到左</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> l =right;l&gt;left;l--)&#123;</span><br><span class="line">            res.push(matrix[down][l])</span><br><span class="line">        &#125;</span><br><span class="line">            </span><br><span class="line">        <span class="comment">//最左边从下到上</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> u = down;u&gt;up;u--)&#123;</span><br><span class="line">            res.push(matrix[u][left])</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//循环结束以后，环向内收缩</span></span><br><span class="line">            up++;</span><br><span class="line">            right--;   </span><br><span class="line">            down--; </span><br><span class="line">            left++;  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//注意跳出循环后，判断条件包括了等于号</span></span><br><span class="line">    <span class="comment">//上下相等，只剩中间一行</span></span><br><span class="line">    <span class="keyword">if</span>(up===down)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> r=left;r&lt;=right;r++)&#123;</span><br><span class="line">            res.push(matrix[up][r])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//左右相等，只剩最后一列</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(left===right)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> d=up;d&lt;=down;d++)&#123;</span><br><span class="line">            res.push(matrix[d][right])</span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>结果：<br>执行用时：104 ms, 在所有 JavaScript 提交中击败了45.70%的用户<br>内存消耗：39.6 MB, 在所有 JavaScript 提交中击败了100.00%的用户</p>
<p>链接：<a href="https://leetcode-cn.com/problems/shun-shi-zhen-da-yin-ju-zhen-lcof/solution/shou-hui-tu-jie-liang-chong-bian-li-de-ce-lue-na-c/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/shun-shi-zhen-da-yin-ju-zhen-lcof/solution/shou-hui-tu-jie-liang-chong-bian-li-de-ce-lue-na-c/</a></p>
<h1 id="总结反思"><a href="#总结反思" class="headerlink" title="总结反思"></a>总结反思</h1><p>多列举一些特殊情况来总结循环终止条件<br>同时注意排除特殊情况<br>在js中 []!=null 最好通过array.length来判断该数组是否为空</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://qiao666.github.io/2020/07/13/%E5%89%91%E6%8C%87offer-29%E9%A1%BA%E6%97%B6%E9%92%88%E6%89%93%E5%8D%B0%E7%9F%A9%E9%98%B5/" data-id="ckckhzd4100004sva3thgerrn" data-title="剑指offer-29顺时针打印矩阵" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%9F%A9%E9%98%B5/" rel="tag">矩阵</a></li></ul>

    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/2/">&laquo; 上一页</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><span class="space">&hellip;</span><a class="page-number" href="/page/8/">8</a><a class="extend next" rel="next" href="/page/4/">下一页 &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">分类</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/ES6/">ES6</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/ES6/ES5%E5%9B%9E%E9%A1%BE/">ES5回顾</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/ES6/%E5%B8%B8%E7%94%A8%E5%85%B3%E9%94%AE%E5%AD%97%E5%92%8C%E6%96%B9%E6%B3%95/">常用关键字和方法</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/ES6/%E6%89%A9%E5%B1%95%E9%83%A8%E5%88%86/">扩展部分</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/HEXO%E4%BD%BF%E7%94%A8/">HEXO使用</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/js%E9%AB%98%E7%BA%A7/">js高级</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/js%E9%AB%98%E7%BA%A7/js%E5%9F%BA%E7%A1%80/">js基础</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/js%E9%AB%98%E7%BA%A7/%E5%87%BD%E6%95%B0/">函数</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/js%E9%AB%98%E7%BA%A7/%E5%87%BD%E6%95%B0/%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE/">作用域和作用域链</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/js%E9%AB%98%E7%BA%A7/%E5%87%BD%E6%95%B0/%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E4%B8%8E%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E6%A0%88/">执行上下文与执行上下文栈</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/js%E9%AB%98%E7%BA%A7/%E5%87%BD%E6%95%B0/%E9%97%AD%E5%8C%85/">闭包</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/js%E9%AB%98%E7%BA%A7/%E5%AF%B9%E8%B1%A1/">对象</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/js%E9%AB%98%E7%BA%A7/%E5%AF%B9%E8%B1%A1/%E5%88%9B%E5%BB%BA/">创建</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/js%E9%AB%98%E7%BA%A7/%E5%AF%B9%E8%B1%A1/%E7%BB%A7%E6%89%BF%E6%A8%A1%E5%BC%8F/">继承模式</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/js%E9%AB%98%E7%BA%A7/%E7%BA%BF%E7%A8%8B-%E4%BA%8B%E4%BB%B6/">线程_事件</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/js%E9%AB%98%E7%BA%A7/%E9%9D%A2%E8%AF%95%E9%A2%98/">面试题</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/js%E9%AB%98%E7%BA%A7/%E9%9D%A2%E8%AF%95%E9%A2%98/%E4%B8%8A%E4%B8%8B%E6%96%87%E6%A0%88/">上下文栈</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/js%E9%AB%98%E7%BA%A7/%E9%9D%A2%E8%AF%95%E9%A2%98/%E4%BD%9C%E7%94%A8%E5%9F%9F/">作用域</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/js%E9%AB%98%E7%BA%A7/%E9%9D%A2%E8%AF%95%E9%A2%98/%E5%8E%9F%E5%9E%8B%E9%93%BE/">原型链</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/js%E9%AB%98%E7%BA%A7/%E9%9D%A2%E8%AF%95%E9%A2%98/%E9%97%AD%E5%8C%85/">闭包</a></li></ul></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/webpack/">webpack</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/webpack/%E5%85%A5%E9%97%A8/">入门</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/webpack/%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/">开发环境配置</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%89%91%E6%8C%87offer/">剑指offer</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%89%91%E6%8C%87offer/03-%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97/">03-数组中重复的数字</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%89%91%E6%8C%87offer/04-%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE/">04-二维数组中的查找</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%89%91%E6%8C%87offer/05%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC/">05替换空格</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%89%91%E6%8C%87offer/06%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8/">06从尾到头打印链表</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%89%91%E6%8C%87offer/07%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/">07重建二叉树</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%89%91%E6%8C%87offer/08%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E8%8A%82%E7%82%B9/">08二叉树的下一个节点</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%89%91%E6%8C%87offer/09%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/">09用两个栈实现队列</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%89%91%E6%8C%87offer/11%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97/">11旋转数组最小数字</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%89%91%E6%8C%87offer/12%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E8%B7%AF%E5%BE%84/">12矩阵中的路径</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%89%91%E6%8C%87offer/13%E6%9C%BA%E5%99%A8%E4%BA%BA%E8%BF%90%E5%8A%A8%E8%8C%83%E5%9B%B4/">13机器人运动范围</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%89%91%E6%8C%87offer/14%E5%89%AA%E7%BB%B3%E5%AD%90/">14剪绳子</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%89%91%E6%8C%87offer/15%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%AD1%E7%9A%84%E4%B8%AA%E6%95%B0/">15二进制中1的个数</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%89%91%E6%8C%87offer/16%E6%95%B0%E5%80%BC%E7%9A%84%E6%95%B4%E6%95%B0%E6%AC%A1%E6%96%B9/">16数值的整数次方</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%89%91%E6%8C%87offer/17%E6%89%93%E5%8D%B0%E4%BB%8E1%E5%88%B0%E6%9C%80%E5%A4%A7n%E4%BD%8D%E7%9A%84%E5%8D%81%E8%BF%9B%E5%88%B6%E6%95%B0/">17打印从1到最大n位的十进制数</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%89%91%E6%8C%87offer/18%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E8%8A%82%E7%82%B9/">18删除链表的节点</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%89%91%E6%8C%87offer/19%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E5%8C%B9%E9%85%8D/">19正则表达式的匹配</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%89%91%E6%8C%87offer/20%E8%A1%A8%E7%A4%BA%E6%95%B0%E5%80%BC%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2/">20表示数值的字符串</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%89%91%E6%8C%87offer/21%E8%B0%83%E6%95%B4%E6%95%B0%E7%BB%84%E9%A1%BA%E5%BA%8F%E4%BD%BF%E5%A5%87%E6%95%B0%E4%BD%8D%E4%BA%8E%E5%81%B6%E6%95%B0%E5%89%8D/">21调整数组顺序使奇数位于偶数前</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%89%91%E6%8C%87offer/22%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E8%8A%82%E7%82%B9/">22链表中倒数第k个节点</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%89%91%E6%8C%87offer/24%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/">24反转链表</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%89%91%E6%8C%87offer/25%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8/">25合并两个链表</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%89%91%E6%8C%87offer/26%E6%A0%91%E7%9A%84%E5%AD%90%E7%BB%93%E6%9E%84/">26树的子结构</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%89%91%E6%8C%87offer/27%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%95%9C%E5%83%8F/">27二叉树的镜像</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%89%91%E6%8C%87offer/28%E5%AF%B9%E7%A7%B0%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91/">28对称的二叉树</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%89%91%E6%8C%87offer/29%E9%A1%BA%E6%97%B6%E9%92%88%E6%89%93%E5%8D%B0%E7%9F%A9%E9%98%B5/">29顺时针打印矩阵</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%89%91%E6%8C%87offer/30%E5%8C%85%E5%90%ABmin%E5%87%BD%E6%95%B0%E7%9A%84%E6%A0%88/">30包含min函数的栈</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%89%91%E6%8C%87offer/31%E6%A0%88%E7%9A%84%E5%8E%8B%E5%85%A5%E5%BC%B9%E5%87%BA%E5%BA%8F%E5%88%97/">31栈的压入弹出序列</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%89%91%E6%8C%87offer/32%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91/">32从上到下打印二叉树</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%89%91%E6%8C%87offer/33%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%90%8E%E7%BB%AD%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97/">33二叉搜索树的后续遍历序列</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%89%91%E6%8C%87offer/34%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%92%8C%E4%B8%BA%E6%9F%90%E4%B8%80%E5%80%BC%E7%9A%84%E8%B7%AF%E5%BE%84/">34二叉树中和为某一值的路径</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%89%91%E6%8C%87offer/35%E5%A4%8D%E6%9D%82%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%8D%E5%88%B6/">35复杂链表的复制</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%89%91%E6%8C%87offer/36%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E5%92%8C%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/">36二叉搜索树和双向链表</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%89%91%E6%8C%87offer/37%E5%BA%8F%E5%88%97%E5%8C%96%E4%BA%8C%E5%8F%89%E6%A0%91/">37序列化二叉树</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%89%91%E6%8C%87offer/38%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8E%92%E5%88%97/">38字符串的排列</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%89%91%E6%8C%87offer/39%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E8%B6%85%E8%BF%87%E4%B8%80%E5%8D%8A%E7%9A%84%E6%95%B0%E5%AD%97/">39数组中出现次数超过一半的数字</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%89%91%E6%8C%87offer/40%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0/">40最小的k个数</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%89%91%E6%8C%87offer/41%E6%95%B0%E6%8D%AE%E6%B5%81%E4%B8%AD%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/">41数据流中的中位数</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%89%91%E6%8C%87offer/42%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC/">42连续子数组的最大值</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%89%91%E6%8C%87offer/43-1-n%E6%95%B4%E6%95%B0%E4%B8%AD1%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0/">43 1~n整数中1出现的次数</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%89%91%E6%8C%87offer/44%E6%95%B0%E5%AD%97%E5%BA%8F%E5%88%97%E4%B8%AD%E6%9F%90%E4%B8%80%E4%BD%8D%E7%9A%84%E6%95%B0%E5%AD%97/">44数字序列中某一位的数字</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%89%91%E6%8C%87offer/45%E6%8A%8A%E6%95%B0%E7%BB%84%E6%8E%92%E6%88%90%E6%9C%80%E5%B0%8F%E7%9A%84%E6%95%B0/">45把数组排成最小的数</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%89%91%E6%8C%87offer/46%E6%8A%8A%E6%95%B0%E5%AD%97%E7%BF%BB%E8%AF%91%E6%88%90%E5%AD%97%E7%AC%A6%E4%B8%B2/">46把数字翻译成字符串</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%89%91%E6%8C%87offer/47%E7%A4%BC%E7%89%A9%E7%9A%84%E6%9C%80%E5%A4%A7%E4%BB%B7%E5%80%BC/">47礼物的最大价值</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%89%91%E6%8C%87offer/48%E6%9C%80%E9%95%BF%E4%B8%8D%E9%87%8D%E5%A4%8D%E5%AD%97%E4%B8%B2/">48最长不重复字串</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%89%91%E6%8C%87offer/49%E4%B8%91%E6%95%B0/">49丑数</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%89%91%E6%8C%87offer/50%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E5%AD%97%E7%AC%A6/">50第一个只出现一次的字符</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%89%91%E6%8C%87offer/51%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%80%86%E5%BA%8F%E5%AF%B9/">51数组中的逆序对</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%89%91%E6%8C%87offer/52%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%85%AC%E5%85%B1%E7%BB%93%E7%82%B9/">52两个链表的第一个公共结点</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%89%91%E6%8C%87offer/53%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E6%95%B0%E5%AD%97/">53在排序数组中查找数字</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%89%91%E6%8C%87offer/54%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E7%AC%ACk%E5%A4%A7%E7%BB%93%E7%82%B9/">54二叉搜索树中的第k大结点</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%89%91%E6%8C%87offer/55%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%B7%B1%E5%BA%A6/">55二叉树的深度</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%89%91%E6%8C%87offer/56%E6%95%B0%E7%BB%84%E4%B8%AD%E6%95%B0%E5%AD%97%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0/">56数组中数字出现的次数</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%89%91%E6%8C%87offer/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/">斐波那契数列</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%88%91%E7%9A%84%E4%BA%91%E4%B9%8B%E8%B7%AF/">我的云之路</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%88%91%E7%9A%84%E4%BA%91%E4%B9%8B%E8%B7%AF/ECS%E7%AE%80%E4%BB%8B/">ECS简介</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%9D%82%E8%B0%88/">杂谈</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/ECS/" rel="tag">ECS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ES5/" rel="tag">ES5</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ES6/" rel="tag">ES6</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ES6%E6%89%A9%E5%B1%95/" rel="tag">ES6扩展</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/IEFE/" rel="tag">IEFE</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hash%E8%A1%A8/" rel="tag">hash表</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hexo%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/" rel="tag">hexo基本使用</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/instanceof/" rel="tag">instanceof</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/js/" rel="tag">js</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/js%E5%87%BD%E6%95%B0/" rel="tag">js函数</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/js%E5%AF%B9%E8%B1%A1/" rel="tag">js对象</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/js%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/" rel="tag">js数据类型</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/js%E9%9D%A2%E8%AF%95/" rel="tag">js面试</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/js%E9%AB%98%E7%BA%A7/" rel="tag">js高级</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/map/" rel="tag">map</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/md%E8%AF%AD%E6%B3%95/" rel="tag">md语法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/prototype/" rel="tag">prototype</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/set/" rel="tag">set</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/sort%E6%8E%92%E5%BA%8F/" rel="tag">sort排序</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/this/" rel="tag">this</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/typeof/" rel="tag">typeof</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/vpn/" rel="tag">vpn</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/web-dev-server/" rel="tag">web-dev-server</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/webpack/" rel="tag">webpack</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%B8%89%E6%8C%87%E9%92%88/" rel="tag">三指针</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%B8%8A%E4%B8%8B%E6%96%87%E9%9D%A2%E8%AF%95/" rel="tag">上下文面试</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86/" rel="tag">中序遍历</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BA%8B%E4%BB%B6/" rel="tag">事件</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/" rel="tag">二分查找</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/" rel="tag">二叉搜索树</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/" rel="tag">二叉树</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/" rel="tag">位运算</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BD%9C%E7%94%A8%E5%9F%9F/" rel="tag">作用域</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE/" rel="tag">作用域链</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%85%AB%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98/" rel="tag">八皇后问题</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" rel="tag">内存管理</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/" rel="tag">冒泡排序</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%87%BA%E5%85%A5%E6%A0%88/" rel="tag">出入栈</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92/" rel="tag">函数参数传递</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8/" rel="tag">函数调用</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%88%9B%E5%BB%BA%E6%A8%A1%E5%BC%8F%E6%AF%94%E8%BE%83/" rel="tag">创建模式比较</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%89%91%E6%8C%87offer/" rel="tag">剑指offer</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" rel="tag">动态规划</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8E%9F%E5%9E%8B/" rel="tag">原型</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8E%9F%E5%9E%8B%E9%93%BE/" rel="tag">原型链</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8E%9F%E5%9E%8B%E9%93%BE%E9%9D%A2%E8%AF%95/" rel="tag">原型链面试</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/" rel="tag">双向链表</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8F%8C%E6%8C%87%E9%92%88/" rel="tag">双指针</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/" rel="tag">反转链表</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8F%98%E9%87%8F%E8%B5%8B%E5%80%BC/" rel="tag">变量赋值</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/" rel="tag">后序遍历</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%9B%9E%E6%BA%AF/" rel="tag">回溯</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0/" rel="tag">回调函数</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%9D%97%E7%BA%A7%E4%BD%9C%E7%94%A8%E5%9F%9F/" rel="tag">块级作用域</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%A4%A7%E5%B0%8F%E5%A0%86/" rel="tag">大小堆</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA/" rel="tag">对象创建</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80/" rel="tag">对象基础</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%AF%B9%E8%B1%A1%E7%BB%A7%E6%89%BF/" rel="tag">对象继承</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%BA%8F%E5%88%97%E5%8C%96%E4%BA%8C%E5%8F%89%E6%A0%91/" rel="tag">序列化二叉树</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/" rel="tag">归并排序</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/" rel="tag">快速排序</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87/" rel="tag">执行上下文</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E6%A0%88/" rel="tag">执行上下文栈</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%8A%95%E7%A5%A8%E7%AE%97%E6%B3%95/" rel="tag">投票算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%8E%92%E5%BA%8F/" rel="tag">排序</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/" rel="tag">插入排序</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E5%80%BC%E7%9A%84%E6%95%B4%E6%95%B0%E6%AC%A1%E6%96%B9/" rel="tag">数值的整数次方</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E7%BB%84/" rel="tag">数组</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/" rel="tag">斐波那契数列</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%9F%A5%E6%89%BE%E5%92%8C%E6%8E%92%E5%BA%8F/" rel="tag">查找和排序</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%A0%88/" rel="tag">栈</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/" rel="tag">树的遍历</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%AD%A3%E5%88%99/" rel="tag">正则</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/" rel="tag">正则表达式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%B7%B1%E6%8B%B7%E8%B4%9D/" rel="tag">深拷贝</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/" rel="tag">滑动窗口</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%9F%A9%E9%98%B5/" rel="tag">矩阵</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BA%BF%E7%A8%8B/" rel="tag">线程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%87%AA%E5%AE%9A%E4%B9%89%E5%87%BD%E6%95%B0/" rel="tag">自定义函数</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%A1%A8%E7%A4%BA%E6%95%B0%E5%80%BC%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2/" rel="tag">表示数值的字符串</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/" rel="tag">贪心算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%B5%84%E6%BA%90%E6%89%93%E5%8C%85/" rel="tag">资源打包</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%80%92%E5%BD%92/" rel="tag">递归</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%93%BE%E8%A1%A8/" rel="tag">链表</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%97%AD%E5%8C%85/" rel="tag">闭包</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%98%9F%E5%88%97/" rel="tag">队列</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/" rel="tag">面试题</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/ECS/" style="font-size: 10px;">ECS</a> <a href="/tags/ES5/" style="font-size: 10px;">ES5</a> <a href="/tags/ES6/" style="font-size: 11.25px;">ES6</a> <a href="/tags/ES6%E6%89%A9%E5%B1%95/" style="font-size: 10px;">ES6扩展</a> <a href="/tags/IEFE/" style="font-size: 10px;">IEFE</a> <a href="/tags/hash%E8%A1%A8/" style="font-size: 10px;">hash表</a> <a href="/tags/hexo%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/" style="font-size: 10px;">hexo基本使用</a> <a href="/tags/instanceof/" style="font-size: 10px;">instanceof</a> <a href="/tags/js/" style="font-size: 11.25px;">js</a> <a href="/tags/js%E5%87%BD%E6%95%B0/" style="font-size: 10px;">js函数</a> <a href="/tags/js%E5%AF%B9%E8%B1%A1/" style="font-size: 12.5px;">js对象</a> <a href="/tags/js%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/" style="font-size: 10px;">js数据类型</a> <a href="/tags/js%E9%9D%A2%E8%AF%95/" style="font-size: 11.25px;">js面试</a> <a href="/tags/js%E9%AB%98%E7%BA%A7/" style="font-size: 12.5px;">js高级</a> <a href="/tags/map/" style="font-size: 10px;">map</a> <a href="/tags/md%E8%AF%AD%E6%B3%95/" style="font-size: 10px;">md语法</a> <a href="/tags/prototype/" style="font-size: 10px;">prototype</a> <a href="/tags/set/" style="font-size: 10px;">set</a> <a href="/tags/sort%E6%8E%92%E5%BA%8F/" style="font-size: 10px;">sort排序</a> <a href="/tags/this/" style="font-size: 10px;">this</a> <a href="/tags/typeof/" style="font-size: 10px;">typeof</a> <a href="/tags/vpn/" style="font-size: 10px;">vpn</a> <a href="/tags/web-dev-server/" style="font-size: 10px;">web-dev-server</a> <a href="/tags/webpack/" style="font-size: 10px;">webpack</a> <a href="/tags/%E4%B8%89%E6%8C%87%E9%92%88/" style="font-size: 10px;">三指针</a> <a href="/tags/%E4%B8%8A%E4%B8%8B%E6%96%87%E9%9D%A2%E8%AF%95/" style="font-size: 10px;">上下文面试</a> <a href="/tags/%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86/" style="font-size: 10px;">中序遍历</a> <a href="/tags/%E4%BA%8B%E4%BB%B6/" style="font-size: 10px;">事件</a> <a href="/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/" style="font-size: 11.25px;">二分查找</a> <a href="/tags/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/" style="font-size: 12.5px;">二叉搜索树</a> <a href="/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/" style="font-size: 17.5px;">二叉树</a> <a href="/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/" style="font-size: 11.25px;">位运算</a> <a href="/tags/%E4%BD%9C%E7%94%A8%E5%9F%9F/" style="font-size: 11.25px;">作用域</a> <a href="/tags/%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE/" style="font-size: 10px;">作用域链</a> <a href="/tags/%E5%85%AB%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98/" style="font-size: 10px;">八皇后问题</a> <a href="/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" style="font-size: 10px;">内存管理</a> <a href="/tags/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/" style="font-size: 10px;">冒泡排序</a> <a href="/tags/%E5%87%BA%E5%85%A5%E6%A0%88/" style="font-size: 10px;">出入栈</a> <a href="/tags/%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92/" style="font-size: 10px;">函数参数传递</a> <a href="/tags/%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8/" style="font-size: 10px;">函数调用</a> <a href="/tags/%E5%88%9B%E5%BB%BA%E6%A8%A1%E5%BC%8F%E6%AF%94%E8%BE%83/" style="font-size: 10px;">创建模式比较</a> <a href="/tags/%E5%89%91%E6%8C%87offer/" style="font-size: 20px;">剑指offer</a> <a href="/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" style="font-size: 16.25px;">动态规划</a> <a href="/tags/%E5%8E%9F%E5%9E%8B/" style="font-size: 10px;">原型</a> <a href="/tags/%E5%8E%9F%E5%9E%8B%E9%93%BE/" style="font-size: 10px;">原型链</a> <a href="/tags/%E5%8E%9F%E5%9E%8B%E9%93%BE%E9%9D%A2%E8%AF%95/" style="font-size: 10px;">原型链面试</a> <a href="/tags/%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/" style="font-size: 10px;">双向链表</a> <a href="/tags/%E5%8F%8C%E6%8C%87%E9%92%88/" style="font-size: 17.5px;">双指针</a> <a href="/tags/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/" style="font-size: 10px;">反转链表</a> <a href="/tags/%E5%8F%98%E9%87%8F%E8%B5%8B%E5%80%BC/" style="font-size: 10px;">变量赋值</a> <a href="/tags/%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/" style="font-size: 10px;">后序遍历</a> <a href="/tags/%E5%9B%9E%E6%BA%AF/" style="font-size: 11.25px;">回溯</a> <a href="/tags/%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0/" style="font-size: 10px;">回调函数</a> <a href="/tags/%E5%9D%97%E7%BA%A7%E4%BD%9C%E7%94%A8%E5%9F%9F/" style="font-size: 10px;">块级作用域</a> <a href="/tags/%E5%A4%A7%E5%B0%8F%E5%A0%86/" style="font-size: 10px;">大小堆</a> <a href="/tags/%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA/" style="font-size: 10px;">对象创建</a> <a href="/tags/%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80/" style="font-size: 10px;">对象基础</a> <a href="/tags/%E5%AF%B9%E8%B1%A1%E7%BB%A7%E6%89%BF/" style="font-size: 10px;">对象继承</a> <a href="/tags/%E5%BA%8F%E5%88%97%E5%8C%96%E4%BA%8C%E5%8F%89%E6%A0%91/" style="font-size: 10px;">序列化二叉树</a> <a href="/tags/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/" style="font-size: 10px;">归并排序</a> <a href="/tags/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/" style="font-size: 10px;">快速排序</a> <a href="/tags/%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87/" style="font-size: 10px;">执行上下文</a> <a href="/tags/%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E6%A0%88/" style="font-size: 10px;">执行上下文栈</a> <a href="/tags/%E6%8A%95%E7%A5%A8%E7%AE%97%E6%B3%95/" style="font-size: 10px;">投票算法</a> <a href="/tags/%E6%8E%92%E5%BA%8F/" style="font-size: 10px;">排序</a> <a href="/tags/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/" style="font-size: 10px;">插入排序</a> <a href="/tags/%E6%95%B0%E5%80%BC%E7%9A%84%E6%95%B4%E6%95%B0%E6%AC%A1%E6%96%B9/" style="font-size: 10px;">数值的整数次方</a> <a href="/tags/%E6%95%B0%E7%BB%84/" style="font-size: 10px;">数组</a> <a href="/tags/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/" style="font-size: 10px;">斐波那契数列</a> <a href="/tags/%E6%9F%A5%E6%89%BE%E5%92%8C%E6%8E%92%E5%BA%8F/" style="font-size: 10px;">查找和排序</a> <a href="/tags/%E6%A0%88/" style="font-size: 12.5px;">栈</a> <a href="/tags/%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/" style="font-size: 10px;">树的遍历</a> <a href="/tags/%E6%AD%A3%E5%88%99/" style="font-size: 10px;">正则</a> <a href="/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/" style="font-size: 10px;">正则表达式</a> <a href="/tags/%E6%B7%B1%E6%8B%B7%E8%B4%9D/" style="font-size: 10px;">深拷贝</a> <a href="/tags/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/" style="font-size: 10px;">滑动窗口</a> <a href="/tags/%E7%9F%A9%E9%98%B5/" style="font-size: 10px;">矩阵</a> <a href="/tags/%E7%BA%BF%E7%A8%8B/" style="font-size: 10px;">线程</a> <a href="/tags/%E8%87%AA%E5%AE%9A%E4%B9%89%E5%87%BD%E6%95%B0/" style="font-size: 10px;">自定义函数</a> <a href="/tags/%E8%A1%A8%E7%A4%BA%E6%95%B0%E5%80%BC%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2/" style="font-size: 10px;">表示数值的字符串</a> <a href="/tags/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/" style="font-size: 10px;">贪心算法</a> <a href="/tags/%E8%B5%84%E6%BA%90%E6%89%93%E5%8C%85/" style="font-size: 10px;">资源打包</a> <a href="/tags/%E9%80%92%E5%BD%92/" style="font-size: 18.75px;">递归</a> <a href="/tags/%E9%93%BE%E8%A1%A8/" style="font-size: 15px;">链表</a> <a href="/tags/%E9%97%AD%E5%8C%85/" style="font-size: 11.25px;">闭包</a> <a href="/tags/%E9%98%9F%E5%88%97/" style="font-size: 13.75px;">队列</a> <a href="/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/" style="font-size: 11.25px;">面试题</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/07/">七月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/06/">六月 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/07/31/%E5%89%91%E6%8C%87offer-56%E6%95%B0%E7%BB%84%E4%B8%AD%E6%95%B0%E5%AD%97%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0/">剑指offer-56数组中数字出现的次数</a>
          </li>
        
          <li>
            <a href="/2020/07/31/%E5%89%91%E6%8C%87offer-55%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%B7%B1%E5%BA%A6/">剑指offer-55二叉树的深度</a>
          </li>
        
          <li>
            <a href="/2020/07/31/%E5%89%91%E6%8C%87offer-54%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E7%AC%ACk%E5%A4%A7%E7%BB%93%E7%82%B9/">剑指offer-54二叉搜索树中的第k大结点</a>
          </li>
        
          <li>
            <a href="/2020/07/30/%E5%89%91%E6%8C%87offer-53%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E6%95%B0%E5%AD%97/">剑指offer-53在排序数组中查找数字</a>
          </li>
        
          <li>
            <a href="/2020/07/30/%E5%89%91%E6%8C%87offer-52%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%85%AC%E5%85%B1%E7%BB%93%E7%82%B9/">剑指offer-52两个链表的第一个公共结点</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 Qiao666<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">主页</a>
  
    <a href="/archives" class="mobile-nav-link">归档</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>